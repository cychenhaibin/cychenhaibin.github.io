<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Camila&#39;s blog</title>
  
  
  <link href="http://cychenhaibin.github.io/atom.xml" rel="self"/>
  
  <link href="http://cychenhaibin.github.io/"/>
  <updated>2024-10-13T04:25:28.000Z</updated>
  <id>http://cychenhaibin.github.io/</id>
  
  <author>
    <name>Camila</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://cychenhaibin.github.io/2024/10/13/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/10/13/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-10-13T04:22:47.000Z</published>
    <updated>2024-10-13T04:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。</p><p>平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道，所以它会保持10个对象的引用。当程序的规模增大，对象会越来越多，它们之间的关系也越来越复杂，难免会形成网状的交叉引用。当我们改变或删除其中个对象的时候，很可能需要通知所有引用到它的对象。这样一来，就像在心脏旁边拆掉一根毛细血管一般，唯一点很小的修改也必须小心翼翼。</p><p><img src="D:\Desktop\前端\img\image-20241008211245435.png" alt="image-20241008211245435"></p><p>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。</p><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。</p><p><img src="D:\Desktop\前端\img\image-20241008223351989.png" alt="image-20241008223351989"></p><h3 id="一、现实中的中介者"><a href="#一、现实中的中介者" class="headerlink" title="一、现实中的中介者"></a>一、现实中的中介者</h3><ol><li><h4 id="机场指挥塔"><a href="#机场指挥塔" class="headerlink" title="机场指挥塔"></a>机场指挥塔</h4><p>中介者也被称为调停者，我们想象一下机场的指挥塔，如果没有指挥塔的存在，每架飞机要和方圆100公里内的所有飞机通信，才能确定航线以及飞行状况，后果是不可想象的。现实中的情况是，每架飞机都只需要和指挥塔通信。指挥塔作为调停者，知道每一架飞机的飞行状况，所以它可以安排所有飞机的起降时间，及时做出航线调整。</p></li><li><h4 id="博彩公司"><a href="#博彩公司" class="headerlink" title="博彩公司"></a>博彩公司</h4><p>打麻将的人经常遇到这样的问题，打了几局之后开始计算钱，A自摸了两把，B杠了三次，C点炮一次给D，谁应该给谁多少钱已经很难计算清楚，而这还是在只有4个人参与的情况下。</p><p>在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能实现的事情。有了博彩公司作为中介，每个人只需和博彩公司发生关联，博彩公同会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就交给博彩公司。</p></li></ol><h3 id="二、中介者模式的例子——购买商品"><a href="#二、中介者模式的例子——购买商品" class="headerlink" title="二、中介者模式的例子——购买商品"></a>二、中介者模式的例子——购买商品</h3><p>假设我们正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输人购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，我们需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量,按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车。</p><p>这个需求是非常容易实现的，假设我们已经提前从后台获取到了所有颜色手机的库存量:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="string">&quot;red&quot;</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>:<span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么页面有可能显示为如下几种场景：</p><ul><li>选择红色手机，购买4个，库存不足。</li><li>选择蓝色手机，购买5个，库存充足，可以加入购物车。</li><li>或者是没有输入购买数量的时候，按钮将被禁用并显示相应提示。</li></ul><p>我们大概已经能够猜到，接下来将遇到至少5个节点，分别是：</p><ul><li>下拉选择框 colorSelect</li><li>文本输入框 numberInput</li><li>展示颜色信息 colorInfo</li><li>展示购买商品数量信息 numberInfo</li><li>决定下一步操作的按钮 nextBtn</li></ul><ol><li><h4 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h4><p>从编写HTML开始：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;colorSelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入购买数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;numberInput&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;colorInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;numberInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;nextBtn&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>请选择手机颜色和购买数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来监听colorSelect的onchange事件函数和numberInput的oninput事件函数，然后在这两个事件中作出相应的处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorSelect&#x27;</span>),</span><br><span class="line">    numberInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInput&#x27;</span>),</span><br><span class="line">    colorInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorInfo&#x27;</span>),</span><br><span class="line">    numberInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInfo&#x27;</span>),</span><br><span class="line">    nextBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nextBtn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="string">&quot;red&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">colorSelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="variable language_">this</span>.<span class="property">value</span>,  <span class="comment">// 颜色</span></span><br><span class="line">        number = numberInput.<span class="property">value</span>,  <span class="comment">// 数量</span></span><br><span class="line">        stock = goods[color];  <span class="comment">// 该颜色手机对应的当前库存</span></span><br><span class="line">    </span><br><span class="line">    colorInfo.<span class="property">innerHTML</span> = color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!color)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInter</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="对象之间的联系"><a href="#对象之间的联系" class="headerlink" title="对象之间的联系"></a>对象之间的联系</h4><p>来考虑一下，当触发了colorselect 的onchange之后，会发生什么事情。</p><p>首先我们要让colorInfo中显示当前选中的颜色，然后获取用户当前输人的购买数量，对用户的输人值进行一些合法性判断。再根据库存数量来判断nextBtn的显示状态。</p><p>别忘了，还要编写numberInput的事件相关代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbernput.<span class="property">oninput</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = colorSelect.<span class="property">value</span>,    <span class="comment">// 颜色</span></span><br><span class="line">        number = <span class="variable language_">this</span>.<span class="property">value</span>,          <span class="comment">// 数量</span></span><br><span class="line">        stock = goods[color ];        <span class="comment">//该颜色子机对应的当前库存</span></span><br><span class="line">    </span><br><span class="line">    numberInfo.<span class="property">innerHML</span> = number;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!color )&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTM</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(((number - <span class="number">0</span>) | <span class="number">0</span>) !== number - <span class="number">0</span>)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTM</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="可能遇到的困难"><a href="#可能遇到的困难" class="headerlink" title="可能遇到的困难"></a>可能遇到的困难</h4><p>虽然目前顺利完成了代码编写，但随之而来的需求改变有可能给我们带来麻烦。假设现在要求去掉colorInfo和numberInfo这两个展示区域，我们就要分别改动 colorselect.onchange和numberInput. oninput里面的代码，因为在先前的代码中，这些对象确实是耦合在一起的。</p><p>目前我们面临的对象还不算太多，当这个页面里的节点激曾到10个或者15个时，它们之间的联系可能变得更加错综复杂，任何一次改动都将变得很棘手。为了证实这一点，我们假设页面中将新增另外一个下拉选择框，代表选择手机内存。现在我们需要计算颜色、内存和购买数量，来判断nextBtn是显示库存不足还是放人购物车。</p><p>首先我们要增加两个HTML汇节点：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;colorSelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择内存：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;memorySelect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;32G&quot;</span>&gt;</span>32G<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;64G&quot;</span>&gt;</span>64G<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入购买数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;numberInput&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择颜色：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;colorInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    选择内存：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;memoryInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    输入数量：</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;numberInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;nextBtn&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>请选择手机颜色和购买数量<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorSelect&#x27;</span>),</span><br><span class="line">    numberInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInput&#x27;</span>),</span><br><span class="line">    colorInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;colorInfo&#x27;</span>),</span><br><span class="line">    numberInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;numberInfo&#x27;</span>),</span><br><span class="line">    memoryInfo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;memoryInfo&#x27;</span>),</span><br><span class="line">    nextBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nextBtn&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来修改表示库存的JSON对象以及修改colorSelect的onchange事件函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="string">&quot;red|3G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;red|16G&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;blue|32G&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;blue|16G&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">colorSelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">var</span> memory = memorySelect.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">var</span> stock = goods[color + <span class="string">&#x27;|&#x27;</span> + memory];</span><br><span class="line"></span><br><span class="line">  number = numberInput.<span class="property">value</span>,</span><br><span class="line">  colorInfo.<span class="property">innerHTML</span> = color;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!color)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!memory)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择内存大小&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然同样改写numberInput的事件相关代码，具体代码的改变跟colorSelect大同小异，最后还要新增memorySelect的onchange事件函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">memorySelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = colorSelect.<span class="property">value</span>, </span><br><span class="line">        memory = <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">        memory = <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">        stock = goods[color + <span class="string">&#x27;|&#x27;</span> + memory];</span><br><span class="line">    memoryInfo.<span class="property">innerHTML</span> = memory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!color)&#123;</span><br><span class="line">        nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">        nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择手机颜色&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!memory)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择内存大小&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仅仅是增加了一个内存的选择条件，就要改变如此多的代码，这是因为在目前的实现中，每个节点对象都是耦合在一起的，改变或者增加任何一个节点对象，都要通知到与其相关的对象。</p></li><li><h4 id="引入中介者"><a href="#引入中介者" class="headerlink" title="引入中介者"></a>引入中介者</h4><p>现在引入中介者对象，所有的节点对象只跟中介者通信。当下拉框colorSelect、memorySelect和文本输入框numberInput发生了事件行为时，它们仅仅通知中介者它们被改变了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需改动中介者对象里的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="string">&quot;red|3G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;red|16G&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;blue|32G&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;blue|16G&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> colorSelect = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;colorSelect&#x27;</span>),</span><br><span class="line">        memorySelect = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;memorySelect&#x27;</span>),</span><br><span class="line">        colorInfo = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;colorInfo&#x27;</span>),</span><br><span class="line">        memoryInfo = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;memoryInfo&#x27;</span>),</span><br><span class="line">        numberInfo = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;numberInfo&#x27;</span>),</span><br><span class="line">        nextBtn = <span class="variable language_">document</span>.<span class="title function_">getElementsById</span>(<span class="string">&#x27;nextBtn&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">changed</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> color = colorSelect.<span class="property">value</span>,</span><br><span class="line">                memory = memorySelect.<span class="property">value</span>,</span><br><span class="line">                number = numberInput.<span class="property">value</span>,</span><br><span class="line">                stock = goods[color + <span class="string">&#x27;|&#x27;</span> + memory];</span><br><span class="line">            <span class="keyword">if</span>(obj === colorSelect)&#123;</span><br><span class="line">                colorInfo.<span class="property">innerHTML</span> = color;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj === memorySelect)&#123;</span><br><span class="line">                memoryInfo.<span class="property">innerHTML</span> = memory;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj === numberInput)&#123;</span><br><span class="line">                numberInfo.<span class="property">innerHTML</span> = number;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!memory)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请选择内存大小&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(number - <span class="number">0</span>) &amp;&amp; number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;请输入正确的购买数量&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(number &gt; stock)&#123;</span><br><span class="line">    nextBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;库存不足&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nextBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  nextBtn.<span class="property">innerHTML</span> = <span class="string">&#x27;放入购物车&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件函数</span></span><br><span class="line">colorSelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    mediator.<span class="title function_">changed</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    mediator.<span class="title function_">changed</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.<span class="property">onInput</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    mediator.<span class="title function_">changed</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以想象，某天我们又要新增一些跟需求相关的节点，比如CPU型号，那我们只需要稍稍改动mediator对象即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="string">&quot;red|3G&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;red|16G&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;blue|32G&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;blue|16G&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cpuSelect = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;cpuSelect&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">change</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> cpu = cpuSelect.<span class="property">value</span>,</span><br><span class="line">                stock = goods[color + <span class="string">&#x27;|&#x27;</span> + momory + <span class="string">&#x27;|&#x27;</span> +cpu];</span><br><span class="line">            <span class="keyword">if</span>(obj === cpuSelect)&#123;</span><br><span class="line">                cpuInfo.<span class="property">innerHTML</span> = cpu;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象(类似不和陌生人说话）。如果对象之间的拥合性太高，一个对象发生改变之后，难免会影响到其他的象，跟“城门失火，殃及池鱼”的道理是一样的。而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。</p><p>因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。</p><p>不过，中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p><p>我们都知道，毒贩子虽然使吸毒者和制毒者之间的耦合度降低，但毒贩子也要抽走一部分利润。同样，在程序中，中介者对象要占去一部分内存。而且毒贩本身还要防止被警察抓住，因为它了解整个犯罪链条中的所有关系，这表明中介者对象自身往往是一个难以维护的对象。</p><p>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们生活的世界中，每个人每个物体之间都会产生一些错综复杂的联系。在应用程序里也一样，程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。&lt;/p&gt;
&lt;p&gt;平时我们大概能记住10个朋友的电话、30家餐馆的位置。在程序里，也许一个对象会和其他10个对象打交道，</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="http://cychenhaibin.github.io/2024/10/12/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://cychenhaibin.github.io/2024/10/12/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/</id>
    <published>2024-10-12T03:43:47.000Z</published>
    <updated>2024-10-13T05:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我第一次接触计网东西的时候是前端的浏览器页面右击检查，点开Network，发现里面的东西都不大了解，甚至看不懂这些是什么，但我知道这是和后端交互，给后端发送请求，学习计网时我的基础也只有2xx、3xx、4xx、5xx这些状态码的含义。其他一概不知。学习计网的第一天也是我实习的第一天。</p><p>计网的学习可以参照三本书<strong>《图解 TCP&#x2F;IP》</strong>、<strong>《图解 HTTP》</strong>、<strong>《网络是怎么连接的》</strong>和 <strong>小林coding</strong>：<a href="https://xiaolincoding.com/%EF%BC%8C%E6%9C%AC%E7%AB%99%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%A1%E7%BD%91%E6%9C%89%E5%85%B3%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%83%BD%E6%98%AF%E5%9C%A8%E5%B0%8F%E6%9E%97coding%E4%B8%8A%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E5%86%99%E7%9A%84%E3%80%82">https://xiaolincoding.com/，本站的所有计网有关的博客都是在小林coding上基于自己的理解写的。</a></p><p>接下来让我们开启计网的学习！</p><h2 id="2024-10-8"><a href="#2024-10-8" class="headerlink" title="2024.10.8"></a>2024.10.8</h2><p><em><strong>当键入网址后，到页面显示，其间发生了什么</strong></em> 这个面试题是我第一次面试时被面试官问到了，当时答的一塌糊涂，完全是想到什么说什么。</p><p>下面就用小林coding里面的网络拓扑模型作为例子，看看里面会发生什么？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg" alt="简单的网络模型"></p><p><strong>首先浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息。</strong></p><p>url里面有什么？见下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg" alt="URL 解析"></p><p>其中http和https是访问协议，其区别是 ：</p><blockquote><p><strong>HTTP</strong> 是以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。默认工作在 TCP 协议 80 端口。</p><p><strong>HTTPS</strong> 是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL&#x2F;TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。默认工作在 TCP 协议443端口。</p></blockquote><p>服务器名后面跟着的就是请求服务器里的文件资源。</p><p><strong>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</strong></p><h3 id="真实地址查询-——-DNS"><a href="#真实地址查询-——-DNS" class="headerlink" title="真实地址查询 —— DNS"></a>真实地址查询 —— DNS</h3><p><strong>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。</strong></p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p><p>所以，有一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p><p>例如：<a href="http://www.server.com.,这个最后的一个点代表根域名.`.`根域是在最顶层,它的下一层就是/">www.server.com.，这个最后的一个点代表根域名。`.`根域是在最顶层，它的下一层就是</a> <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p>域名解析的工作流程：【小林coding里面写的很详细，在这里使用小林coding的图来展示】</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程"></p><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p><h2 id="2024-10-9"><a href="#2024-10-9" class="headerlink" title="2024.10.9"></a>2024.10.9</h2><p>昨天<em><strong>当键入网址后，到页面显示，其间发生了什么</strong></em> 这个问题还没写完，今天继续！</p><h3 id="指南好帮手-——-协议栈"><a href="#指南好帮手-——-协议栈" class="headerlink" title="指南好帮手 —— 协议栈"></a>指南好帮手 —— 协议栈</h3><p><strong>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</strong></p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img"></p><h3 id="可靠传输-——-TCP"><a href="#可靠传输-——-TCP" class="headerlink" title="可靠传输 —— TCP"></a>可靠传输 —— TCP</h3><p>HTTP 是基于 TCP 协议传输的，先了解一下TCP协议。</p><p>TCP 传输数据之前，要先三次握手建立连接：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>用TCP协议把数据包送出去后，TCP不会对传达后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和ACK。</p><p>发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><h2 id="2024-10-10"><a href="#2024-10-10" class="headerlink" title="2024.10.10"></a>2024.10.10</h2><h2 id="远程定位-——-IP"><a href="#远程定位-——-IP" class="headerlink" title="远程定位 —— IP"></a>远程定位 —— IP</h2><p>TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成 <strong>网络包</strong> 发送给通信对象。</p><p>在IP协议里面需要有<strong>源地址IP</strong>和<strong>目标地址IP</strong>：</p><ul><li>源地址IP，时客户端输出的IP地址；</li><li>目标地址，通过DNS域名解析得到的Web服务器IP。</li></ul><h2 id="两点传输-——-MAC"><a href="#两点传输-——-MAC" class="headerlink" title="两点传输 —— MAC"></a>两点传输 —— MAC</h2><p><strong>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。</strong></p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><p><code>0800</code>：IP协议</p></li><li><p><code>0806</code>：ARP协议</p></li></ul><blockquote><p>MAC发送方和接收方如何确认？</p></blockquote><p><strong>发送方</strong>的MAC地址获取就比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读取出来写入到MAC头部就可以了。</p><p><strong>接收方</strong>的MAC地址就有点复杂了，只要告诉以太网对方的MAC的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的MAC地址。</p><p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的MAC地址。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg" alt="ARP 广播"></p><p>ARP协议会在以太网中以 <strong>广播</strong> 的形式，对以太网所有的设备喊出：”这个IP地址是谁的？请把你的MAC地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><blockquote><p>好像每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p><ul><li>先查询ARP缓存，如果其中已经保存了对方的MAC地址，就不需要发送ARP查询，直接使用ARP缓存中的地址。</li><li>而当ARP缓存中不存在对方MAC地址时，则发送ARP广播查询</li></ul><blockquote><p>查看 ARP 缓存内容</p></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg" alt="ARP 缓存内容"></p><h3 id="出口——网卡"><a href="#出口——网卡" class="headerlink" title="出口——网卡"></a>出口——网卡</h3><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><h3 id="送别者——交换机"><a href="#送别者——交换机" class="headerlink" title="送别者——交换机"></a>送别者——交换机</h3><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC层，也称为<strong>二层网络设备</strong>。</p><blockquote><p>交换机的包接收操作</p></blockquote><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有MAC地址，并通过核对接收到的包的接收方MAC地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg" alt="交换机的 MAC 地址表"></p><p>如果收到的包的接收方 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><blockquote><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p><p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p><p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="2024-10-12"><a href="#2024-10-12" class="headerlink" title="2024.10.12"></a>2024.10.12</h2><p>昨天太忙了。。。</p><h3 id="出境大门——路由器"><a href="#出境大门——路由器" class="headerlink" title="出境大门——路由器"></a>出境大门——路由器</h3><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><blockquote><p>路由器与交换机的区别</p></blockquote><ul><li>因为 <strong>路由器</strong> 是基于IP设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而 <strong>交换机</strong> 是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><blockquote><p>路由器基本原理</p></blockquote><p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><blockquote><p>路由器的包接收操作</p></blockquote><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><blockquote><p>查询路由表确定输出端口</p></blockquote><p><strong>完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。</strong></p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" alt="路由器转发"></p><blockquote><p>路由器的发送操作</p></blockquote><p>进入包的<strong>发送操作</strong></p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h3 id="相互扒皮——服务器-与-客户端"><a href="#相互扒皮——服务器-与-客户端" class="headerlink" title="相互扒皮——服务器 与 客户端"></a>相互扒皮——服务器 与 客户端</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" alt="网络分层模型"></p><p>至此，<strong>当键入网址后，到页面显示，其间发生了什么？</strong>就是全部内容了。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>[小林coding]:<a href="https://xiaolincoding.com/network/1_base/what_happen_url.html#%E4%BA%92%E7%9B%B8%E6%89%92%E7%9A%AE-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%8E-%E5%AE%A2%E6%88%B7%E7%AB%AF">https://xiaolincoding.com/network/1_base/what_happen_url.html#%E4%BA%92%E7%9B%B8%E6%89%92%E7%9A%AE-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%8E-%E5%AE%A2%E6%88%B7%E7%AB%AF</a>“小林coding”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我第一次接触计网东西的时候是前端的浏览器页面右击检查，点开Network，发现里面的东西都不大了解，甚至看不懂这些是什么，但我知道这是和后端交互，给后端发送请求，学习计网时我的基础也只有2xx、3xx、4xx、5xx这些状态码的含义。其他一概不知。学习计网的第一天也是我实</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://cychenhaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="http://cychenhaibin.github.io/2024/10/07/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/10/07/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-10-07T09:21:47.000Z</published>
    <updated>2024-10-07T10:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>职责链的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间传递，直到遇到一个可以处理它的对象，我们把这些对象称为链中的节点。</p><h3 id="一、现实中的职责链模式"><a href="#一、现实中的职责链模式" class="headerlink" title="一、现实中的职责链模式"></a>一、现实中的职责链模式</h3><p>职责链的模式在现实中并不难找到，以下就是两个常见的跟职责链模式有关的场景：</p><ul><li>如果早高峰能顺利挤上公交车的话，那么估计这一天都会过的很开心。因为公交车上人实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在N个人手上传递，才能最终到达售票员的手里。</li><li>中学时代的期末考试，如果你平时不太老实，考试时就会被安排在第一个位置。遇到不会答的题目，就把题目编号写在小纸条上往后传递，坐在后面的同学如果也不会答，他就会把这张小纸条继续递给他后面的人。</li></ul><p>从这两个例子中，我们很容易找到职责链模式的最大优点：请求发送者只需要知道链中第一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公车上，我就得先搞清楚谁是售票员，才能把硬币遂给他。同样，在期末考试中，也许我就要先了解同学中有哪些可以解答这道题。</p><h3 id="二、实际开发中的职责链模式"><a href="#二、实际开发中的职责链模式" class="headerlink" title="二、实际开发中的职责链模式"></a>二、实际开发中的职责链模式</h3><p>假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮预定后(订单已在此时生成)，现在已经到了正式购买的阶段。</p><p>公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况下不一定保证能买到。</p><p>我们的订单页面是PIP吐出的模板，在页面加载之初，PTIP会传递给页面几个字段。</p><ul><li>orderType：表示订单类型(定金用户或者普通购买用户)code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3的时候是普通购买用户。</li><li>pay：表示用户是否已经支付定金，值为true或者false，虽然用户已经下过500元定金的订单，但如果他一直没有支付定金，现在只能降级进入普通购买模式。</li><li>stock：表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受此限制。</li></ul><p>下面我们把这个流程写成代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(order <span class="title class_">Type</span> === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pay === <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(order <span class="title class_">Type</span> === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pay === <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200元定金预购，得到50优惠券&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(order <span class="title class_">Type</span> === <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们得到了意料中的运行结果，但这远远算不上一段值得夸奖的代码。order函数不仅巨大到难以阅读，而且需要经常进行修改。虽然目前项目能正常运行，但接下来的维护工作无疑是个梦麗。恐怕只有最“新手”的程序员才会写出这样的代码。</p><h3 id="三、用职责链模式重构代码"><a href="#三、用职责链模式重构代码" class="headerlink" title="三、用职责链模式重构代码"></a>三、用职责链模式重构代码</h3><p>现在我们采用职责链模式重构这段代码，先把500元订单、200元订单以及普通购买分成3个函数。</p><p>接下来把orderType、pay、stock这3个字段当作参数传递给500元订单两数，如果该函数不符合处理条件，则把这个请求传递给后面的200元订单函数，如果200元订单函数依然不能处理该请求，则继续传递请求给普通购买函数，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 500订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">order200</span>(orderType, pay, stock);  <span class="comment">// 将请求传递给200元订单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200元订单</span></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200元定金预购，得到50优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">orderNormal</span>(orderType, pay, stock);  <span class="comment">// 将请求传递给普通订单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通购买订单</span></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，执行结果和前面那个巨大的order函数完全一样，但是代码的结构已经清晰了很多，我们把一个大函数拆分了3个小函数，去掉了许多嵌套的条件分支语句。</p><p>目前已经有了不小的进步，但我们不会满足于此，虽然已经把大函数拆分成了互不影响的3个小函数，但可以看到，请求在链条传递中的顺序非常僵硬，传递请求的代码被耦合在了业务函数之中:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order500 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">order200</span>(orderType, pay, stock);  <span class="comment">// order500 和 order200 耦合在一起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这依然是违反开放-封闭原则的，如果有天我们要增加300元预订或者去掉200元预订，意味着就必须改动这些业务函数内部。就像一根环环相扣打了死结的链条，如果要增加、拆除或者移动一个节点，就必须得先砸烂这根链条。</p><h3 id="四、灵活拆分职责链节点"><a href="#四、灵活拆分职责链节点" class="headerlink" title="四、灵活拆分职责链节点"></a>四、灵活拆分职责链节点</h3><p>我们采用一种更灵活的方式，来改进上面的职责链模式，目标是让链中的各个节点可以灵活拆分和重组。</p><p>首先需要改写一下分别表示3种购买模式的节点函数，我们约定，如果某个节点不能处理请求，则返回一个特定的字符串 ‘nextSuccessor’来表示该请求需要继续往后面传递：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 500订单</span></span><br><span class="line"><span class="keyword">var</span> order500 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;500元定金预购，得到100优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;nextSuccessor&#x27;</span>;    <span class="comment">// 我不知道下一个节点是谁，反正把请求往后传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 200元订单</span></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;200元定金预购，得到50优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;nextSuccessor&#x27;</span>;    <span class="comment">// 我不知道下一个节点是谁，反正把请求往后传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通购买订单</span></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(stock &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通购买，无优惠券&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;手机库存不足&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来需要把丽数包装进职责链节点，我们定义一个构造的数 Chain，在new Chain 的时候传递的参数即为需要被包装的丽数，同时它还拥有一个实例属性this.successor，表示在链中的下一个节点。</p><p>此外Chain的prototype中还有两个函数，它们的作用如下所示:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Chain,prototype.setNextSuccessor 指定在链中的下一个节点</span></span><br><span class="line"><span class="comment">// Chain,prototype.passRequest      传递请求给某个节点</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Chain</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">successor</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Chain</span>,prototype.<span class="property">setNextSuccessor</span> = <span class="keyword">function</span>(<span class="params">sucessor</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">successor</span> = successor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Chain</span>,prototype.<span class="property">passRequest</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret === <span class="string">&#x27;nextSuccessor&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">successor</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">successor</span>.<span class="property">passRequest</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">successor</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在把3个订单函数分别包装成职责链的节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> <span class="title class_">Chain</span>(order500);</span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> <span class="title class_">Chain</span>(order200);</span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> <span class="title class_">Chain</span>(orderNormal);</span><br></pre></td></tr></table></figure><p>然后指定在职责链中的顺序：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainOrder500.<span class="title function_">setNextSuccessor</span>(chainOrder200);</span><br><span class="line">chainOrder200.<span class="title function_">setNextSuccessor</span>(chainOrderNormal);</span><br></pre></td></tr></table></figure><p>最后把请求传递给第一个节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">1</span>,<span class="literal">true</span>,<span class="number">500</span>);    <span class="comment">// 输出：500元定金预购，得到100优惠券</span></span><br><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">2</span>,<span class="literal">true</span>,<span class="number">500</span>);    <span class="comment">// 输出：200元定金预购，得到50优惠券</span></span><br><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">3</span>,<span class="literal">true</span>,<span class="number">500</span>);    <span class="comment">// 输出：普通购买，无优惠券</span></span><br><span class="line">chainOrder500.<span class="title function_">passRequest</span>(<span class="number">1</span>,<span class="literal">false</span>,<span class="number">0</span>);     <span class="comment">// 输出：手机库存不足</span></span><br></pre></td></tr></table></figure><p>通过改进，我们可以自由灵活地增加，移除和修改链中地节点顺序，假如某天网站运营人员又想出了支持300元定金购买，那我们就在该链中增加一个节点即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order300 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> chainOrder300 = <span class="keyword">new</span> <span class="title class_">Chain</span>(order300);</span><br><span class="line">chainOrder500.<span class="title function_">setNextSuccessor</span>(chainOrder300);</span><br><span class="line">chainOrder300.<span class="title function_">setNextSuccessor</span>(chainOrder200);</span><br></pre></td></tr></table></figure><h3 id="五、异步的职责链"><a href="#五、异步的职责链" class="headerlink" title="五、异步的职责链"></a>五、异步的职责链</h3><p>在上一节的职责链模式中，我们让每个节点函数同步返回一个特定的值”nextsuccessor”，来表示是否把请求传递给下一个节点。而在现实开发中，我们经常会遇到一些异步的问题，比如我们要在节点两数中发起一个ajax异步请求，异步请求返回的结果才能决定是否继续在职贵链中passReques。</p><p>这时候让节点函数同步返回mnextsuccessr 经没有意义了，所以要给chain类再增加一个原型方法Chain.prototype.next，表示手动传递请求给职责链中的下一个节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Chain</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">next</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">successor</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">successor</span>.<span class="property">passRequest</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">successor</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>来看一个异步职责链的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="title class_">Chain</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;nextSuccessor&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="title class_">Chain</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        self.<span class="title function_">next</span>();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="keyword">new</span> <span class="title class_">Chain</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn1.<span class="title function_">setNextSuccessor</span>(fn2).<span class="title function_">setNextSuccessor</span>(fn3);</span><br><span class="line">fn1.<span class="title function_">passRequest</span>();</span><br></pre></td></tr></table></figure><p>现在得到了一个特殊的链条，请求在链中的节点里传递，但节点有权限决定什么时候把请求交给下一个节点。可以想象，异步的职责链加上命令模式（把ajax请求封装成命令对象），我们可以很方便地创建一个异步ajax队列库。</p><h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>职责链模式可以很好的帮助我们管理代码，降低发起请求的对象和处理请求的对象之间的耦合性。职责链中的节点数量和顺序是可以自由变化的，我们可以在运行时决定链中包含哪些节点。</p><p>无论是作用域链、原型链、还是DOM节点中的事件冒泡，我们都能从中找到职责链模式的影子。职责链模式还可以和组合对象模式结合在一起，用来连接部件和父部件，或者提高组合对象的效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;职责链的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;
&lt;p&gt;职责链模式的名字非常形象，一系列可能会处理请求的对象被连接成一条链，请求在这些对象之间传递，直到遇</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/22/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/22/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-22T07:51:47.000Z</published>
    <updated>2024-09-22T07:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>享元（flyweight）模式是一种用于性能优化的模式，”fly”在这里是苍蝇的意思，意为蝇最级。享元模式的核心是运用共享技术来有效支持大量细粒度对象。</p><p>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览器特别是移动端的浏览器分配的内存并不算多，如何节省内存就成了一件非常有意义的事情。</p><h3 id="一、初识享元模式"><a href="#一、初识享元模式" class="headerlink" title="一、初识享元模式"></a>一、初识享元模式</h3><p>假设有个内衣工厂，目前的产品有50种男式内衣和50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。正常情况下需要50个男模特和50个女模特，然后让他们每人分别穿上一件内衣来拍照。不使用享元模式的情况下，在程序里也许会这样写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Model</span> = <span class="keyword">function</span>(<span class="params"> sex, underwear</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">underwear</span> = underwear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Model</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">takePhoto</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sex=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sex</span> + <span class="string">&#x27;underwear=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">underwear</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> maleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + i);</span><br><span class="line">    maleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++)&#123;</span><br><span class="line">    <span class="keyword">var</span> maleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;female&#x27;</span>, <span class="string">&#x27;underwear&#x27;</span> + i);</span><br><span class="line">    maleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要得到一张照片，每次都需要传入sex和underwear参数，如上所述，现在一共有50种男内衣和50种女内衣，所以一共会产生100个对象。如果将来生产了10000种内衣，那这个程序可能会因为存在如此多的对象已经提前崩溃。</p><p>下面我们来考虑以下如何优化这个场景。虽然有100种内衣，但很明显并不需要50个男模特和50个女模特。其实男模特和女模特各自有一个就足够了，他们分别穿上不同的内衣来拍照。</p><p>先把underwear参数从构造函数中移除，构造函数只接收sex参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Model</span> = <span class="keyword">function</span>(<span class="params"> sex </span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Model</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">takePhoto</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sex=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">sex</span> + <span class="string">&#x27;underwear=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">underwear</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分别创建一个男模特对象和一个女模特对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">    femaleModel = <span class="keyword">new</span> <span class="title class_">Model</span>(<span class="string">&#x27;female&#x27;</span>);</span><br></pre></td></tr></table></figure><p>给男模特依次穿上所有的男装，并进行拍照：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++)&#123;</span><br><span class="line">    maleModel.<span class="property">underwear</span> = <span class="string">&#x27;underwear&#x27;</span> + i;</span><br><span class="line">    maleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给女模特依次穿上所有的女装，并进行拍照：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">50</span>; j++)&#123;</span><br><span class="line">    femaleModel.<span class="property">underwear</span> = <span class="string">&#x27;underwear&#x27;</span> + i;</span><br><span class="line">    femaleModel.<span class="title function_">takePhoto</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到改进之后的代码，只需要两个对象便完成了同样的功能。</p><h3 id="二、内部状态与外部状态"><a href="#二、内部状态与外部状态" class="headerlink" title="二、内部状态与外部状态"></a>二、内部状态与外部状态</h3><p>上面那个例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态下面提供了一些指引：</p><ul><li>内部状态存储于对象内部。</li><li>内部状态可以被一些对象共享。</li><li>内部状态独立于具体的场景，通常不会改变。</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li></ul><p>这样一来，我们便可以把所有内部状态相同的对象都指引为同一个共享的对象。而外部状态可以从对象身上剥离出来，并存储在外部。</p><p>剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为了一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。</p><p>在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。通常来讲，内部状态有多少种组合，系统便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要2个对象。</p><p>使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，模特的性别就可以作为内部状态储存在共享对象内部。而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。</p><h3 id="三、享元模式的通用结构"><a href="#三、享元模式的通用结构" class="headerlink" title="三、享元模式的通用结构"></a>三、享元模式的通用结构</h3><p>示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。</p><ul><li>我们通过构造函数显式new出了男女两个model对象，在其他系统中，也许并不是一开始就需要所有的共享对象。</li><li>给model对象手动设置了underwear外部状态，在更复杂的系统中，这不是一个最好的方式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。</li></ul><p>通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。</p><h3 id="四、享元模式的适用性"><a href="#四、享元模式的适用性" class="headerlink" title="四、享元模式的适用性"></a>四、享元模式的适用性</h3><p>享元模式是一种很好的性能优化方案，带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。</p><ul><li><p>一个程序中使用了大量的相似对象。</p></li><li><p>由于使用了大量对象，造成很大的内存开销。</p></li><li><p>对象的大多数状态都可以变为外部状态。</p></li><li><p>剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。</p></li></ul><h3 id="五、再谈内部状态和外部状态"><a href="#五、再谈内部状态和外部状态" class="headerlink" title="五、再谈内部状态和外部状态"></a>五、再谈内部状态和外部状态</h3><p>如果顺利的话，通过前面的例子已经了解到内部状态和外部状态的概念以及享元模式的工作原理。我们知道，实现享元模式的关键是把内部状态和外部状态分离出来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。现在考虑两种极端情况，即对象没有外部状态和没有内部状态的时候。</p><ol><li><h4 id="没有内部状态的享元"><a href="#没有内部状态的享元" class="headerlink" title="没有内部状态的享元"></a>没有内部状态的享元</h4><p>很多网盘都提供了极速上传（控件）与普通上传（Flash）两种模式，如果极速上传不好使（可能是没有安装控件或者控件损坏），用户还可以随时切换到普通上传模式，所以这里确实是需要同时存在两个不同的upload共享对象。</p><p>但不是每个网站都必须做得如此复杂，很多小一些的网站就只支持单一的上传方式。假设我们是这个网站的开发者，不需要考虑极速上传和普通上传之间的切换，这意味着在之前的代码中作为内部状态的uploadType属性是可以删掉的。</p><p>在继续使用享元模式的前提下，构造函数Upload就变成了无参数形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Upload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>其他属性如fileName、fileSize、dom依然可以作为外部状态保存在共享对象外部。在uploadType作为内部状态的时候，它可能为控件，也可能为Flash，所以当时最多可以组合出两个共享对象。而现在已经没有了内部状态，这意味着只需要唯一的一个共享对象。现在改写创建享元对象的工厂：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">UploadFactory</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> uploadObj;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">create</span>:: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(uploadObj)&#123;</span><br><span class="line">                <span class="keyword">return</span> uploadObj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> uploadObj = <span class="keyword">new</span> <span class="title class_">Upload</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>管理器部分的代码不需要改动，还是复杂剥离和组装外部状态。可以看到，当对象没有内部状态的时候，生产共享对象的工厂实际上变成了一个单例工厂。虽然这时候的共享对象没有内部状态的区分，但还是有剥离外部状态的过程，依然倾向于称之为享元模式。</p></li><li><h4 id="没有外部状态的享元"><a href="#没有外部状态的享元" class="headerlink" title="没有外部状态的享元"></a>没有外部状态的享元</h4><p>网上许多资料中，经常把Java或者C#的字符串看成享元，这种说法是否正确呢？我们看看下面这段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>).intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>).intern();</span><br><span class="line">        System.out.println(a1 == a2);               <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段Java代码里，分别new了两个字符串对象a1和a2。intern是一种对象池技术，<code>new String(&quot;a&quot;).intern()</code>的含义如下。</p><ul><li>如果值为a的字符串对象已经存在于对象池中，则返回这个对象的引用。</li><li>反之，将字符串a的对象添加进对象池，并返回这个对象的引用。</li></ul><p>所以a1 &#x3D;&#x3D; a2的结果是true。但这并不是使用了享元模式的结果，享元模式的关键是区别内部状态和外部状态。享元模式的过程是剥离外部状态，并把外部状态保存在其他地方，在合适的时刻再把外部状态组装进共享对象。这里并没有剥离外部状态的过程，a1和a2指向的完全就是同一个对象，所以如果没有外部状态的分离，即使这里使用了共享技术，但并不是一个纯粹的享元模式。</p></li></ol><h3 id="六、对象池"><a href="#六、对象池" class="headerlink" title="六、对象池"></a>六、对象池</h3><p>在前面已经提到了Java中String的对象池，下面来学习这种共享技术。对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取。如果对象池里没有空闲对象，则创建一个新的对象，当获取出的对象完成它的职责之后，再进入池子等待被下次获取。</p><p>对象池的原理很好理解，比如我们组人手一本《JavaScript》，从节约的角度来讲，这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书还回图书馆。如果同时有三个人要看这本书，现在图书馆里只有两本，那我们再马上去书店买一本放入图书馆。</p><p>对象池技术的应用非常广泛，HTTP连接池和数据库连接池都是其代表应用。在Web前端开发中，对象池使用最多的场景大概就是跟DOM有关的操作。很多空间和时间都消耗在了DOM节点上，如何避免频繁地创建和删除DOM节点就成了一个有意义的话题。</p><ol><li><h4 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h4><p>假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫他toolTip。</p><p>在搜索我家附近地图的时候，页面出现了2个小气泡。当我再搜索附近拉面馆时，页面中出现了6个小气泡。按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。这样在第二次的搜索结束页面里，我们只需要再创建4个小气泡而不是6个。</p><p>先定义一个获取小气泡节点的工厂，作为对象池的数组成为私有属性被包含在工厂闭包里，这个工厂有两个暴露对外的方法，create表示获取一个div节点，recover表示回收一个div节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toolTipFactory = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTipPool = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">create</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(toolTipPool.<span class="property">length</span> === <span class="number">0</span>)&#123;                 <span class="comment">// 如果对象池为空</span></span><br><span class="line">                <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);  <span class="comment">// 创建一个dom</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">                <span class="keyword">return</span> div;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                        <span class="comment">// 如果对象池里不为空</span></span><br><span class="line">                <span class="keyword">return</span> too;<span class="title class_">TipPool</span>.<span class="title function_">shift</span>();               <span class="comment">// 则从对象池中取出一个dom</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">recover</span>: <span class="keyword">function</span>(<span class="params">tooltipDom</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> toolTipPool.<span class="title function_">push</span>(tooltipDom);          <span class="comment">// 对象池回收dom</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在把时钟拨回进行第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, str; str = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>][i++];)&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTip = toolTipFactory.<span class="title function_">create</span>();</span><br><span class="line">    toolTip.<span class="property">innerHTML</span> = str;</span><br><span class="line">    ary.<span class="title function_">push</span>(toolTip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果愿意稍稍测试一下，可以看到页面中出现了innerHTML分别为A和B的两个div节点。</p><p>接下来假设地图需要重新开始绘制，在此之前要把这两个节点回收进对象池：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, toolTip; toolTip = ary[i++];)&#123;</span><br><span class="line">    toolTipFactory.<span class="title function_">recover</span>(toolTip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再创建6个小气泡：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, str; str = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>][i++];)&#123;</span><br><span class="line">    <span class="keyword">var</span> toolTip = toolTipFactory.<span class="title function_">create</span>();</span><br><span class="line">    toolTip.<span class="property">innerHTML</span> = str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再测试一番，页面中出现了内容分别为A、B、C、D、E、F的6个节点，上一次创建好的节点被共享给了下一次操作。对象池跟享元模式的思想有点近似，虽然innerHTML的值A、B、C、D等也可以看成节点的外部状态，但再这里我们并没有主动分离内部状态和外部状态的过程 。</p></li><li><h4 id="通用对象池实现"><a href="#通用对象池实现" class="headerlink" title="通用对象池实现"></a>通用对象池实现</h4><p>还可以在对象池工厂里，把创建对象的具体过程封装起来，实现一个通用的对象池：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectPoolFactory = <span class="keyword">function</span>(<span class="params">createObjFn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> objectPool = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">create</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = objectPool.<span class="property">length</span> === <span class="number">0</span> ?</span><br><span class="line">                createObjFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) : objectPool.<span class="title function_">shift</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">recover</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">            objectPool.<span class="title function_">push</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在利用objectPoolFactory来创建一个装载一些iframe的对象池：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeFactory = <span class="title function_">objectPoolFactory</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line">    </span><br><span class="line">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        iframe.<span class="property">onload</span> = <span class="literal">null</span>;             <span class="comment">// 防止iframe重复加载的bug</span></span><br><span class="line">        iframeFactory.<span class="title function_">recover</span>(iframe);    <span class="comment">// iframe加载完成之后回收节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iframe1 = iframeFactory.<span class="title function_">create</span>();</span><br><span class="line">iframe1.<span class="property">src</span> = <span class="string">&#x27;http://baidu.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iframe2 = iframeFactory.<span class="title function_">create</span>();</span><br><span class="line">iframe2.<span class="property">src</span> = <span class="string">&#x27;http://QQ.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe3 = iframeFactory.<span class="title function_">create</span>();;</span><br><span class="line">    iframe3.<span class="property">src</span> = <span class="string">&#x27;http://163.com&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>对象池是另外一种性能优化方案，它跟享元模式有一些相似之处，但没有分离内部状态和外部状态这个过程。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;享元（flyweight）模式是一种用于性能优化的模式，”fly”在这里是苍蝇的意思，意为蝇最级。享元模式的核心是运用共享技术来有效支持大量细粒度对象。&lt;/p&gt;
&lt;p&gt;如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。在JavaScript中，浏览</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/17/%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/17/%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-17T09:22:47.000Z</published>
    <updated>2024-09-17T09:37:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript开发中用到集成的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。</p><p>基于继承的设计模式——模块方法模式</p><h3 id="一、模块方法模式的定义和组成"><a href="#一、模块方法模式的定义和组成" class="headerlink" title="一、模块方法模式的定义和组成"></a>一、模块方法模式的定义和组成</h3><p>模块方法模式是一种只需使用继承就可以实现的非常简单的模式。</p><p>模块方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><p>假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为了解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。</p><h3 id="二、第一个例子——Coffee-or-Tea"><a href="#二、第一个例子——Coffee-or-Tea" class="headerlink" title="二、第一个例子——Coffee or Tea"></a>二、第一个例子——Coffee or Tea</h3><ol><li><h4 id="先泡一杯咖啡"><a href="#先泡一杯咖啡" class="headerlink" title="先泡一杯咖啡"></a>先泡一杯咖啡</h4><p>首先，我们先泡一杯咖啡，如果没有什么太个性化的需求，泡咖啡的步骤通常如下：</p><ol><li>把水煮沸</li><li>用沸水冲泡咖啡</li><li>把咖啡倒进杯子</li><li>加糖和牛奶</li></ol><p>通过下面这段代码，我们可以得到一杯香浓的咖啡</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Coffee</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brewCoffeeGriends</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addSugarAndMilk</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brewCoffeeGriends</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addSugarAndMilk</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="泡一壶茶"><a href="#泡一壶茶" class="headerlink" title="泡一壶茶"></a>泡一壶茶</h4><p>接下来，开始准备我们的茶，泡茶的步骤跟泡咖啡的步骤相差并不大：</p><ol><li>把水煮沸</li><li>用沸水侵泡茶叶</li><li>把茶水倒进杯子</li><li>加柠檬</li></ol><p>同样用一段代码来实现泡茶的步骤：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Tea</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">steepTeaBag</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用水侵泡茶叶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把茶水倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addLemon</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">steepTeaBag</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addLemon</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">tea.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="分离出共同点"><a href="#分离出共同点" class="headerlink" title="分离出共同点"></a>分离出共同点</h4><p>现在泡好了一杯咖啡和一壶茶，经过思考和比较，我们发现咖啡和茶的冲泡过程是大同小异的。</p><table><thead><tr><th align="center">泡咖啡</th><th align="center">泡茶</th></tr></thead><tbody><tr><td align="center">把水煮沸</td><td align="center">把水煮沸</td></tr><tr><td align="center">用沸水冲泡咖啡</td><td align="center">用沸水侵泡茶叶</td></tr><tr><td align="center">把咖啡倒进杯子</td><td align="center">把茶水倒进杯子</td></tr><tr><td align="center">加糖和牛奶</td><td align="center">加柠檬</td></tr></tbody></table><p>我们找到泡咖啡和泡茶主要有以下不同点：</p><ul><li>原料不同。一个是咖啡，一个是茶，但我们可以把它们都抽象成”饮料”。</li><li>泡的方式不同。咖啡是冲泡，而茶叶是侵泡，我们可以把它们都抽象为”泡”。</li><li>加入的调料不同。一个是糖和牛奶，一个是柠檬，但我们可以把它们都抽象为”调料”。</li></ul><p>经过抽象之后，不管是泡咖啡还是泡茶，我们都能整理为以下四步：</p><ol><li>把水煮沸</li><li>用沸水冲泡饮料</li><li>把饮料倒进杯子</li><li>加调料</li></ol><p>所以不管是冲泡还是侵泡，我们都能给它一个新的方法名称，比如说<code>brew()</code>。同理，不管是加糖和牛奶，还是柠檬，我们都可以称之为<code>addCondiments()</code>。</p><p>让我们忘记最开始创建的Coffee类和Tea类。现在可以创建一个抽象父类来表示泡一杯饮料的整个过程。不论是Coffee，还是Tea，都被我们用Beverage来表示，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Beverage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;        <span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;        <span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;    <span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="创建Coffee子类和Tea子类"><a href="#创建Coffee子类和Tea子类" class="headerlink" title="创建Coffee子类和Tea子类"></a>创建Coffee子类和Tea子类</h4><p>现在创建一个Beverage类的对象对我们来说没有意义，因为世界上能喝的东西没有一种真正叫”饮料”的，饮料在这里还只是一个抽象的存在。接下来我们要创建咖啡类和茶类，并让它们继承饮料类：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Coffee</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Beverage</span>();</span><br></pre></td></tr></table></figure><p>接下来要重写抽象父类中的一些方法，只有”把水煮沸”这个行为可以直接使用父类Beverage中的boilWater方法，其他方法都需要在Coffee子类中重写，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Coffee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>至此我们的Coffee类已经完成了，当调用coffee对象的init方法时，由于coffee对象和Coffee构造器的原型prototype上都没有对应的init方法，所以该请求会顺着原型链，被委托给Coffee的”父类”Beverage原型上的init方法。</p><p>而Beverage.prototype.init方法中已经规定好了泡饮料的顺序，所以我们能成为地泡出一杯咖啡，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Baverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来照葫芦画瓢，来创建我们的Tea类：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Tea</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Beverage</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水侵泡茶叶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把茶叶倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Tea</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">tea.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>本章一直讨论的是模板方法模式，那么在上面的例子中，到底谁才是所谓的模板方法呢？</p><p><strong>Beverage.prototype.init</strong></p><p>Beverage.prototype.init被称为模板方法的原因是，该方法中封装了子类的算法框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在Beverage.prototype.init方法中，算法内的每一步骤都清楚地展示在我们眼前。</p></li></ol><h3 id="三、抽象类"><a href="#三、抽象类" class="headerlink" title="三、抽象类"></a>三、抽象类</h3><p>首先要说明的是，模板方法模式是一种严重依赖抽象类地设计模式。JavaScript在语言层面并没有提供对抽象类的支持，我们也是很难模拟抽象类的实现。</p><ol><li><h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><p>在Java中，类分为两种，一种为具体类，另一种为抽象类。具体类可以被实例化，抽象类不能被实例化，要了解抽象类不能被实例化的原因，我们可以思考”饮料”这个抽象类。</p><p>想象这样一个场景：我们口渴了，去便利店想买一瓶饮料，我们不能直接跟店员说：”来一瓶饮料。”如果我们这样说了，那么店员接下来肯定会问：”要什么饮料？”饮料只是一个抽象名词，只有当我们真正明确了的饮料类型之后，才能得到一杯咖啡、茶、或者可乐。</p><p>由于抽象类不能被实例化，如果有人编写一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。</p><p>抽象类和接口一样可以用于向上转型，在静态类型语言中，编译器对类型的检查总是一个绕不过的话题与困扰。虽然类型检查可以提高程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们的Java程序尽量遵守依赖倒置原则。</p><p>除了用于向上转型，抽象类也可以表示一种锲约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删掉了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的，比如在模板方法模式中，Beverage类的init方法里规定了冲泡一杯饮料的顺序如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">boilWater</span>();      <span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">brew</span>();           <span class="comment">// 用水泡原料</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();      <span class="comment">// 把原料倒进杯子</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();  <span class="comment">// 添加调料</span></span><br></pre></td></tr></table></figure><p>如果在Coffee子类中没有实现对应的brew方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类应该拥有这些方法，并提供正确的实现。</p></li><li><h4 id="抽象方法和具体方法"><a href="#抽象方法和具体方法" class="headerlink" title="抽象方法和具体方法"></a>抽象方法和具体方法</h4><p>抽象方法声明在抽象类中，抽象方法并没有具体的实现过程，是一些”哑”方法。比如Beverage类中的brew方法、pourInCup方法和addCondiments方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。</p><p>除了抽象方法外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫作具体方法。当代码需要改变时，我们只需要改动抽象类里的具体方法就可以了。比如饮料中的boilWater方法，假设冲泡所有的饮料之前，都要先把水煮沸，那我们自然可以把boilWater方法放进抽象类Beverage中。</p></li><li><h4 id="用Java实现Coffee-or-Tea例子"><a href="#用Java实现Coffee-or-Tea例子" class="headerlink" title="用Java实现Coffee or Tea例子"></a>用Java实现Coffee or Tea例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;              <span class="comment">// 饮料抽象类</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;                        <span class="comment">// 模板方法</span></span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span>&#123;                         <span class="comment">// 具体方法boilWater</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;                     <span class="comment">// 抽象方法brew</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;     <span class="comment">// 抽象方法addCondiments</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span>;                <span class="comment">// 抽象方法pourCup</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;        <span class="comment">// Coffee类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;                             <span class="comment">// 子类中重写brew方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;                        <span class="comment">// 子类中重写pourInCup方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addVondiments</span><span class="params">()</span> &#123;                    <span class="comment">// 子类中重写addVondiments方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;                             <span class="comment">// 子类中重写brew方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;用沸水冲泡茶叶&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;                        <span class="comment">// 子类中重写pourInCup方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addVondiments</span><span class="params">()</span> &#123;                    <span class="comment">// 子类中重写addVondiments方法</span></span><br><span class="line">        System.out.println(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">(Beverage heverage)</span>&#123;</span><br><span class="line">        heverage.init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();       <span class="comment">// 创建coffee对象</span></span><br><span class="line">        prepareRecipe(coffee);                <span class="comment">// 开始泡咖啡</span></span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        <span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line">        <span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line">        <span class="comment">// 加糖和牛奶</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">tea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tea</span>();             <span class="comment">// 创建tea对象</span></span><br><span class="line">        prepareRecipe(tea);                   <span class="comment">// 开始泡茶</span></span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        <span class="comment">// 用沸水冲泡茶叶</span></span><br><span class="line">        <span class="comment">// 把茶倒进杯子</span></span><br><span class="line">        <span class="comment">// 加柠檬</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="JavaScript没有抽象类的缺点和解决方案"><a href="#JavaScript没有抽象类的缺点和解决方案" class="headerlink" title="JavaScript没有抽象类的缺点和解决方案"></a>JavaScript没有抽象类的缺点和解决方案</h4><p>JavaScript并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于JavaScript是一门”类型模糊”的语言，所以隐藏对象的类型在JavaScript中并不重要。</p><p>另一方面，当我们在JavaScript中使用原型继承来模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的”抽象方法”。</p><p>我们知道，Beverage.prototype.init方法作为模板方法，已经规定了子类的算法框架，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Baverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们的Coffee类或者Tea类忘记实现这4个方法中的一个呢？拿brew方法举例，如果我们忘记编写Coffee.prototype.brew方法，那么当请求coffee对象的brew时，请求会顺着原型链找到Beverage”父类”对应的Beverage.prototype.brew方法，而Beverage.prototype.brew方法到目前为止是一个空方法，这显然是不能符合我们需要的。</p><p>在Java中编译器会保证子类会重写父类中的抽象方法，但在JavaScript中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。</p><p>下面提供两种变通的解决方案。</p><ul><li><p>第1种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。</p></li><li><p>第2种方案是让Bever.prototype.brew等方法直接抛出一个异常，如果因为粗心忘记编写Coffee.prototype.brew方法，那么至少我们会在程序运行时得到一个错误：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写brew方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写pourInCup方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写addCondiments方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>第2种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后。</p><p>我们一共有3次机会得到这个错误信息，第1次是在编写代码的时候，通过编译器的检查来得到错误信息；第2次是在创建对象的时候用鸭子类型来进行”接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。</p></li></ol><h3 id="四、模板方法模式的使用场景"><a href="#四、模板方法模式的使用场景" class="headerlink" title="四、模板方法模式的使用场景"></a>四、模板方法模式的使用场景</h3><p>从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了框架的骨架，程序员继承框架的结构之后，负责往里面填空，比如Java程序员大多数使用过HttpServlet技术来开发项目。</p><p>一个基于HttpServlet的程序包含7个生命周期，这7个生命周期分别对应一个do方法。</p><p><code>doGet()</code></p><p><code>doHead()</code></p><p><code>doPost()</code></p><p><code>doPut()</code></p><p><code>doDelete()</code></p><p><code>doOption()</code></p><p><code>doTrace()</code></p><p>HttpServlet类还提供了一个service方法，它就是这里的模板方法，service规定了这些do方法的执行顺序，而这些do方法的具体实现则需要HttpServlet的子类来提供。</p><p>在Web开发中也能找到很多模板方法模式的适用场景，比如我们在构建一系列的UI组件，这些组件的构建过程一般如下所示：</p><ol><li>初始化一个div容器</li><li>通过ajax请求拉取相应的数据</li><li>把数据渲染到div容器里面，完成组件的构造</li><li>通知用户组件渲染完毕</li></ol><p>任何组件都遵循上面的4步，其中第1步和第4步是相同的，第2步不同的地方只是请求ajax的远程地址，第3步不同的地方是渲染数据的方式。</p><p>于是我们可以把这4个步骤都抽象到父类的模板方法里面，父类中还可以顺便提供第1步和第4步的具体实现。当子类继承这个父类之后，会重写模板方法里面的第2步和第3步。</p><h3 id="五、钩子方法"><a href="#五、钩子方法" class="headerlink" title="五、钩子方法"></a>五、钩子方法</h3><p>通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于大多数子类的，但如果有一些特别”个性”的子类呢？比如我们在饮料类Beverage中封装了饮料的冲泡顺序：</p><ol><li>把水煮沸‘</li><li>用沸水冲泡饮料</li><li>把饮料倒进杯子</li><li>加调料</li></ol><p>这4个冲泡饮料的步骤适用于咖啡和茶，在饮料店里，根据这4个步骤制作出来的咖啡和茶，一直顺利地提供给绝大部分客人享用。但有一些客人喝咖啡是不加调料（糖和牛奶）的。既然Beverage作为父类，已经规定好了冲泡饮料的4个步骤，那么有什么办法可以让子类不受这个约束呢？</p><p><strong>钩子方法（hook）</strong>可以用来解决这个问题，放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要”挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。</p><p>在这个例子里，我们把挂钩的名字定为customerWantsCondiments，接下来将挂钩放入Beverage类，看看如何得到一杯不需要糖和牛奶的咖啡：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Beverage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">boilWater</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写brew方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写pourInCup方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须重写addCondiments方法&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customerWantsCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    retuen <span class="literal">true</span>;                             <span class="comment">// 默认需要调料</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Beverage</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">boilWater</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">brew</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">customerWantsCondiments</span>())&#123;      <span class="comment">// 如果挂钩返回true，则需要调料</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">CoffeeWithHook</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Beverage</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">brew</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pourInCup</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CoffeeWithHook</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">customerWantsCondiments</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;请问需要调料吗？&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffeeWithHook = <span class="keyword">new</span> <span class="title class_">CoffeeWithHook</span>();</span><br><span class="line">coffeeWithHook.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><h3 id="六、好莱坞原则"><a href="#六、好莱坞原则" class="headerlink" title="六、好莱坞原则"></a>六、好莱坞原则</h3><p>学习完模板方法模式之后，引人一个新的设计原则——著名的”好莱坞原则”。<br>好莱坞无疑是演员的天堂，但好菜坞也有很多找不到工作的新人演员，许多新人演员在好菜坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：”不要来找我，我会给你打电话”</p><p>在设计中，这样的规则就称为好莱坞原则。在这一原则的指导下，我们允许底层组件将自己挂钩到高层组件中，而高层组件会决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是“别调用我们，我们会调用你”</p><p>模板方法模式是好莱坞原则的个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。</p><p>除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布一订阅模式和回调函数。</p><ul><li><p>发布-订阅模式</p><p>在发布一订阅模式中，发布者会把消息推送给订阅者，这取代了原先不断去fetch消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过5秒钟就问司机“是否到达目的地”之外，还可以在车上美美地睡上一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好菜坞原则中提到的“别调用我们，我们会调用你”</p></li><li><p>回调函数</p><p>在ajax异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传人发起ajax异步请求的两数。当数据返回之后，这个回调两数才被执行，这也是好菜坞原则的一种体现。把需要执行的操作封装在回调两数里，然后把主动权交给另外一个函数。至于回调函数什么时候被执行，则是另外一个函数控制的。</p></li></ul><h3 id="七、真的需要”继承”吗"><a href="#七、真的需要”继承”吗" class="headerlink" title="七、真的需要”继承”吗"></a>七、真的需要”继承”吗</h3><p>模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好菜坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。</p><p>通过模板方法模式，编写了一个Cofee orTea的例子。模板方法模式是为数不多的基于继承的设计模式，但JaasScrit语 实际上没有提供真正的类式继承，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但学习到的模板方法模式并不十分正宗。而且在JavaScripti这般灵活的语言中，实现这样一个例子，是否真的需要继承这种重武器呢?</p><p>在好莱坞原则的指导之下，下面这段代码可以达到和继承一样的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Beverage</span> = <span class="keyword">function</span>(<span class="params"> param </span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> boilwater = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把水煮沸&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> brew = param.<span class="property">brew</span> || <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须传brew方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pourInCup = param.<span class="property">pouTInCup</span> || <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须传递 pourInCup方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addCondiments = param.<span class="property">addcondiments</span> || <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必频传递addCondiments方法&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> F- <span class="keyword">function</span>(<span class="params"></span>)];</span><br><span class="line"></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">boilwater</span>();</span><br><span class="line"><span class="title function_">brew</span>();</span><br><span class="line"><span class="title function_">pourInCup</span>();</span><br><span class="line"><span class="title function_">addCondiments</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">return</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Coffee</span>-<span class="title class_">Beverage</span>(&#123;</span><br><span class="line">    <span class="attr">brew</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水冲泡咖啡&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pourInCup</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把咖啡倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">addcondiments</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Tea</span> = <span class="title class_">Beverage</span>(&#123;</span><br><span class="line">    <span class="attr">brew</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用沸水侵泡茶叶&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">pourInCup</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;把茶倒进杯子&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">addCondiments</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加柠檬&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">coffee.<span class="title function_">init</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">tea.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>在这段代码中，我们把brew、pourInCup、addCondiments这些方法依次传人Beverage函数，Beverage函数被调用之后返回构造器F。F类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架。</p><h3 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h3><p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也是符合开放—封闭原则的。</p><p>但在JavaScript中，我们很多时候都不需要依样画瓢地去实现一个模版方法模式，高阶函数是更好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在JavaScript开发中用到集成的场景其实并不是很多，很多时候我们都喜欢用mix-in的方式给对象扩展属性。但这不代表继承在JavaScript里没有用武之地，虽然没有真正的类和继承机制，但我们可以通过原型prototype来变相地实现继承。&lt;/p&gt;
&lt;p&gt;基于继承的设</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/13/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/13/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-12T16:06:47.000Z</published>
    <updated>2024-09-12T16:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的”孙对象”构成的。</p><h3 id="一、回顾宏命令"><a href="#一、回顾宏命令" class="headerlink" title="一、回顾宏命令"></a>一、回顾宏命令</h3><p>宏命令对象包含了一组具体的子命令对象，不管是宏命令对象，还是子命令对象，都有一个execute方法负责执行命令。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录QQ&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MacroCommand</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">commandsList</span>: [],</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">command</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">commandsList</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,command; command = <span class="variable language_">this</span>.<span class="property">commandsList</span>[i++];)&#123;</span><br><span class="line">                command.<span class="title function_">execute</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> marcoCommand = <span class="title class_">MarcoCommand</span>();</span><br><span class="line"></span><br><span class="line">marcoCommand.<span class="title function_">add</span>(closeDoorCommand);</span><br><span class="line">marcoCommand.<span class="title function_">add</span>(openPcCommand);</span><br><span class="line">marcoCommand.<span class="title function_">add</span>(openQQCommand);</span><br><span class="line"></span><br><span class="line">marcoCommand.<span class="title function_">execute</span>();</span><br></pre></td></tr></table></figure><p>通过这段代码，我们发现，宏命令中包含了一组子命令，它们组成了一个树形结构，这里是一颗结构非常简单的树：</p><p><img src="/../image/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20240912193252727.png" alt="image-20240912193252727"></p><p>其中，marcoCommand被称为组合对象，closeDoorCommand、openPcCommand、openQQCommand都是叶对象。在marcoCommand的execute方法里，并不执行真正的操作，而是遍历它所包含的叶对象，把真正的execute请求委托给这些叶对象。</p><p>marcoCommand表现得像一个命令，但它实际上只是一组真正命令的”代理”。并非真正的代理，虽然结构上相似，但marcoCommand只负责传递请求给叶对象，它的目的不在于控制对叶对象的访问。</p><h3 id="二、组合模式的用途"><a href="#二、组合模式的用途" class="headerlink" title="二、组合模式的用途"></a>二、组合模式的用途</h3><p>组合模式将组合成树形结构，以表示”部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性，下面分别说明：</p><ul><li>表示树形结构。通过上面的例子，我们很容易找到组合模式的一个优点：提供了一种遍历树形结构的方案，通过调用组合对象方法的execute方法，程序会递归调用组合对象下面的叶对象的execute方法，所以我们的万能遥控器只需要一次操作，便能依次完成关门、打开电脑、登录QQ这几件事情。组合模式可以非常方便地描述对象部分-整体层次结构。</li><li>利用对象多态性统一对待组合对象和单个对象。利用对象的多态性表现，可以使客户端忽略组合对象和单个对象的不同。在组合模式中，客户将统一地使用组合结构中的所有对象，而不需要关心它究竟是组合对象还是单个对象。</li></ul><p>这在实际开发中会给客户带来相当大的便利性，当我们往万能遥控器里面添加一个命令的时候，并不关心这个命令是宏命令还是普通子命令&#x2F;这点对于我们不重要，我们只需要确定他是一个命令，并且这个命令拥有可执行的execute方法，那么这个命令就可以被添加进万能遥控器。</p><p>当宏命令和普通子命令接收到执行execute方法的请求时，宏命令和普通子命令都会做它们各自认为正确的事情。这些差异是隐藏在客户背后的，在客户看来，这种透明性可以让我们非常自由地扩展这个万能遥控器。</p><h3 id="三、请求在树中传递的过程"><a href="#三、请求在树中传递的过程" class="headerlink" title="三、请求在树中传递的过程"></a>三、请求在树中传递的过程</h3><p>在组合模式中，请求在树中传递地过程总是遵循一种逻辑。</p><p>以hml为例，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象（普通命令），叶对象自身会对请求作出相应的处理，如果当前处理请求的对象是组合对象（宏命令），组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。</p><p>总而言之，如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。叶对象下面不会再有其他子节点，一个叶对象就是树的这条枝叶的尽头，组合对象下面可能还会由子节点，如图：</p><p><img src="/../image/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20240912200206700.png" alt="image-20240912200206700"></p><p>请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。</p><p>在刚刚的例子中，由于宏命令和子命令组成的树太过简单，我们还不能清楚地看到组合模式带来的好处，如果只是简单地遍历一组子节点，迭代器便能解决所有的问题。接下来我们将创造一个更强大的宏命令，这个宏命令中又包含了另外一些宏命令和普通子命令，看起来是一棵相对较复杂的树。</p><h3 id="四、更强大的宏命令"><a href="#四、更强大的宏命令" class="headerlink" title="四、更强大的宏命令"></a>四、更强大的宏命令</h3><p>基本对象可以被组合成更复杂的组合对象，组合对象又可以被组合，这样不断递归下去，这棵树的结构可以支持任意多的复杂度。在树最终被构造完成之后，让整顿树最终运转起来的步骤非常简单，只需要调用最上层对象的execute方法。每当对最上层的对象进行一次请求时，实际上是在对整个树进行深度优先的搜索，而创建组合对象的程序员并不关心这些内在的细节，往这棵树里面添加一些新的节点对象时非常容易地事情。</p><h3 id="五、抽象类在组合模式中的作用"><a href="#五、抽象类在组合模式中的作用" class="headerlink" title="五、抽象类在组合模式中的作用"></a>五、抽象类在组合模式中的作用</h3><p>前面说到，组合模式最大的优点在于可以一致性地对待组合对象和基本对象，客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有execute方法，这个命令就可以被添加到树中。</p><p>这种透明性带来的便利，在静态类型语言中体现得尤为明显。比如在Java中，实现组合模式的关键是Composite类和Leaf类都必须继承自一个Compenent抽象类。这个Compenent抽象类既代表组合对象，又代表叶对象，它能够保证组合对象和叶对象拥有同样的名字的方法，从而可以对同一消息都做出反馈。组合对象和叶对象的具体类型被隐藏在Compenent抽象类身后。</p><p>针对Compenent抽象类来编写程序，客户操作的始终是Compenent对象，而不用去区分到底是组合对象还是叶对象。</p><p>然而在JavaScript这种动态类型语言中，对象的多态性是与生俱来的，也没有编译器去检查变量的类型，所以我们通常不会去模拟一个”怪异”的抽象类，JavaScript中实现组合模式的难点在于要保证组合对象和叶对象拥有同样的方法，这通常需要用鸭子类型的思想对它们进行接口检查。</p><p>在JavaScript中实现组合模式，看起来缺乏一些严谨，我们的代码算不上安全，但能更快速和自由地开发，这既是JavaScript地缺点，也是它的优点。</p><h3 id="六、透明性带来的安全问题"><a href="#六、透明性带来的安全问题" class="headerlink" title="六、透明性带来的安全问题"></a>六、透明性带来的安全问题</h3><p>组合模式的透明性使得发起请求的客户不用去顾忌树中组合对象和叶对象的区别，但它们在本质上有是区别的。</p><p>组合对象可以拥有子节点，叶对象下面就没有子节点，所以我们也许会发生一些误操作，比如试图往叶对象中添加子节点。解决方案通常是给叶对象也添加add方法，并且在调用这个方法时，抛出一个异常来及时提醒客户。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MacroCommand</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">commandsList</span>: [],</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">command</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">commandsList</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,command; command = <span class="variable language_">this</span>.<span class="property">commandsList</span>[i++];)&#123;</span><br><span class="line">                command.<span class="title function_">execute</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openTvCommand = &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打开电视&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;叶对象不能添加子节点&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> macroCommand = <span class="title class_">MacroCommand</span>();</span><br><span class="line"></span><br><span class="line">macroCommand.<span class="title function_">add</span>(openTvCommand);</span><br><span class="line">openTvCommand.<span class="title function_">add</span>(macroCommand);     <span class="comment">// Uncaught Error: 叶对象不能添加子节点</span></span><br></pre></td></tr></table></figure><h3 id="七、组合模式的例子-扫描文件夹"><a href="#七、组合模式的例子-扫描文件夹" class="headerlink" title="七、组合模式的例子-扫描文件夹"></a>七、组合模式的例子-扫描文件夹</h3><p>文件夹和文件之间的关系，非常适合用组合模式来描述。文件夹里面可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树，组合模式在文件夹的应用中有以下两层好处。</p><ul><li>例如，我在同事的移动硬盘里找到了一些电子书，想把它们复制到F盘中的学习资料文件夹，在复制这些电子书的时候，我并不需要考虑这批文件的类型，不管它们是单独的电子书还是被放到了文件夹中。组合模式让Ctrl+V、Ctrl+C成为了一个统一的操作。</li><li>当我用杀毒软件扫描该文件夹时，往往不会关心里面有多少文件和子文件夹，组合模式使得我们只需要操作最外层的文件夹进行扫描。</li></ul><p>现在首先分别定义好文件夹Folder和文件File这两个类。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************ Folder ************************/</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Folder</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">file</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span>.<span class="title function_">push</span>(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件夹：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, file, files = <span class="variable language_">this</span>.<span class="property">files</span>; file = files[i++];)&#123;</span><br><span class="line">        file.<span class="title function_">scan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ File ************************/</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">File</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;文件下面不能再添加文件&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来创建一些文件夹和文件对象，并且让它们组合成一棵树，这棵树就是我们F盘里面的现有文件目录结构：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;学习资料&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> folder1 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> folder2 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;jQuery&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;JavaScript设计模式与开发实践&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;精通jQuery&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file3 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;重构与模式&#x27;</span>)</span><br><span class="line"></span><br><span class="line">folder1.<span class="title function_">add</span>(file1);</span><br><span class="line">folder2.<span class="title function_">add</span>(file2);</span><br><span class="line"></span><br><span class="line">folder.<span class="title function_">add</span>(folder1);</span><br><span class="line">folder.<span class="title function_">add</span>(folder2);</span><br><span class="line">folder.<span class="title function_">add</span>(file3);</span><br></pre></td></tr></table></figure><p>现在的需求是把移动硬盘里的文件和文件价都复制到这棵树中，假设我们已经得到了这些文件对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> folder3 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;Nodejs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file4 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;深入浅出Node.js&#x27;</span>);</span><br><span class="line">folder3.<span class="title function_">add</span>(file4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> file5 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;JavaScript语言精髓与编程实践&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接下来就是把这些文件都添加到原有的树中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">folder.<span class="title function_">add</span>(folder3);</span><br><span class="line">folder.<span class="title function_">add</span>(file5);</span><br></pre></td></tr></table></figure><p>通过这个例子，我们再次看到客户是如何同等对待组合对象和叶对象。在添加一批文件的操作过程中，客户不用分辨它们到底是文件还是文件夹。新增加的文件和文件夹能够很容易地添加到原来的树结构中，和树里已有的对象一起工作。</p><p>我们改变了树的结构，增加了新的数据，却不用修改任何一句原有的代码，这是符合开放-封闭原则的。</p><p>运用了组合模式之后，扫描整个文件夹的操作也是轻而易举的，我们只需要操作树的最顶端对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">folder.<span class="title function_">scan</span>();</span><br></pre></td></tr></table></figure><h3 id="八、一些值得注意的地方"><a href="#八、一些值得注意的地方" class="headerlink" title="八、一些值得注意的地方"></a>八、一些值得注意的地方</h3><p>在使用组合模式的时候，还有以下几个值得我们注意的地方。</p><ol><li><h4 id="组合模式不是父子关系"><a href="#组合模式不是父子关系" class="headerlink" title="组合模式不是父子关系"></a>组合模式不是父子关系</h4><p>组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。</p><p>组合模式是一种HAS-A（聚合）的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。</p><p>为了方便描述，有时候把上下级对象称为父子节点，但大家都知道，它们并非真正意义上的父子关系。</p></li><li><h4 id="对叶对象操作的一致性"><a href="#对叶对象操作的一致性" class="headerlink" title="对叶对象操作的一致性"></a>对叶对象操作的一致性</h4><p>组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。</p><p>比如公司要给全体员工发放元旦的过节费1000块，这个场景可以运用组合模式，但如果公司给今天过生日的员工发送一封生日祝福的邮件，组合模式在这里就没有用武之地了，除非先把今天过生日的员工挑选出来。只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。</p></li><li><h4 id="双向映射关系"><a href="#双向映射关系" class="headerlink" title="双向映射关系"></a>双向映射关系</h4><p>发送过节费的通知步骤是从公司到各个部门，再到各个小组，最后到每个员工的邮箱里。这本身是一个组合模式的好例子，但要考虑的一种情况是，也许某些员工属于多个组织架构。比如某位架构师既隶属于开发组，又隶属于架构组，对象之间的关系并不是严格意义上的层次结构，在这种情况下，是不适合使用组合模式的，该架构师很可能会收到两份过节费。</p><p>这种复合情况下我们必须给父节点和子节点建立双向映射关系，一个简单的方法是给小组和员工对象都增加集合来保存对方的引用。但是这种相互间的引用相当复杂，而且对象之间产生了过多的耦合性，修改或者删除一个对象都变得困难，此时我们可以引入中介者模式来管理这些对象。</p></li><li><h4 id="用职责链模式提高组合模式性能"><a href="#用职责链模式提高组合模式性能" class="headerlink" title="用职责链模式提高组合模式性能"></a>用职责链模式提高组合模式性能</h4><p>在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。</p></li></ol><h3 id="九、引用父对象"><a href="#九、引用父对象" class="headerlink" title="九、引用父对象"></a>九、引用父对象</h3><p>在七节提到的例子中，组合对象保存了它下面的子节点的引用，这是组合模式的特点，此时树结构是从上至下的。但有时候我们需要在子节点上保持对父节点的引用，比如在组合模式中使用职责链时，有可能需要让请求从子节点往父节点上冒泡传递。还有当我们删除某个文件的时候，实际上是从这个文件所在的上层文件中删除文件的。</p><p>现在来改写扫描文件夹的代码，使得在扫描整个文件夹之前，我们可以先移除某一个具体的文件。</p><p>首先改写Folder类和File类，在这两个类的构造函数中，增加this.parent属性，并且在调用add方法的时候，正确设置文件或者文件夹的父节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Folder</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">null</span>;     <span class="comment">// 增加this.parent属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">file</span>)&#123;</span><br><span class="line">    file.<span class="property">parent</span> = <span class="variable language_">this</span>;     <span class="comment">// 设置父对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">files</span>.<span class="title function_">push</span>(file);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件夹：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,file, files = <span class="variable language_">this</span>.<span class="property">files</span>; file = files[i++];)&#123;</span><br><span class="line">        file.<span class="title function_">scan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来增加<code>Folder.prototype.remove</code>方法，表示移除该文件夹：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Folder</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">parent</span>)&#123;       <span class="comment">// 根节点或者树外的游离节点 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> files = <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">files</span>, l = files.<span class="property">length</span> - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="keyword">var</span> file = files[l];</span><br><span class="line">        <span class="keyword">if</span>(file === <span class="variable language_">this</span>)&#123;</span><br><span class="line">            files.<span class="title function_">splice</span>(l, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>File.prototype.remove</code>方法里，首先会判断<code>this.parent</code>，如果<code>this.parent</code>为null，那么这个文件夹要么是树的根节点，要么是还没有添加到树的游离节点，这时候没有节点需要从树中移除，我们暂且让remove方法直接return，表示不做任何操作。</p><p>如果this.parent不为null，则说明该文件夹有父节点存在，此时遍历父节点中保存的子节点列表，删除想要删除的子节点。</p><p>File类的实现基本一致：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">File</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能添加在文件下面&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">scan</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始扫描文件：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">parent</span>)&#123;           <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> files = <span class="variable language_">this</span>.<span class="property">parent</span>.<span class="property">files</span>, l = files.<span class="property">length</span> - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="keyword">var</span> file = file[l];</span><br><span class="line">        <span class="keyword">if</span>(file === <span class="variable language_">this</span>)&#123;</span><br><span class="line">            files.<span class="title function_">splice</span>(l, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面测试一下移除文件功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> folder = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;学习资料&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> folder1 = <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;深入浅出Node.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">folder1.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;JavaScript语言精髓与编程实践&#x27;</span>));</span><br><span class="line">folder.<span class="title function_">add</span>(folder1);</span><br><span class="line">folder.<span class="title function_">add</span>(file1);</span><br><span class="line"></span><br><span class="line">folder1.<span class="title function_">remove</span>();    <span class="comment">// 移除文件夹</span></span><br><span class="line">folder.<span class="title function_">scan</span>();</span><br></pre></td></tr></table></figure><h3 id="十、何时使用组合模式"><a href="#十、何时使用组合模式" class="headerlink" title="十、何时使用组合模式"></a>十、何时使用组合模式</h3><p>组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况：</p><ul><li><p>表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。</p></li><li><p>客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象还是叶对象，也就不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。</p></li></ul><h3 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h3><p>组合模式可以让我们使用树形方式创建对象的结构。可以把相同的操作应用在组合对象和单个对象上。在大多数情况下，我们都可以忽略掉组合对象和单个对象之间的差别，从而用一致的方式来处理它们。</p><p>然而，组合模式并不是完美的，他可能会产生一个这样的系统：系统中的每个对象看起来都与其他对象差不多。它们的区别只有在运行的时候才会显现出来，这会使代码难以理解。此外，如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的”孙对象”构成的。&lt;/p&gt;
&lt;h3 id=&quot;一、回顾宏命令&quot;&gt;&lt;a href=&quot;#一、回顾宏命令&quot; class=&quot;headerlink&quot; title=&quot;一、回顾宏命令&quot;&gt;&lt;/a&gt;一、回顾宏命令&lt;/h</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/11/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/11/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-11T12:36:47.000Z</published>
    <updated>2024-09-11T12:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设有一个快餐店，而我是快餐店的点餐服务员，那么我一天的工作应该是这样的：当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心的是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人正在回家的路上，要求1个小时后才开始炒他的菜，只要订单还在，厨师就不会忘记。客人也可以很方便地打电话来撤销订单。另外如果有太多地客人点餐，厨房可以按照订单的顺序排队炒菜。</p><p>这些记录着订餐信息的清单，便是命令模式中的命令对象。</p><h3 id="一、命令模式的用途"><a href="#一、命令模式的用途" class="headerlink" title="一、命令模式的用途"></a>一、命令模式的用途</h3><p>命令模式是最简单和优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。</p><p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p><p>拿订餐来说，客人需要向厨师发送请求，但是完全不知道这些厨师的名字和联系方式，也不知道厨师炒菜的方式和步骤。命令模式把客人订餐的请求封装成command对象，也就是订餐中的订餐对象。这个对象可以在程序中被四处传递，就像订餐可以从服务员中手中传到厨师手中。这样一来，客人不需要知道厨师的名字，从而解开了请求调用者和请求接收者之间的耦合关系。</p><p>另外，相对于过程化的请求调用，command对象拥有更长的生命周期。对象的生命周期是跟初始化请求无关的，因为这个请求已经被封装在了command对象的方法中，成为了这个对象的行为，我们可以在程序运行的任意时刻去调用这个方法，就像厨师可以在客人预定1个小时之后才能帮他炒菜，相当于程序在1个小时之后才开始执行command对象的方法。</p><h3 id="二、命令模式的例子-菜单程序"><a href="#二、命令模式的例子-菜单程序" class="headerlink" title="二、命令模式的例子-菜单程序"></a>二、命令模式的例子-菜单程序</h3><p>假设我们正在编写一个用户界面程序，该用户界面上至少有数十个Button按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。</p><p>命令模式的场景：</p><blockquote><p>有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁、也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p></blockquote><p>我们很快可以找到在这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体的行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。</p><p>设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外，按下按钮之后会发生一些事情是不变的，而具体会发生什么事情是可变的。通过command对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为。</p><p>首先在页面中完成这些按钮的“绘制”：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> button1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button1&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> button2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button2&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> button3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button3&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面定义setCommand函数，setCommand函数负责往按钮上安装命令。可以肯定的是，点击按钮会执行某个command命令，执行命令的动作被约定为调用command对象的execute()方法。虽然还不知道这些命令究竟代表了什么操作，但负责绘制按钮的程序员不关心这些事情，他只需要预留好安装命令的接口，command对象自然知道如何正确的对象沟通：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setCommand = <span class="keyword">function</span>(<span class="params">button, command</span>)&#123;</span><br><span class="line">    button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        command.<span class="title function_">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，负责编写点击按钮之后的具体行为的程序员交上了他们的成果，他们完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在MenuBar和SubMenu这两个对象中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MenuBar</span> = &#123;</span><br><span class="line">    <span class="attr">refresh</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;刷新菜单目录&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SubMenu</span> = &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;增加子菜单&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">del</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除子菜单&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让button变得有勇气来之前，要先把这些行为都封装在命令类中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">RefreshMenuBarCommand</span> = <span class="keyword">function</span>(<span class="params">receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">RefreshMenuBarCommand</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="title function_">refresh</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">AddSubMenuCommand</span> = <span class="keyword">function</span>(<span class="params">receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AddSubMenuCommand</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span>.<span class="title function_">add</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">DelSubMenuCommand</span> = <span class="keyword">function</span>(<span class="params">receiver</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">receiver</span> = receiver;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DelSubMenuCommand</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">execute</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除子菜单&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是把命令接收者传入到command对象中，并且把command对象安装到button上面：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = <span class="keyword">new</span> <span class="title function_">refreshMenuBarCommand</span>(<span class="title class_">MenuBar</span>);</span><br><span class="line"><span class="keyword">var</span> addSubMenuCommand = <span class="keyword">new</span> <span class="title function_">addSubMenuCommand</span>(<span class="title class_">SubMenu</span>);</span><br><span class="line"><span class="keyword">var</span> delSubMenuCommand = <span class="keyword">new</span> <span class="title function_">delSubMenuCommand</span>(<span class="title class_">SubMenu</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setCommand</span>(button1, refreshMenuBarCommand);</span><br><span class="line"><span class="title function_">setCommand</span>(button2, addSubMenuCommand);</span><br><span class="line"><span class="title function_">setCommand</span>(button3, delSubMenuCommand);</span><br></pre></td></tr></table></figure><h3 id="三、JavaScript中的命令模式"><a href="#三、JavaScript中的命令模式" class="headerlink" title="三、JavaScript中的命令模式"></a>三、JavaScript中的命令模式</h3><p>命令模式的由来，其实是回调函数的一个面向对象的替代品。</p><p>JavaScript作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到JavaScript语言之中。运算块不一定要封装在<code>command.execute</code>方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传播。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。</p><p>在面向对象设计中，命令模式的接收者被当成command对象的属性保存起来，同时约定执行命令的操作调用<code>command.execute</code>方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包产生的环境中，在将来执行命令的时候，接收者都能被顺利访问。</p><h3 id="四、撤销命令"><a href="#四、撤销命令" class="headerlink" title="四、撤销命令"></a>四、撤销命令</h3><p>命令模式的作用不仅是封装运算块，而且可以很方便地给命令对象增加撤销操作。就像订餐时客人可以通过电话来取消订单一样。</p><p>撤销操作的实现一般是给命令对象增加一个名为unexecude或者undo的方法，在该方法里执行execute的反向操作。</p><p>撤销是命令模式里一个非常有用的功能，试想一下开发一个围棋程序的时候，我们把每一棋子的变化都封装成命令，则可以轻而易举的实现悔棋功能。同样，撤销命令还可以用于编辑器的Ctrl+Z功能。</p><h3 id="五、撤销和重做"><a href="#五、撤销和重做" class="headerlink" title="五、撤销和重做"></a>五、撤销和重做</h3><p>很多时候，我们需要撤销一系列的命令。比如在一个围棋程序中，现在已经下了10步棋，我们需要一次性悔棋到第5步。在这之前，我们可以把所有执行过的下棋命令都存储在一个历史列表中，然后倒序循环来依次执行这些命令的undo操作，直到循环执行到第5个命令为止。</p><p>然而，在某些情况下无法顺利地利用undo操作让对象回到execute之前的状态。比如在一个Canvas画图的程序中，画布上有一些点，我们在这些点之间画了N条曲线把这些点相互连接起来，当然这是用命令模式来实现的。但是我们却很难为这里的命令对象定义一个擦除某条曲线的undo操作，因为在Canvas画图中，擦除一条线相对不容易实现。</p><p>这时候最好的办法是先清除画布，然后把刚才执行过的命令全部重新执行一遍。这一点同样可以利用一个历史列表堆栈办到。记录命令日志，然后重新执行它们，这是逆转不可逆命令的一个好办法。</p><h3 id="六、命令队列"><a href="#六、命令队列" class="headerlink" title="六、命令队列"></a>六、命令队列</h3><p>在订餐的故事中，如果订单的数量过多而厨师的人手不够，则可以让这些订单进行排队处理。第一个订单完成之后，再开始执行跟第二个订单有关的操作。<br>队列在动画中的运用场景也非常多，比如小球运动程序有可能遇到另外一个问题：有些用户反馈，这个程序只适合于APM小于20的人群，大部分用户都有快速连续点击按钮的习惯，当用户第二次点击button的时候，此时小球的前一个动画可能尚未结束，于是前一个动画会骤然停止，小球转而开始第二个动画的运动过程。但这并不是用户的期望，用户希望这两个动画会排队进行。<br>把请求封装成命令对象的优点在这里再次体现了出来，对象的生命周期几乎是永久的，除非我们主动去回收它。也就是说，命令对象的生命周期跟初始请求发生的时间无关，comand对象的execute 方法可以在程序运行的任何时刻执行，即使点击按钮的请求早已发生，但我们的命令对象仍然是有生命的。<br>所以我们可以把div 的这些运动过程都封装成命令对象，再把它们压进一个队列堆栈，当动画执行完，也就是当前command对象的职责完成之后，会主动通知队列，此时取出正在队列中等待的第一个命令对象，并且执行它。<br>我们比较关注的问题是，一个动画结束后该如何通知队列。通常可以使用回调函数来通知队列，除了回调函数之外，还可以选择发布-订阅模式。即在一个动画结束后发布一个消息，订阅者接收到这个消息之后，便开始执行队列里的下一个动画。</p><h3 id="七、宏命令"><a href="#七、宏命令" class="headerlink" title="七、宏命令"></a>七、宏命令</h3><p>宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。想象一下，家里有一个万能遥控器，每天回家的时候，只要按一个特别的按钮，他就会帮我们关上房间门，顺便打开电脑并登录QQ。</p><p>下面我们逐步创建一个宏命令。首先，我们依然要创建好各种Command：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openPcCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开电脑&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> openQQCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录QQ&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来定义宏命令MacroCommand，它的结构也很简单。macroCommand.add方法表示把子命令添加进宏命令对象，当调用宏命令对象的execute方法时，会迭代这一组子命令对象，并且依次执行它们的execute方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MacroCommand</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">commandsList</span>: [],</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">command</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">commandsList</span>.<span class="title function_">push</span>(command);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, command; command = <span class="variable language_">this</span>.<span class="property">commandsList</span>[i++];)&#123;</span><br><span class="line">                command.<span class="title function_">execute</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> macroCommand = <span class="title class_">MacroCommand</span>();</span><br><span class="line">macroCommand.<span class="title function_">add</span>(closeDoorCommand);</span><br><span class="line">macroCommand.<span class="title function_">add</span>(openPcCommand);</span><br><span class="line">macroCommand.<span class="title function_">add</span>(openQQCommand);</span><br><span class="line"></span><br><span class="line">macroCommand.<span class="title function_">execute</span>();</span><br></pre></td></tr></table></figure><p>当然我们还可以为宏命令添加撤销功能，跟<code>macroCommand.execute</code>类似，当调用<code>macroCommand.undo</code>方法时，宏命令里包含的所有子命令对象要依次执行各自的undo操作。</p><p>宏命令是命令模式与组合模式的联用产物。</p><h3 id="八、智能命令与傻瓜命令"><a href="#八、智能命令与傻瓜命令" class="headerlink" title="八、智能命令与傻瓜命令"></a>八、智能命令与傻瓜命令</h3><p>再看一下我们上一节创建的命令：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> closeDoorCommand = &#123;</span><br><span class="line"><span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;关门&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很奇怪，closeDoorCommand中没有包含任何receiver的信息，它本身九包揽了执行请求的行为，这跟我们之前看到的命令对象都包含了一个receiver是矛盾的。</p><p>一般来说，命令模式都会在command对象中保存一个接收者来负责真正执行客户的请求，这种情况下ml对象是”傻瓜式“的，它只负责把客户的请求转交给接收者来执行，这种模式的好处是请求发起者和请求接收者之间尽可能地得到了解耦。</p><p>但是我们也可以定义一些更”聪明“的命令对象。”聪明“的命令对象可以直接实现请求，这样一来就不再需要接收者的存在，这种”聪明“的命令对象也叫做智能命令。没有接收者的智能命令，退化到和策略模式非常相近，从代码结构上已经无法分辨它们，能分辨的只有它们的意图的不同。策略模式指向的问题域更小，所有策略对象的目标总是一致的，它们只是达到这个目标的不同手段，它们的内部实现是针对”算法“而言的。而智能命令模式指向的问题域更广，command对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设有一个快餐店，而我是快餐店的点餐服务员，那么我一天的工作应该是这样的：当某位客人点餐或者打来订餐电话后，我会把他的需求都写在清单上，然后交给厨房，客人不用关心的是哪些厨师帮他炒菜。我们餐厅还可以满足客人需要的定时服务，比如客人正在回家的路上，要求1个小时后才开始炒他的菜</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>发布-订阅模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/11/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/11/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-11T08:59:47.000Z</published>
    <updated>2024-09-11T08:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布-订阅模式。</p><h3 id="一、现实中的发布-订阅模式"><a href="#一、现实中的发布-订阅模式" class="headerlink" title="一、现实中的发布-订阅模式"></a>一、现实中的发布-订阅模式</h3><p>小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM告诉小明，不久之后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。</p><p>于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼MM决定辞职，因为厌倦了每天回答1000个相同内容的电话。</p><p>当然现实中没有那么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼MM答应他，新楼盘一推出就马上发信息给小明。小红、小强、小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘退出的时候，售楼MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。</p><h3 id="二、发布-订阅模式的作用"><a href="#二、发布-订阅模式的作用" class="headerlink" title="二、发布-订阅模式的作用"></a>二、发布-订阅模式的作用</h3><p>在这个例子中使用发布-订阅模式有着显而易见的优点：</p><ul><li>购房者不用天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。</li><li>购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购买者的任何情况，不管购房者是男是女还是一只猴子。而售楼处的任何变动也不会影响购买者，比如售楼MM离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。</li></ul><p>第一点说明发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布-订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需订阅感兴趣的事件发生点。</p><p>第二点说明发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布-订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</p><h3 id="三、DOM事件"><a href="#三、DOM事件" class="headerlink" title="三、DOM事件"></a>三、DOM事件</h3><p>实际上，只要我们曾经在DOM节点上面绑定过对事件函数，那我们就曾经使用过发布-订阅模式，来看看下面这两句简单地代码发生了什么事情：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>();   <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure><p>在这里需要监控用户点击document.body的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息等待售楼处发布消息。</p><p>当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">4</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>();   <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure><p>注意，手动触发事件更好的做法是IE下用fireEvent，标准浏览器下用dispatchEvent实现。</p><h3 id="四、自定义事件"><a href="#四、自定义事件" class="headerlink" title="四、自定义事件"></a>四、自定义事件</h3><p>除了DOM事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布-订阅模式可以用于任何JavaScript代码中。</p><p>看看如何一步步实现发布-订阅模式。</p><ul><li>首先要指定好谁充当发布者（比如售楼处）</li><li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）。</li><li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）</li></ul><p>另外，我们还可以往回调函数里面填入一些参数，订阅者可以接受这些参数，比如售楼处可以在发给订阅者的短信里面加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;                               <span class="comment">// 定义售楼处</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">clientList</span> = [];                        <span class="comment">// 缓存列表，存放订阅者的回调函数</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">listen</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;                  <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clientList</span>.<span class="title function_">push</span>(fn);                        <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;                   <span class="comment">// 发布消息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = <span class="variable language_">this</span>.<span class="property">clientList</span>[i++];)&#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);                   <span class="comment">// arguments是发布消息时带上的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面我们来进行一些测试</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                    <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                   <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><p>至此，我们已经实现了一个最简单的发布-订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买88平方米的房子，但是发布者把110平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;                               <span class="comment">// 定义售楼处</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">clientList</span> = [];                        <span class="comment">// 缓存列表，存放订阅者的回调函数</span></span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">listen</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;                  <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">clientList</span>[key])&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">clientList</span>.<span class="title function_">push</span>(fn);                        <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="property">trigger</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;                   <span class="comment">// 发布消息</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>), <span class="comment">// 取出消息类型</span></span><br><span class="line">        fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];                  <span class="comment">// 取出该消息对应的回调函数集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>)&#123;                    <span class="comment">// 如果没有订阅该消息，则返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = <span class="variable language_">this</span>.<span class="property">clientList</span>[i++];)&#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);                   <span class="comment">// arguments是发布消息时带上的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">price, squareMeter</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;squareMeter=&#x27;</span>+squareMeter);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                    <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                   <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><p>很明显，现在订阅者可以只订阅自己感兴趣的事件了。</p><h3 id="五、发布-订阅模式的通用实现"><a href="#五、发布-订阅模式的通用实现" class="headerlink" title="五、发布-订阅模式的通用实现"></a>五、发布-订阅模式的通用实现</h3><p>现在我们已经看到了如何让售楼处拥有接受订阅和发布事件的功能。假设现在小明又去另一个售楼处买房子，那么这段代码是否必须在另一个售楼处对象上重写一次呢，有没有办法可以让所有对象都拥有发布-订阅功能呢？</p><p>答案显然是有的，JavaScript作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。</p><p>所以我们把发布-订阅模式的功能提取出来，放在一个单独的对象内：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = &#123;</span><br><span class="line">    <span class="attr">clientList</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">listen</span>: <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">clientList</span>[key])&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">clientList</span>[key].<span class="title function_">push</span>(fn);   <span class="comment">// 订阅的消息添加进缓存列表</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">trigger</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">            fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>)&#123;    <span class="comment">// 如果没有绑定对应的消息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);   <span class="comment">// arguments是trigger时带上的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再定义一个installEvent函数，这个函数可以给所有的对象都动态安装发布-订阅功能。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> installEvent = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event)&#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来测试一遍，我们给售楼处对象salesOffices动态增加发布-订阅功能：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;</span><br><span class="line"><span class="title function_">installEvent</span>(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                         <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                        <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><h3 id="六、取消订阅事件"><a href="#六、取消订阅事件" class="headerlink" title="六、取消订阅事件"></a>六、取消订阅事件</h3><p>有时候，我们也许需要取消订阅事件的功能，比如，小明突然不想买房子了，为了避免继续收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在我们给event对象添加remove方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!fns)&#123;      <span class="comment">// 如果key对应的消息没有被人订阅，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fn)&#123;       <span class="comment">// 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅</span></span><br><span class="line">        fns&amp;&amp;(fns.<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> l = fns.<span class="property">length</span> - <span class="number">1</span>;l &gt;= <span class="number">0</span>;i--)&#123;  <span class="comment">// 反向遍历订阅的回调函数列表</span></span><br><span class="line">            <span class="keyword">var</span> _fn = fns[l];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">                fns.<span class="title function_">splice</span>(l,i);                 <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> salesOffices = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> installEvent = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> event)&#123;</span><br><span class="line">        obj[i] = event[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">installEvent</span>(salesOffices);</span><br><span class="line"></span><br><span class="line">salesOffice.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">2000000</span>, <span class="number">88</span>);                         <span class="comment">// 200万 88平方米</span></span><br><span class="line">salesOffices.<span class="title function_">trigger</span>(<span class="number">3000000</span>, <span class="number">110</span>);                        <span class="comment">// 300万 110平方米</span></span><br></pre></td></tr></table></figure><h3 id="七、全局的发布-订阅对象"><a href="#七、全局的发布-订阅对象" class="headerlink" title="七、全局的发布-订阅对象"></a>七、全局的发布-订阅对象</h3><p>回想下刚刚实现的发布-订阅模式，我们给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题。</p><ul><li><p>我们给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表clientList，这其实是一种资源浪费。</p></li><li><p>小明跟售楼处对象还是存在一定的耦合性。小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。见代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffices.<span class="title function_">listen</span>(<span class="string">&#x27;sqareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>如果小明还关心300平米的房子，而这套房子的卖家是salesOffices2，这意味着小明要开始订阅salesOffices2对象，见如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">salesOffices2.<span class="title function_">listen</span>(<span class="string">&#x27;sqareMeter100&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;     <span class="comment">// 小明订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利的接收到消息。当然，为了保证订阅者和发布者能够顺利通信，订阅者和发布者都必须知道这个中介公司。</p><p>同样在程序中，发布-订阅模式可以用一个全局的Event对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event作为一个类似“中介者”的角色，把订阅者和发布者联系起来，见如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Event</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> clientList = &#123;&#125;,</span><br><span class="line">        listen,</span><br><span class="line">        trigger,</span><br><span class="line">        remove;</span><br><span class="line">    </span><br><span class="line">    listen = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!clientList[key])&#123;</span><br><span class="line">            clientList[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        clientList[key].<span class="title function_">push</span>(fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    trigger = <span class="keyword">function</span>(<span class="params">key, fn</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">        fns = clientList[key];</span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,fn; fn = fns[i++];)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    remove = <span class="keyword">function</span>(<span class="params">key,fn</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> fns = clientList[key];</span><br><span class="line">        <span class="keyword">if</span>(!fns)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fn)&#123;</span><br><span class="line">        fns&amp;&amp;(fns.<span class="property">length</span> = <span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> l = fns.<span class="property">length</span> - <span class="number">1</span>;l &gt;= <span class="number">0</span>;i--)&#123;  <span class="comment">// 反向遍历订阅的回调函数列表</span></span><br><span class="line">            <span class="keyword">var</span> _fn = fns[l];</span><br><span class="line">            <span class="keyword">if</span>(_fn === fn)&#123;</span><br><span class="line">                fns.<span class="title function_">splice</span>(l,i);                 <span class="comment">// 删除订阅者的回调函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">listen</span>: listen,</span><br><span class="line">        <span class="attr">trigger</span>: trigger,</span><br><span class="line">        <span class="attr">remove</span>: remove</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="keyword">function</span>(<span class="params">price</span>)&#123;   <span class="comment">// 小红订阅消息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;价格=&#x27;</span>+price);                   <span class="comment">// 价格=2000000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;squareMeter88&#x27;</span>, <span class="number">2000000</span>)          <span class="comment">// 售楼处发布消息</span></span><br></pre></td></tr></table></figure><h3 id="八、模块间通信"><a href="#八、模块间通信" class="headerlink" title="八、模块间通信"></a>八、模块间通信</h3><p>上一节实现的发布-订阅模式的实现，是基于一个全局的Event对象，我们利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司之后，我们不再需要知道房子开售的消息来自哪个售楼处。</p><p>比如现在有两个模块，a模块里面有一个按钮，每次点击按钮后，b模块里面的div中会显示按钮的点击次数，我们用发布-订阅模式完成下面的代码，使得a模块和b模块可以在保持封装性的前提下进行通信</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span><br><span class="line">            点我</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;count&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        button.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Event</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;add&#x27;</span>, count++);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)();</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> b = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;show&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Event</span>.<span class="title function_">listen</span>(<span class="string">&#x27;add&#x27;</span>, <span class="keyword">function</span>(<span class="params">count</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                div.<span class="property">innerHTML</span> = count;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;)();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但在这里我们要留意另一个问题，模块之间如果用了太多的全局发布-订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。</p><h3 id="九、必须先订阅再发布吗"><a href="#九、必须先订阅再发布吗" class="headerlink" title="九、必须先订阅再发布吗"></a>九、必须先订阅再发布吗</h3><p>我们了解到的发布-订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的信息，如果把顺序反过来，发布者先发布一条消息，而在此之前并没有对象来订阅他，这条消息无疑将消失在宇宙中。</p><p>在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅他的时候，再重新把消息发给订阅者。就如同QQ离线消息一样，离线消息被保存在服务器中，接收人下次登录上线的时候，可以重新收到这条消息。</p><p>这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户信息之后才能渲染到用户导航模块，而获取用户信息的操作是一个ajax异步请求。当ajax请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。</p><p>但是这只是理想的状况，因为异步的原因，我们不能保证ajax请求返回的时间，有时候它返回得比较快，而此时用户导航模块得代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许我们还需要一个方案，使得我们的发布-订阅对象拥有先发布后订阅的能力。</p><p>为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像QQ的未读消息只会被重新阅读一次，所有刚才的操作我们只能进行一次。</p><h3 id="十、JavaScript实现发布-订阅模式的便利性"><a href="#十、JavaScript实现发布-订阅模式的便利性" class="headerlink" title="十、JavaScript实现发布-订阅模式的便利性"></a>十、JavaScript实现发布-订阅模式的便利性</h3><p>这里要提出的是，我们一直讨论的发布-订阅模式，跟一些别的语言（比如java）中的实现还是有区别的。在java中实现一个自己的发布-订阅模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需要提供一个名为诸如update的方法，供发布者对象在适合的时候调用。而在JavaScript中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个：门户大开“的对象，同时增加了代码量和复杂度。</p><p>刚好在JavaScript中，arguments可以很方便地表示参数列表，所以我们一般都会选择推模型，使用<code>Function.prototype.apply</code>方法把所有参数都推送给订阅者。</p><h3 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h3><p>发布-订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布-订阅模式还可以用来帮助实现一些别的设计模式，比如中介模式。从架构上来看，无论是MVC还是MVVM，都少不了发布-订阅模式的参与，而且JavaScript本身也是一门基于事件驱动的语言。</p><p>当然，发布-订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布-订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug不是件轻松的事情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布-订阅模式。&lt;/p&gt;
&lt;h3 id=&quot;一、现实中的发布-订阅模式&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/03/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-03T04:51:47.000Z</published>
    <updated>2024-09-03T04:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><h3 id="一、实现自己的迭代器"><a href="#一、实现自己的迭代器" class="headerlink" title="一、实现自己的迭代器"></a>一、实现自己的迭代器</h3><p>实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="keyword">function</span>(<span class="params">ary,callback</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = ary.<span class="property">length</span>; i &lt; l; i++)&#123;</span><br><span class="line">        callback.<span class="title function_">call</span>(ary[i], i, ary[ i ]);    <span class="comment">// 把下标和元素当作参数传给callback函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="keyword">function</span>(<span class="params">i, n</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>([i, n]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="二、内部迭代器和外部迭代器"><a href="#二、内部迭代器和外部迭代器" class="headerlink" title="二、内部迭代器和外部迭代器"></a>二、内部迭代器和外部迭代器</h3><p>迭代器可以分为内部迭代器和外部迭代器</p><ol><li><h4 id="内部迭代器"><a href="#内部迭代器" class="headerlink" title="内部迭代器"></a>内部迭代器</h4><p>我们刚刚编写的each函数属于内部迭代器，each函数的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。</p><p>内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的each函数就无法同时迭代2个数组了。</p><p>在一些没有闭包的语言中，内部迭代器本身的实现也相当复杂。比如C语言中的内部迭代器是用函数指针来实现的，循环处理所需要的数据都要以参数的形式明确地从外面传递进去。</p></li><li><h4 id="外部迭代器"><a href="#外部迭代器" class="headerlink" title="外部迭代器"></a>外部迭代器</h4><p>外部迭代器必须显式地请求迭代下一个元素。</p><p>外部迭代器增加了一些调用地复杂度，但相对也增强了迭代器地灵活性，我们可以手工控制迭代的过程或者顺序。</p></li></ol><h3 id="三、迭代类数组对象和字面量对象"><a href="#三、迭代类数组对象和字面量对象" class="headerlink" title="三、迭代类数组对象和字面量对象"></a>三、迭代类数组对象和字面量对象</h3><p>迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象，无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那它就可以被迭代。</p><p>在JavaScript中，for in语句可以用来迭代普通字面量对象的属性。</p><p><img src="/../image/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/image-20240903123550097.png" alt="image-20240903123550097"></p><h3 id="四、倒序迭代器"><a href="#四、倒序迭代器" class="headerlink" title="四、倒序迭代器"></a>四、倒序迭代器</h3><p>由于GoF中对迭代器模式的定义非常松散，所以我们可以有多种多样的迭代器实现，总的来说，迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定我们以顺序、倒序还是中序来循环遍历聚合对象。</p><p>下面实现一个倒序访问的迭代器：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseEach = <span class="keyword">function</span>(<span class="params">ary,callback</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = ary.<span class="property">length</span> - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)&#123;</span><br><span class="line">        <span class="title function_">callback</span>(l, ary[l]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">reverseEach</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="keyword">function</span>(<span class="params">i, n</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);    <span class="comment">// 2， 1， 0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="五、中止迭代器"><a href="#五、中止迭代器" class="headerlink" title="五、中止迭代器"></a>五、中止迭代器</h3><p>迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。</p><p>下面我们把之前的each函数改写一下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> each = <span class="keyword">function</span>(<span class="params">ary, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; l = ary.<span class="property">length</span>; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">callback</span>(i, ary[i]) === <span class="literal">false</span>)&#123;     <span class="comment">// callback的执行结果返回false，提前终止迭代</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="keyword">function</span>(<span class="params">i, n</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">3</span>)&#123;                  <span class="comment">// n大于3的时候终止循环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)              <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-03T02:29:47.000Z</published>
    <updated>2024-09-03T02:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>代理模式是为了一个对象提供一个代用品或占位符，以便控制对它的访问</p><p>道理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理后，再把请求转交给本体对象。</p><h3 id="一、第一个例子——小明追MM的故事"><a href="#一、第一个例子——小明追MM的故事" class="headerlink" title="一、第一个例子——小明追MM的故事"></a>一、第一个例子——小明追MM的故事</h3><blockquote><p>在四月一个晴朗的早晨，小明遇到了他百分百女孩，我们暂且称呼小明的女神为A。两天过后，小明决定给A送一束花来表白。刚好小明打听到A和他有一个共同的朋友B，于是内向的小明决定让B来代替自己完成送花这件事情。</p></blockquote><p>不用代理模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Flower</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> flower = <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        target.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">receiveFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到花&#x27;</span> + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sendFlower</span>(A);</span><br></pre></td></tr></table></figure><p>接下来，我们引入代理B，即小明通过B来给A送花：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Flower</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> flower = <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        target.<span class="title function_">receivelower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        A.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">receiveFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到花&#x27;</span> + flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sendFlower</span>(B);</span><br></pre></td></tr></table></figure><p>现在我们改变故事的背景设定，假设当A在心情好的时候收到花，小明表白成功的机率有60%，而当A在心情差的时候收到花，小明表白的成功率无限趋近于0.</p><p>小明跟A刚刚认识两天，还无法辨别A什么时候心情好。如果不合时宜地把花送给A，花被直接扔掉的可能性很大。</p><p>但是A的朋友B却很了解A，所以小明只管把花交给B，B会监听A的心情变化，然后选择A心情好的时候把花转交给A：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Flower</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    <span class="attr">sendFlower</span>: <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> flower = <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        target.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        A.<span class="title function_">listenGoodMood</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// 监听A的好心情</span></span><br><span class="line">            A.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到花&#x27;</span> + flower);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">listenGoodMood</span>: <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">fn</span>();</span><br><span class="line">        &#125;, <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.<span class="title function_">sendFlower</span>(B);</span><br></pre></td></tr></table></figure><h3 id="二、保护代理和虚拟代理"><a href="#二、保护代理和虚拟代理" class="headerlink" title="二、保护代理和虚拟代理"></a>二、保护代理和虚拟代理</h3><p>代理B可以帮助A过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理B处被拒绝掉。这种代理叫做<strong>保护代理</strong>。A和B一个充当白脸，一个充当黑脸，白脸A继续保持良好的女神形象，不希望直接拒绝任何人，于是找了黑脸B来控制对A的访问。</p><p>假设现实中化的价格不菲，导致在程序世界里，new Flower也是一个代价昂贵的操作，那么我们可以把new Flower的操作交给代理B去执行，代理B会选择在A心情好时再执行new Flower，这是代理的另一种模式，叫做<strong>虚拟代理</strong>。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    <span class="attr">receiverFlower</span>: <span class="keyword">function</span>(<span class="params">flower</span>)&#123;</span><br><span class="line">        A.<span class="title function_">listenGoodMood</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// 监听A的好心情</span></span><br><span class="line">            A.<span class="title function_">receiveFlower</span>(flower);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>保护代理用于控制不同权限的对象对目标对象的访问，但在JavaScript并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式。</p><h3 id="三、虚拟代理图片预加载"><a href="#三、虚拟代理图片预加载" class="headerlink" title="三、虚拟代理图片预加载"></a>三、虚拟代理图片预加载</h3><p>在web开发中，图片预加载是一种常用的技术，如果直接给某个img标签节点设置src属性，由于图片过大或者网络不佳，图片的位置往往有段时间是空白的。常见的做法是先用一张loading图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img节点里，这种场景就很适合使用虚拟代理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            imgNode.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">myImage.<span class="title function_">setSrc</span>(<span class="string">&#x27;http://xxx.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在开始引入代理对象proxyImage，通过这个代理对象，在图片被真正加载好之前，页面中将出现一张占位的图，来提示用户图片正在加载。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            imgNode.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>;</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        myImage.<span class="title function_">setSrc</span>(<span class="variable language_">this</span>.<span class="property">src</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            myImage.<span class="title function_">setSrc</span>(<span class="string">&#x27;file:xxx.gif&#x27;</span>);</span><br><span class="line">            img.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImage.<span class="title function_">setSrc</span>(<span class="string">&#x27;http://xxx.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="四、代理的意义"><a href="#四、代理的意义" class="headerlink" title="四、代理的意义"></a>四、代理的意义</h3><p>不用代理的预加载图片函数实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyImage</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>;</span><br><span class="line">    </span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        imgNode.<span class="property">src</span> = img.<span class="property">src</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">setSrc</span>: <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">            imgNode.<span class="property">src</span> = <span class="string">&#x27;file:xxx.gif&#x27;</span>;</span><br><span class="line">            img.<span class="property">src</span> = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyImage</span>.<span class="title function_">setSrc</span>(<span class="string">&#x27;http://xxx.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了说明代理的意义，下面我们引人一个面向对象设计的原则——单一职责原则。</p><p>单一职责原则指的是，就一个类(通常也包括对象和丽数等)而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中,如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。</p><p>职责被定义为“引起变化的原因”。上段代码中的MyImage对象除了负责给img节点设置src外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。</p><p>另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放——封闭原则。如果我们只是从网络上获取一些体积很小的图片，或者5年后的网速快到根本不再需要预加载，我们可能希望把预加载图片的这段代码从MyImage对象里删掉。这时候就不得不改动MyImage对象了。</p><p>实际上，我们需要的只是给img节点设置STC，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体MyImage。</p><h3 id="五、代理和本体接口的一致性"><a href="#五、代理和本体接口的一致性" class="headerlink" title="五、代理和本体接口的一致性"></a>五、代理和本体接口的一致性</h3><p>上一节说到，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的别，这样做有两个好处。</p><ul><li>用户可以放心地请求代理，他只关心是否能得到想要的结果。</li><li>在任何使用本体的地方都可以替换成使用代理。</li></ul><p>在Java等语言中，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥有同样的方法，另一方面，面向接口编程迎合依赖倒置原则，通过接口进行向上转型，从而避开编译器的类型检查，代理和本体将来可以被替换使用。</p><p>在JavaScrit这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了setSrc方法，另外大多数时候甚至干跪不做检测，全部依赖程序员的自觉性，这对于程序的健壮性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内，而且我们也习惯了没有接口的世界。</p><p>另外值得一提的是，如果代理对象和本体对象都为一个两数(两数也是对象)，两数必然都能被执行，则可以认为它们也具有一致的“接口”。</p><h3 id="六、虚拟代理合并HTTP请求"><a href="#六、虚拟代理合并HTTP请求" class="headerlink" title="六、虚拟代理合并HTTP请求"></a>六、虚拟代理合并HTTP请求</h3><p>先想象这样一个场景：每周我们都要写一份工作周报，周报要交给总监批阅。总监手下管理着150个员工，如果我们每个人直接把周报发给总监，那总监可能要把一整周的时间都花在查看邮件上面。</p><p>现在我们把周报发给各自的组长，组长作为代理，把组内成员的周报合并提炼成一份后一次性地发给总监。这样一来，总监的邮箱便清净多了。</p><p>这个例子在程序世界里很容易引起共鸣，在Web开发中，也许最大的开销就是网络请求。假设我们在做一个文件同步的功能，当我们选中一个checkbox的时候，它对应的文件就会被同步到另外一台备用服务器上面。</p><h3 id="七、缓存代理"><a href="#七、缓存代理" class="headerlink" title="七、缓存代理"></a>七、缓存代理</h3><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。</p><ol><li><h4 id="缓存代理的例子——计算乘积"><a href="#缓存代理的例子——计算乘积" class="headerlink" title="缓存代理的例子——计算乘积"></a>缓存代理的例子——计算乘积</h4><p>先创建一个用于求乘积的函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始计算乘积&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; l = <span class="variable language_">arguments</span>.<span class="property">length</span>;i &lt; l; i++)&#123;</span><br><span class="line">        a = a * <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mult</span>(<span class="number">2</span>,<span class="number">3</span>);   <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">mult</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>现在加入缓存代理函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxyMult = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(args <span class="keyword">in</span> cache)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[args] = mult.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title function_">proxyMult</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);   <span class="comment">// 24</span></span><br><span class="line"><span class="title function_">proxyMult</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);   <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>当我们第二次调用proxyMult(1，2，3，4）的时候，本体mult函数并没有被计算，proxyMult直接返回了之前缓存好的计算结果。</p><p>通过增加缓存代理的方式，mult函数可以继续专注于自身的职责——计算乘积，缓存的功能是由代理对象实现的。</p></li><li><h4 id="缓存代理用于ajax异步请求"><a href="#缓存代理用于ajax异步请求" class="headerlink" title="缓存代理用于ajax异步请求"></a>缓存代理用于ajax异步请求</h4><p>我们在常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。</p><p>显然这里也可以引人缓存代理，实现方式跟计算乘积的例子差不多，唯一不同的是，请求数据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。</p></li></ol><h3 id="八、其他代理模式"><a href="#八、其他代理模式" class="headerlink" title="八、其他代理模式"></a>八、其他代理模式</h3><p>代理模式的变化种类非常多</p><ul><li>防火墙代理：控制网络资源的访问，保护主机不让”坏人”接近。</li><li>远程代理：为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象，</li><li>保护代理：用于对象应该有不同访问权限的情况。</li><li>智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。</li><li>写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;代理模式是为了一个对象提供一个代用品或占位符，以便控制对它的访问&lt;/p&gt;
&lt;p&gt;道理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/02/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-09-02T04:59:47.000Z</published>
    <updated>2024-09-02T05:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="一、实现单例模式"><a href="#一、实现单例模式" class="headerlink" title="一、实现单例模式"></a>一、实现单例模式</h3><p>用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Singleton</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;seven1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;seven2&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(a === b);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通过<code>Singleton.getInstance</code>来获取Singleton类的唯一对象，这种方式相对简单，但有一个问题，就是增加了这个类的”不透明性”，Singleton类的使用者必须知道这是一个单例类，跟以往通过new xxx的方式来获取的对象不同，这里偏要使用<code>Singleton.getInstance</code>来获取对象。</p><h3 id="二、透明的单例模式"><a href="#二、透明的单例模式" class="headerlink" title="二、透明的单例模式"></a>二、透明的单例模式</h3><p>用户从这个类中创建对象的时候，可以像使用其他任何普通类一样。下面，我们将使用CreateDiv单例类，它的作用是负责在页面中创建唯一的div节点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CreateDiv</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">CreateDiv</span> = <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">html</span> = html;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">        <span class="keyword">return</span> instance = <span class="variable language_">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">CreateDiv</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">html</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CreateDiv</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(<span class="string">&#x27;seven1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(<span class="string">&#x27;seven2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(a === b);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为了把instance封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回真正的Singleton构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。</p><p>CreateDiv的构造函数实际上负责了两件事情，第一是创建对象和执行初始化init方法，第二是保证只有一个对象。</p><h3 id="三、用代理实现单例模式"><a href="#三、用代理实现单例模式" class="headerlink" title="三、用代理实现单例模式"></a>三、用代理实现单例模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CreateDiv</span> = <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">html</span> = html;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CreateDiv</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> div = documents.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">html</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来引入代理类proxySingletonCreateDiv：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxySingletonCreateDiv = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">CreateDiv</span>(html);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">proxySingletonCreateDiv</span>(<span class="string">&#x27;seven1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">proxySingletonCreateDiv</span>(<span class="string">&#x27;seven2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(a === b);</span><br></pre></td></tr></table></figure><p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们负责管理单例的逻辑移到了代理类proxySingletonCreateDiv中，这样一来，CreateDiv就变成了一个普通的类，它跟proxySingletonCreateDiv组合起来可以达到单例模式的效果。</p><h3 id="四、JavaScript中的单例模式"><a href="#四、JavaScript中的单例模式" class="headerlink" title="四、JavaScript中的单例模式"></a>四、JavaScript中的单例模式</h3><p>前面提到的几种单例模式的实现，更多的是接近传统面向对象语言中的实现，单例对象从”类”中创建而来。在以类为中心的语言中，这是很自然的做法。</p><p>但JavaScript其实是一门无类语言，也正因为如此，生搬单例模式的概念并无意义。在JavaScript中创建对象的方法非常简单，既然我们只需一个”唯一”的对象，为什么要为它先创建一个”类”呢？</p><p><strong>单例模式的核心是确保只有一个实例，并提供全局访问</strong></p><p>全局变量不是单例模式，但在JavaScript开发中，我们经常会把全局变量当成单例来使用：<code>var a = &#123;&#125;</code>。</p><p>当用这种方式创建对象a时，对象a确实是独一无二的。如果a变量被声明在全局作用域下，则我们可以在代码中的任何位置使用这个变量，全局变量提供给全局访问是理所当然的。这样满足了单例模式的两个条件。</p><p>但是全局变量存在很多问题，它很容易造成命名空间污染。在大中型项目中，如果不加以限制和管理，程序中可能存在很多这样的变量JavaScript中的变量也很容易被不小心覆盖，相信每个JavaScript程序员都曾经历过变量冲突的痛苦，随时有可能被别人覆盖。</p><p>作为普通的开发者，我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。以下几种方式可以相对降低全局变量带来的命名污染。</p><ol><li><h4 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h4><p>适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。</p><p>最简单的方法依然是用对象字面量的方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> namespace1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把a和b都定义为namespace1的属性，这样可以减少变量和全局作用域打交道的机会。另外，我们还可以动态地创建命名空间：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyApp</span> = &#123;&#125;;</span><br><span class="line"><span class="title class_">MyApp</span>.<span class="property">namespace</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = name.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> current = <span class="title class_">MyApp</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> parts)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!current[parts[i]])&#123;</span><br><span class="line">            current[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyApp</span>.<span class="title function_">namespace</span>(<span class="string">&#x27;event&#x27;</span>);</span><br><span class="line"><span class="title class_">MyApp</span>.<span class="title function_">namespace</span>(<span class="string">&#x27;dom.style&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="title class_">MyApp</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyApp</span> = &#123;</span><br><span class="line">    <span class="attr">event</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">dom</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="使用闭包封装私有变量"><a href="#使用闭包封装私有变量" class="headerlink" title="使用闭包封装私有变量"></a>使用闭包封装私有变量</h4><p>这种方法把一些变量封装在闭包内部，只暴露一些接口跟外界通信：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> __name = <span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">        __age = <span class="number">29</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getUserInfo</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> __name + <span class="string">&#x27;-&#x27;</span> + age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>用下划线来约定变量<code>__name</code>和<code>__age</code>，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。</p></li></ol><h3 id="五、惰性单例"><a href="#五、惰性单例" class="headerlink" title="五、惰性单例"></a>五、惰性单例</h3><p>惰性单例指的是在需要的时候才创建对象实例。instance实例对象总是在我们调用<code>Singleton.getInstance</code>的时候才被创建，而不是在页面加载好的时候就创建。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Singleton</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>不过这是基于”类”的单例模式，基于”类”的单例模式在JavaScript中并不适用。</p><h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><p>单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理惰性单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;h3 id=&quot;一、实现单例模式&quot;&gt;&lt;a href=&quot;#一、实现单例模式&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://cychenhaibin.github.io/2024/09/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://cychenhaibin.github.io/2024/09/01/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-08-31T18:51:47.000Z</published>
    <updated>2024-08-31T18:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>策略模式的定义是：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。</p><h3 id="一、使用策略模式计算奖金"><a href="#一、使用策略模式计算奖金" class="headerlink" title="一、使用策略模式计算奖金"></a>一、使用策略模式计算奖金</h3><ol><li><h4 id="最初代码实现："><a href="#最初代码实现：" class="headerlink" title="最初代码实现："></a>最初代码实现：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calculateBonus = <span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">calculateBonus</span>(<span class="string">&#x27;B&#x27;</span>,<span class="number">20000</span>);   <span class="comment">// 40000</span></span><br><span class="line"><span class="title function_">calculateBonus</span>(<span class="string">&#x27;S&#x27;</span>,<span class="number">6000</span>);    <span class="comment">// 24000</span></span><br></pre></td></tr></table></figure><p>这段代码十分简单，但是存在着显而易见的缺点：</p><ul><li><p><code>calculateBonus</code>函数比较庞大，包含了很多if-else语句，这些语句需要覆盖所有的逻辑分支。</p></li><li><p><code>calculateBonus</code>函数缺乏弹性违反开放-封闭原则</p></li><li><p>算法的复用性差</p></li></ul></li><li><h4 id="使用组合函数重构代码"><a href="#使用组合函数重构代码" class="headerlink" title="使用组合函数重构代码"></a>使用组合函数重构代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">performanceS</span>(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">performanceA</span>(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(performanceLevel === <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">performanceB</span>(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">calculateBonus</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10000</span>);    <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure></li><li><h4 id="使用策略模式重构代码"><a href="#使用策略模式重构代码" class="headerlink" title="使用策略模式重构代码"></a>使用策略模式重构代码</h4><p>策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式的目的就是将算法的使用与算法的实现分离开来。</p><p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组<strong>策略类</strong>，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是<strong>环境类Context</strong>，Context接受客户的请求，随后把请求委托给某一个策略类。</p><p>也可以有三种：<strong>抽象策略（strategy）类、具体策略（Concrete Strategy）类、环境（Context）类。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">performanceS.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">performanceA.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">performanceB.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">calculate</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来定义奖金类Bonus</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Bonus</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">salary</span> = <span class="literal">null</span>;                           <span class="comment">// 原始工资</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = <span class="literal">null</span>;                         <span class="comment">// 绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setSalary</span> = <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">salary</span> = salary;                         <span class="comment">// 设置员工的原始工资</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setStrategy</span> = <span class="keyword">function</span>(<span class="params">strategy</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = strategy;                     <span class="comment">// 设置员工绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bonus</span>.<span class="property">prorotype</span>.<span class="property">getBonus</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;            <span class="comment">// 取得奖金数额</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">strategy</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;未设置strategy属性&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">strategy</span>.<span class="title function_">calculate</span>(<span class="variable language_">this</span>.<span class="property">salary</span>);  <span class="comment">// 把计算奖金操作委托给对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="keyword">new</span> <span class="title class_">Bonus</span>();</span><br><span class="line"></span><br><span class="line">bonus.<span class="title function_">setSalary</span>(<span class="number">10000</span>);</span><br><span class="line">bonus.<span class="title function_">setStrategy</span>(<span class="keyword">new</span> <span class="title function_">performanceS</span>());            <span class="comment">// 设置策略对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bonus.<span class="title function_">getBonus</span>());                    <span class="comment">// 40000</span></span><br><span class="line"></span><br><span class="line">bonus.<span class="title function_">setStrategy</span>(<span class="keyword">new</span> <span class="title function_">performanceA</span>());            <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bonus.<span class="title function_">getBonus</span>());                    <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二、JavaScript版本的策略模式"><a href="#二、JavaScript版本的策略模式" class="headerlink" title="二、JavaScript版本的策略模式"></a>二、JavaScript版本的策略模式</h3><p>实际上在JavaScript语言中，函数也是对象，所以更简单和直接的做法是把strategy直接定义为函数：</p><p>将判断语句改写成对象形式可以消除大片的条件分支语句</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line">    <span class="string">&quot;S&quot;</span>: <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;B&quot;</span>: <span class="keyword">function</span>(<span class="params">salary</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="keyword">function</span>(<span class="params">level, salary</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[level](salary);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculateBonus</span>(<span class="string">&#x27;S&#x27;</span>,<span class="number">20000</span>));   <span class="comment">// 80000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculateBonus</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">10000</span>));   <span class="comment">// 30000</span></span><br></pre></td></tr></table></figure><h3 id="三、多态在策略模式中的体现"><a href="#三、多态在策略模式中的体现" class="headerlink" title="三、多态在策略模式中的体现"></a>三、多态在策略模式中的体现</h3><p>通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。<strong>当我们对这些策略对象发出”计算奖金”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是”它们可以相互替换”的目的。</strong>替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。</p><h3 id="四、策略模式的优缺点"><a href="#四、策略模式的优缺点" class="headerlink" title="四、策略模式的优缺点"></a>四、策略模式的优缺点</h3><ol><li><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li><li>策略模式提供了对开放-封闭原则地完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。</li><li>策略模式的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li><li>在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案。</li></ul></li><li><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。</p></li><li><p>要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。</p></li></ul></li></ol><h3 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h3><p>在JavaScript语言的策略模式中，策略类往往被函数所代替，这时策略模式就成为一种”隐式”的模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;策略模式的定义是：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p&gt;
&lt;h3 id=&quot;一、使用策略模式计算奖金&quot;&gt;&lt;a href=&quot;#一、使用策略模式计算奖金&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>闭包和高阶函数</title>
    <link href="http://cychenhaibin.github.io/2024/08/31/%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://cychenhaibin.github.io/2024/08/31/%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-31T15:00:47.000Z</published>
    <updated>2024-08-31T15:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><ol><li><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 <code>var</code> ，这个变量就会成为全局变量。另一种情况是用 <code>var</code> 关键字在函数中声明变量，这时候变量即是局部变量。</p><p>在JavaScript中，函数可以用来创造函数作用域，此时的函数就像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。<strong>变量的搜索是从内到外而非从外到内的。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> func2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">alert</span>(b);   <span class="comment">// 2</span></span><br><span class="line">        <span class="title function_">alert</span>(a);   <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">func2</span>();</span><br><span class="line">    <span class="title function_">alert</span>(c);       <span class="comment">// c is not defined</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure></li><li><h4 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;     <span class="comment">// 退出函数后局部变量a将被销毁</span></span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">alert</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="title function_">alert</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">func</span>();</span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>当退出函数后，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行了 <code>var f = func()</code> 时，f返回了一个匿名函数的引用，它可以访问到 <code>func()</code> 被调用时产生的环境，二局部变量a一直处于这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个<strong>闭包结构</strong>，局部变量的生命看起来被延续了。</p></li><li><h4 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h4><ol><li><h5 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h5><p>闭包可以帮助把一些不需要暴露在全局的变量封装成”私有变量”。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; l = <span class="variable language_">arguments</span>.<span class="property">length</span>; i&lt;l; i++)&#123;</span><br><span class="line">        a = a * <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="延续局部变量的寿命"><a href="#延续局部变量的寿命" class="headerlink" title="延续局部变量的寿命"></a>延续局部变量的寿命</h5></li></ol></li><li><h4 id="闭包的面向对象设计"><a href="#闭包的面向对象设计" class="headerlink" title="闭包的面向对象设计"></a>闭包的面向对象设计</h4><p>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</p><p>下面看看这段跟闭包相关的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extent = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">call</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            value++;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> extent = <span class="title function_">extent</span>();</span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 1</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 2</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果换成面向对象的写法，就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> extent = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">call</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 1</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 2</span></span><br><span class="line">extent.<span class="title function_">call</span>();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><h4 id="用闭包实现命令模式"><a href="#用闭包实现命令模式" class="headerlink" title="用闭包实现命令模式"></a>用闭包实现命令模式</h4><p>命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者（执行者）之间的耦合关系。</p></li><li><h4 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h4><p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。<strong>使用闭包的原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量</strong>，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。不能说成是内存泄露。</p><p>跟闭包和内存泄漏有关系的地方是，使用闭包的同时比较容易形成<strong>循环引用</strong>，<strong>如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄漏</strong>，但这本身并非闭包问题，也并非JavaScript的问题，在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。</p><p>同样，如果要解决循环引用带来的内存泄露问题，我们<strong>只需要把循环引用中的变量设为null即可</strong>。将变量设置为null意味着<strong>切断变量与它此前引用的值之间的连接</strong>。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p></li></ol><h3 id="二、高阶函数"><a href="#二、高阶函数" class="headerlink" title="二、高阶函数"></a>二、高阶函数</h3><p>高阶函数是指至少满足下列条件之一的函数：</p><ul><li><p>函数可以作为参数被传递</p></li><li><p>函数可以作为返回值输出</p></li><li><p>一个函数可以接收另一个函数作为参数</p></li></ul><ol><li><h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><ol><li><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>在ajax异步请求的应用中，回调函数的使用非常频繁。当我们想在ajax请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把callback函数当作参数传入发起ajax请求的方法中，待请求完成之后执行callback函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getUserInfo = <span class="keyword">function</span>(<span class="params">userId, callback</span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(<span class="string">&#x27;http://xxx.com/getUserInfo?&#x27;</span>+userId,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getUserInfo</span>(<span class="number">13157</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(data.<span class="property">userName</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，”委托”给另外一个函数来执行。</p></li><li><h5 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a><code>Array.prototype.sort</code></h5><p><code>Array.prototype.sort</code>接受一个函数当作参数，这个函数里面封装了数组元素的排列顺序。从<code>Array.prototype.sort</code>的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数的参数里，动态传入<code>Array.prototype.sort</code>，使<code>Array.prototype.sort</code>方法成为了一个非常灵活的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;   <span class="comment">// 从小到大排</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h4><ol><li><h5 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h5><p>判断一个数据是否是数组，在以往的实现中，可以基于鸭子类型的概念来判断，比如判断这个数据有没有length属性，有没有sort方法或者slice方法等。但更好的方式是用<code>Object.prototype.toString</code>来计算。<code>Object.prototype.toString.call(obj)</code>返回一个字符串，比如<code>Object.prototype.toString.call([1,2,3])</code>总是返回<code>&quot;[object Array]&quot;</code>。所以我们可以编写一系列的isType函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isString = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isArray = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h5 id="getSingle"><a href="#getSingle" class="headerlink" title="getSingle"></a>getSingle</h5><p>这个高阶的例子，既把函数当作参数传递，又让函数执行后返回了另一个函数。可以看看getSingle的效果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getScript = <span class="title function_">getSingle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script1 = <span class="title function_">getScript</span>();</span><br><span class="line"><span class="keyword">var</span> script2 = <span class="title function_">getScript</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(script1 === script2);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h4><p>AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来后，再通过”动态织入”的方式掺入业务逻辑模块中。</p></li><li><h4 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h4><ol><li><h5 id="currying（柯里化函数）"><a href="#currying（柯里化函数）" class="headerlink" title="currying（柯里化函数）"></a>currying（柯里化函数）</h5><p>currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p><p>假设我们要编写一个计算每个月开销的函数。在每天结束之前，我们都要记录今天花掉了多少钱：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> monthlyCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> cost = <span class="keyword">function</span>(<span class="params">money</span>)&#123;</span><br><span class="line">    monthlyCost += money;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">cost</span>(<span class="number">100</span>);            <span class="comment">// 第一天开销</span></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">200</span>);            <span class="comment">// 第二天开销</span></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">300</span>);            <span class="comment">// 第三天开销</span></span><br><span class="line"><span class="comment">//cost(700);          // 第三十天开销</span></span><br><span class="line"><span class="title function_">alert</span>(monthlyCost);   <span class="comment">// 600</span></span><br></pre></td></tr></table></figure><p>每天结束后我们都会记录并计算到今天为止花掉的钱。但我们其实并不太关心每天花掉了多少钱，而只想知道月底的时候会花掉多少钱。也就是说，实际上只需要在月底计算一次。</p><p>如果在每个月前29天，我们都只是保存好当天的开销，直到第30天才进行求值计算，这样就达到了我们的要求。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个函数fn作为参数，返回一个新函数（会收集所有传入的参数，并将它们一次性应用到fn函数上</span></span><br><span class="line"><span class="keyword">var</span> currying = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;  </span><br><span class="line">    <span class="comment">// 存储传递给柯里化函数的参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [];        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 如果没有传入参数，就将存储到args中的参数一次性应用到fn函数上</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用fn函数，将args数组中的所有参数传递给fn</span></span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果传递了参数则将参数增加到args中</span></span><br><span class="line">            [].<span class="property">push</span>.<span class="title function_">apply</span>(args, <span class="variable language_">arguments</span>);  </span><br><span class="line">            <span class="comment">// 返回当前正在执行的函数本身</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cost = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;l = <span class="variable language_">arguments</span>.<span class="property">length</span>; i&lt;l; i++)&#123;</span><br><span class="line">            money += <span class="variable language_">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> cost = <span class="title function_">currying</span>(cost);</span><br><span class="line"></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">100</span>);</span><br><span class="line"><span class="title function_">cost</span>(<span class="number">200</span>);</span><br><span class="line"><span class="title function_">cost</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">cost</span>());</span><br></pre></td></tr></table></figure><p>当调用cost()时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让cost函数返回另外一个函数。只有当我们以不带参数的形式执行cost()时，才利用前面保存的所有参数，真正开始进行求值计算。</p></li><li><h5 id="uncurrying"><a href="#uncurrying" class="headerlink" title="uncurrying"></a>uncurrying</h5><p>在类数组对象arguments借用<code>Array.prototype</code>的方法之前，先把<code>Array.prototype.push.call</code>这句代码转换为一个通用的push函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">uncurrying</span>();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">push</span>(<span class="variable language_">arguments</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);   <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>通过uncurrying的方式，<code>Array.prototype.push.call</code>变成了一个通用的push函数。这样一来。push函数的作用就跟<code>Array.prototype.push</code>一样了，同样不仅仅局限于只能操作array对象。</p></li><li><h5 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h5><p>函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合理，否则我们一般不会遇到跟性能相关的问题。但是在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。</p><ol><li><p>函数被频繁调用的场景</p><ul><li><p>window.onresize事件</p></li><li><p>mousemove事件</p></li><li><p>上传进度</p></li></ul></li><li><p>函数节流的原理</p><p>上面提到的三个场景，发现他们面临的共同问题是函数被触发的频率太高。通过使用定时器来控制函数的频率。</p></li></ol></li><li><h5 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h5><p>某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严重影响页面性能。处理大量数据或高频率事件时，通过将任务拆分成多个小块来提高性能和响应速度的技术，确保在执行复杂的操作时不会阻塞浏览器UI线程。</p><p><strong>比如把1秒钟创建1000个节点，改为每隔200毫秒创建8个节点。</strong></p></li><li><h5 id="惰性加载函数"><a href="#惰性加载函数" class="headerlink" title="惰性加载函数"></a>惰性加载函数</h5><p>函数执行的分支只会在函数第一次调用才执行。</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、闭包&quot;&gt;&lt;a href=&quot;#一、闭包&quot; class=&quot;headerlink&quot; title=&quot;一、闭包&quot;&gt;&lt;/a&gt;一、闭包&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;变量的作用域&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>this、call和apply</title>
    <link href="http://cychenhaibin.github.io/2024/08/31/this%E3%80%81call%E5%92%8Capply/"/>
    <id>http://cychenhaibin.github.io/2024/08/31/this%E3%80%81call%E5%92%8Capply/</id>
    <published>2024-08-30T16:56:47.000Z</published>
    <updated>2024-08-30T16:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h3><p>this的四种绑定方式：<strong>隐式绑定</strong>、<strong>显式绑定</strong>、<strong>window绑定</strong>、<strong>new绑定</strong></p><p><strong>隐式绑定</strong>：使用对象来调用其内部的一个方法，该方法的this是指向对象本身的，this永远指向最后调用它的那个对象。</p><p><strong>显式绑定</strong>：通过call来设置函数执行上下文的this指向。</p><p><strong>window绑定</strong>：在ES5严格模式中，JavaScript不会默认this指向window对象，而会正确地把this保持为underfined。</p><p><strong>new绑定</strong>：用new调用函数时，JavaScript解释器都会在底层创建一个全新地对象并把这个对象当做this</p><p>改变this指向：</p><ul><li><p>使用ES6箭头函数</p></li><li><p>在函数内部使用_this &#x3D; this</p></li><li><p>使用apply、call、bind</p></li><li><p>new一个实例化对象</p></li></ul><ol><li><h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><ol><li><h5 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h5><p>当函数作为对象地方法被调用时，this指向该对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">getA</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span> === obj);     <span class="comment">// true</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">a</span>);           <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getA</span>();</span><br></pre></td></tr></table></figure></li><li><h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>作为普通函数调用，this指向全局对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;globalName&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = myObject.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>());</span><br></pre></td></tr></table></figure><p><strong>箭头函数注意：</strong></p><ol><li><p>函数体内this就是定义时所的对象，而非调用时的所在对象，和普通函数相反</p></li><li><p>箭头函数无法用做构造器，即不能使用new调用</p></li><li><p>不能使用arguments对象，不存在</p></li><li><p>不可以使用yield命令，即无法用做Generator命令</p></li></ol></li><li><h5 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h5><p>JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造函数看起来更像一个类。</p><p>除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一摸一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总是返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。</p></li><li><h5 id="Function-prototype-call-或-Function-prototype-apply调用"><a href="#Function-prototype-call-或-Function-prototype-apply调用" class="headerlink" title="Function.prototype.call 或 Function.prototype.apply调用"></a><code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>调用</h5><p>跟普通函数相比，用 <code>Function.prototype.call</code> 或 <code>Function.prototype.apply</code>可以动态地改变传入函数地this。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;sven&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;anne&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>());             <span class="comment">// sven</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">call</span>(obj2));  <span class="comment">// anne</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="丢失的this"><a href="#丢失的this" class="headerlink" title="丢失的this"></a>丢失的this</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">myName</span>: <span class="string">&#x27;sven&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">myName</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>());    <span class="comment">// sven</span></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName2</span>());       <span class="comment">// underfined</span></span><br></pre></td></tr></table></figure><p>当调用obj.getName时，getName方法是作为obj对象地属性被调用时，此时的this指向obj对象，所以<code>obj.getName()</code>输出sven。</p><p>当另外一个变量getName2来引用 <code>obj.getName</code>，并且调用getName2时，此时时普通函数调用方式，this是指向全局window的，所以程序执行结果是underfined。</p></li></ol><h3 id="二、call-和-apply"><a href="#二、call-和-apply" class="headerlink" title="二、call 和 apply"></a>二、call 和 apply</h3><p>bind是创建一个新对象</p><ul><li><p>call和apply是立即执行，bind则是返回了一个绑定的this的新函数，只有调用了这个新函数才真正的调用了目标函数。</p></li><li><p>bind函数存在多次绑定问题，如果多次绑定this，则以第一次为准</p></li><li><p>bind函数实际上是显式绑定（call、apply）的一个变种，称为硬绑定，ES5中提供了内置的方法 <code>Function。prototype.bind</code></p></li></ul><ol><li><h4 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h4><p>apply接受两个参数，第一个参数指定了函数体内的this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。</p><p>call传入的参数量不固定，跟apply不同的是，第一个参数也是代表函数体内的this指向，从第二个参数往后，每个参数被依次传入函数。</p><p>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。</p><p>但如果是在严格模式下，函数体内的this还是为null</p></li><li><h4 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h4><ol><li><h5 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h5><p>call和apply最常见的用途是改变函数内部的this指向</p><p>在实际开发中，经常会遇到this指向被不经意改变的场景，比如有一个div节点，div节点的onclick事件中的this本来是指向这个div的：嵌套中的this不会从外层函数中继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);      <span class="comment">// div1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如该事件函数中有一个内部函数func，在事件内部调用func函数时，func函数体内的this就指向window，而不是我们预期的div：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);      <span class="comment">// div1</span></span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);  <span class="comment">// underfined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们用call来修正func函数内的this，使其依然指向div：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    func.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a><code>Function.prototype.bind</code></h5><p>大部分高级浏览器都实现了内置的 <code>Function.prototype.bind</code>，用来指定函数内部的this指向</p></li><li><h5 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h5><p>我们知道，杜鹃既不会筑巢，也不会孵椆，而是把自己的蛋寄托给云雀等其他鸟类，让它们代为孵化和养育。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5></li></ol><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、this&quot;&gt;&lt;a href=&quot;#一、this&quot; class=&quot;headerlink&quot; title=&quot;一、this&quot;&gt;&lt;/a&gt;一、this&lt;/h3&gt;&lt;p&gt;this的四种绑定方式：&lt;strong&gt;隐式绑定&lt;/strong&gt;、&lt;strong&gt;显式绑定&lt;/strong</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的JavaScript</title>
    <link href="http://cychenhaibin.github.io/2024/08/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84JavaScript/"/>
    <id>http://cychenhaibin.github.io/2024/08/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84JavaScript/</id>
    <published>2024-08-30T07:38:47.000Z</published>
    <updated>2024-08-30T11:34:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>看本文之前需要有JavaScript的基础知识</p><hr><p>JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承，也没有在语言层面提供对抽象类和接口的支持</p><h3 id="一、动态类型语言和鸭子模型"><a href="#一、动态类型语言和鸭子模型" class="headerlink" title="一、动态类型语言和鸭子模型"></a>一、动态类型语言和鸭子模型</h3><p>编程语言按照数据类型大体可分为两类：<strong>静态类型语言</strong>、<strong>动态类型语言</strong></p><p>静态类型语言在编译时便已经确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值后，才会具有某种类型。</p><ol><li><p>静态语言</p><ul><li><p>优点：</p><p>在编译时就能发现类型不匹配的错误，如果在程序中明确规定了数据类型，编译器还可以针对这些信息对程序进行一些优化的工作，提高程序执行速度</p></li><li><p>缺点：</p><p>迫使程序员按照锲约来编写程序，类型的声明会增加更多代码</p></li></ul></li><li><p>动态语言</p><ul><li><p>优点：</p><p>编写的代码数量少，更加简洁</p></li><li><p>缺点：</p><p>无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误</p></li></ul></li></ol><p>在JavaScript中，当我们对一个变量赋值时，虽然不需要考虑他的类型，因此，<strong>JavaScript是一门典型的动态类型语言。</strong></p><p>这一切都建立在鸭子类型的概念上，鸭子类型的通俗说法是：”如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。”</p><p>我们可以通过一个小故事来更深刻的了解鸭子类型：</p><blockquote><p>​从前在JavaScript的王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子叫声，于是国王召集大臣，要组建一个1000只鸭子组成的合唱团。大臣们找遍了全国，终于找到了999只鸭子，但始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫声跟鸭子一摸一样，于是这只鸡就成为了合唱团的最后一员。</p></blockquote><p>这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要，鸭子类型指导我们只关注对象的行为，而不关注对象本身。</p><h3 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a>二、多态</h3><p>多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果，换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。</p><p>从字面意思理解多态不太容易，下面我们来举例说明一下。</p><blockquote><p>主人家里养了两只动物，分别是一只鸡和一只鸭，当主人向他们发出”叫”的命令时，鸭会”嘎嘎嘎”地叫，而鸡会”咯咯咯”地叫。这两只动物都会以自己的方式来发出叫声。它们同样”都是动物，并且可以发出叫声”，但根据主人的指令，它们会各自发出不同的叫声。</p></blockquote><ol><li><h4 id="一段”多态”的JavaScript代码"><a href="#一段”多态”的JavaScript代码" class="headerlink" title="一段”多态”的JavaScript代码"></a>一段”多态”的JavaScript代码</h4><p>我们把上面的故事用JavaScript代码实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="keyword">function</span>(<span class="params">animal</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> <span class="title class_">Duck</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;嘎嘎嘎&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> <span class="title class_">Chicken</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;咯咯咯&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Duck</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Chicken</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Duck</span>());</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Chicken</span>());</span><br></pre></td></tr></table></figure><p>这段代码确实体现了”多态性”，当我们分别向鸭和鸡发出”叫唤”的消息时，它们根据此消息做出了各自不同的反应，但是这样的”多态性”是无法令人满意的，如果后来增加一只动物，此时我们必须要改动<code>makeSound</code>函数，修改代码总是危险的，当动物的种类越来越多时，<code>makeSound</code>有可能变成一个巨大的函数。</p><p>多态背后的思想是将”做什么”和”谁去做以及怎样做”分离开来，也就是将”不变的事物”与”可能改变的事物”分离开来。在这个故事中，动物会叫，这个是不变的，但是不同类型的动物具体怎么叫是可变的，把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来可生长的，也是符合开放-封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。</p></li><li><h4 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h4><p>下面是改写后的代码，首先我们把不变的部分隔离出来，那就是所有的动物都会发出叫声：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="keyword">function</span>(<span class="params">animal</span>)&#123;</span><br><span class="line">    animal.<span class="title function_">sound</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把可变的部分各自封装起来，我们刚才谈到的多态性实际上是对象的多态性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Duck</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Duck</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sound</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;嘎嘎嘎&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Chicken</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Chicken</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sound</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;咯咯咯&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Duck</span>());</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="keyword">new</span> <span class="title class_">Chicken</span>());</span><br></pre></td></tr></table></figure></li><li><h4 id="检查类型和多态"><a href="#检查类型和多态" class="headerlink" title="检查类型和多态"></a>检查类型和多态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘎嘎嘎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chicken</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咯咯咯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalSound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">(Duck duck)</span>&#123;    <span class="comment">// (1)</span></span><br><span class="line">        duck.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">AnimalSound</span> <span class="variable">animalSound</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalSound</span>();</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">duck</span>();</span><br><span class="line">        animalSound.makeSound(duck);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经顺利让鸭子可以发出叫声，但如果现在想要鸡也叫起来，我们发现这是一件不可能实现的事情，因为(1)处<code>AnimalSound</code>类的<code>makeSound</code>方法，被我们规定为只能接受Duck类型的参数。</p><p>某些时候，在享受静态语言类型检查带来安全性的同时，我们亦会感觉被束缚了手脚。</p><p>为了解决这一问题，静态类型的面向对象语言通常被设计为可以<strong>向上转型</strong>：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。就像我们描述天上的一只麻雀或者一只喜鹊，通常可以说”一只麻雀在飞”或者”一只喜鹊在飞”。但如果想忽视他们的具体类型，那么也可以说”一只鸟在飞”。</p><p>同理，当Duck对象和Chicken对象的类型都被隐藏在超类型的Animal身后，Duck对象和Chicken对象就能被交换使用，这是让对象表现出多态性的必经之路，而多态性的表现正是实现众多设计模式的目标。</p></li><li><h4 id="使用继承得到多态效果"><a href="#使用继承得到多态效果" class="headerlink" title="使用继承得到多态效果"></a>使用继承得到多态效果</h4><p>使用继承来得到多态效果，是让对象表现出多态性的最常用手段。</p><p>我们先创建一个Animal抽象类，再分别让Duck和Chicken都继承自Animal抽象类，下面代码中(1)处和(2)处的赋值语句显然是成立的，因为鸭子和鸡也是动物</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;  <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chicken</span> extend Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;咯咯咯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> extend Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘎嘎嘎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();       <span class="comment">// (1)</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">Chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>(); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>现在剩下的就是让<code>AnimalSound</code>类的<code>makeSound</code>方法接受Animal类型的参数，而不是具体的Duck类型或者Chicken类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalSound</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">AnimalSound</span> <span class="variable">animalSound</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalSound</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">Chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chicken</span>();</span><br><span class="line">        animal.makeSound(duck);</span><br><span class="line">        animal.makeSound(chicken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="JavaScript的多态"><a href="#JavaScript的多态" class="headerlink" title="JavaScript的多态"></a>JavaScript的多态</h4><p>在java中可以通过向上转型来实现，而JavaScript的变量类型在运行期是可变的，一个JavaScript对象，既可以表示Duck类型的对象，又可以表示Chicken类型的对象，这意味着JavaScript对象的多态性是与生俱来的。</p><p>在JavaScript中，并不需要向上转型之类的技术来取得多态的效果</p></li><li><h4 id="多态在面向对象程序设计中的作用"><a href="#多态在面向对象程序设计中的作用" class="headerlink" title="多态在面向对象程序设计中的作用"></a>多态在面向对象程序设计中的作用</h4><p>Martin Fowler在《重构：改善既有代码的设计》里写道：</p><blockquote><p>多态的最根本好处在于，你不必再向对象询问”你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p></blockquote><p>Martin Fowler的话可以用下面这个例子很好的诠释：</p><blockquote><p>在电影的拍摄现场，当导演喊出”action”时，主角开始背台词，照明师负责打灯，后面的群众演员假装中枪倒地，道具师往镜头前撒上雪花。在得到同一消息时，每个对象都知道自己应该做什么。如果不利于对象的多态性，而是用面向对象的方式来编写这段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人面前，确认它们的职业分工（类型），然后告诉它们要做什么。如果映射到程序中，那么程序中将充斥着条件分支语句。</p></blockquote><p><strong>将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象的程序设计</strong></p></li></ol><p>​</p><h3 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h3><p><strong>封装的目的是将信息隐藏</strong></p><ol><li><h4 id="封装数据"><a href="#封装数据" class="headerlink" title="封装数据"></a>封装数据</h4><p>只能依赖变量的作用域来实现封装特性，而且只能模拟出public和private这两种封装性。</p><p>除了ES6中提供的let之外，一般我们通过函数来创建作用域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _name = <span class="string">&#x27;seven&#x27;</span>;        <span class="comment">// 创建private变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;    <span class="comment">// 公开public方法</span></span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在ES6中，还可以通过Symbol创建私有属性。</p></li><li><h4 id="封装实现"><a href="#封装实现" class="headerlink" title="封装实现"></a>封装实现</h4><p>封装实现细节的例子非常多，拿迭代器来说明，迭代器的作用是在一个不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。我们编写了一个each函数，它的作用就是遍历一个聚合对象，使用这个each函数的人不用关心它的内部代码是怎样实现的，只要它提供的功能正确便可以。即使each函数修改了内部源码，只要对外的接口或者调用方式没有变化，用户就不用关心它内部实现的改变。</p></li><li><h4 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h4><p>封装类型是静态类型语言中一种重要的封装方式，一般而言，封装类型是通过抽象类和接口来进行的。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为，在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。</p></li></ol><h3 id="四、原型模式基于原型继承的JavaScript对象系统"><a href="#四、原型模式基于原型继承的JavaScript对象系统" class="headerlink" title="四、原型模式基于原型继承的JavaScript对象系统"></a>四、原型模式基于原型继承的JavaScript对象系统</h3><p>原型模式不单是一种设计模式，也称为一种编程泛型。</p><ol><li><h4 id="使用克隆的原型模式"><a href="#使用克隆的原型模式" class="headerlink" title="使用克隆的原型模式"></a>使用克隆的原型模式</h4><p>原型模式是用于创建对象的一种模式，如果我们要创建一个对象，一种方法是先指定它的类型，然后通过类来创建对象。原型模式选择了另一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一摸一样的对象。</p><p>原型模式的实现关键，是语言本身是否提供了clone方法。ES5提供了 <code>Object.create</code> 方法，可以用来克隆对象。</p></li><li><h4 id="克隆是创建对象的手段"><a href="#克隆是创建对象的手段" class="headerlink" title="克隆是创建对象的手段"></a>克隆是创建对象的手段</h4><p>原型模式提供了另一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。这就像一个仙女要送给三岁小女孩生日礼物，虽然小女孩可能还不知道飞机或者船怎么说，但她可以指着商店橱柜里的飞机模型说”我要这个”。</p><p>当然在JavaScript这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。从设计模式的角度来讲，原型模式的意义比不算大。但JavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式搭建的，在这里称之为原型编程范型也许更合适。</p></li><li><h4 id="体验Io语言"><a href="#体验Io语言" class="headerlink" title="体验Io语言"></a>体验Io语言</h4><p>在JavaScript语言中不存在类的概念，对象也并非从类中创建出来的，所有的JavaScript对象都是从某个对象上克隆而来的。</p><p>JavaScript基于原型的面向对象系统参考了Self语言和Smalltalk语言，为了搞清JavaScript中的原型，我们本该寻根溯源这两门语言，但由于这两门语言距离现在是在太遥远，我们转而了解一下另外一种轻巧又基于原型的语言——Io语言。</p><p>作为一门基于原型的语言，Io中同样没有类的概念，每一个对象都是基于另外一个对象的克隆。在Io中，根对象名为Object。</p></li><li><h4 id="原型编程范型的一些规则"><a href="#原型编程范型的一些规则" class="headerlink" title="原型编程范型的一些规则"></a>原型编程范型的一些规则</h4><p>如果A对象是从B对象克隆而来，那么B对象就是A对象的原型。每个对象都有原型，这个原型还有属于自己的原型，最终形成了原型链，原型链最顶端是null。基于原型链的委托机制就是原型继承的本质</p><p>为什么设计原型：继承，让对象的属性和方法共享。</p><p>原型编程中的一个重要特征：当对象无法响应某个请求时，会把该请求对象委托给它自己的原型。</p><p>原型编程规范至少包括以下基本准则</p><ul><li><p>所有的数据都是对象</p></li><li><p>要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它</p></li><li><p>对象会记住它的原型</p></li><li><p>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</p></li></ul></li><li><h4 id="JavaScript中的原型继承"><a href="#JavaScript中的原型继承" class="headerlink" title="JavaScript中的原型继承"></a>JavaScript中的原型继承</h4><ol><li><h5 id="所有数据都是对象"><a href="#所有数据都是对象" class="headerlink" title="所有数据都是对象"></a>所有数据都是对象</h5><p>按照JavaScript设计者的本意，除了underfined之外，一切都应是对象，事实上，JavaScript中的根对象是 <code>Object.prototype</code> 对象。<code>Object.prototype</code>对象是一个空对象。我们在遇到的每个对象，实际上都是从 <code>Object.prototype</code> 对象克隆而来的，<code>Object.prototype</code> 对象就是它们的原型。</p></li><li><h5 id="要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它"><a href="#要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它" class="headerlink" title="要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它"></a>要得到一个对象，不是通过实例化，而是找到一个对象作为原型并克隆它</h5><p>在JavaScript语言里，我们并不关心克隆的细节，因为这是引擎内部负责实现的，我们所需要做的只是显式地调用 <code>var obj1 = new Object()</code> 或者 <code>var obj2 = &#123;&#125;</code> 。此时，引擎内部会从<code>Object.prototype</code> 上面克隆一个对象出来，我们最终得到地就是这个对象。</p><p>JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用new运算符来调用函数时，此时的函数就是一个构造器。用new运算符来创建对象的过程，实际上也只是先克隆 <code>Object.prototype</code> 对象，再进行一些其他额外操作的过程。</p><p><strong>JavaScript是通过克隆<code>Object.prototype</code>来得到新的对象，但实际上并不是每次都真正克隆了一个新的对象</strong></p></li><li><h5 id="对象会记住它的原型"><a href="#对象会记住它的原型" class="headerlink" title="对象会记住它的原型"></a>对象会记住它的原型</h5><p>JavaScript给对象提供了一个名为<code>__proto__</code>的隐藏属性，某个对象的<code>__proto__</code>属性会默认指向它的构造器的原型对象，即 <code>&#123;Constructor&#125;.prototype</code>。在一些浏览器中，<code>__proto__</code>被公开出来。</p><p>实际上，<code>__proto__</code>就是对象跟”对象构造器的原型”联系起来的纽带。因为对象要通过<code>__proto__</code>属性来记住它的构造对象的原型。</p></li><li><h5 id="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"><a href="#如果对象无法响应某个请求，它会把这个请求委托给它自己的原型" class="headerlink" title="如果对象无法响应某个请求，它会把这个请求委托给它自己的原型"></a>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</h5><p>这条规则即是原型继承的精髓所在。JavaScript的克隆跟Io语言还是有点不一样，Io中每个对象都可以作为原型被克隆，当Animal对象克隆自Object对象，Dog对象又克隆自Animal对象时，就形成了一条天然的原型链。</p><p>而在JavaScript中，每个对象都是从 <code>Object.prototype</code> 对象克隆而来的，如果是这样的话，我们只能得到单一的继承关系，即每个对象都继承自  <code>Object.prototype</code> 对象，这样的对象系统显然是受限的。</p><p>实际上，虽然JavaScript的对象最初都是由 <code>Object.prototype</code> 对象克隆而来的，但对象构造器的原型并不仅限于 <code>Object.prototype</code> 上，而是可以动态指向其他对象。这样一来，当对象a需要借用对象b的能力时，可以有选择性的把对象a的构造器的原型指向对象b，从而达到继承的效果。</p><p>下面的代码是我们最常用的原型继承方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>);  <span class="comment">// seven</span></span><br></pre></td></tr></table></figure><p>当我们期望得到一个”类”继承自另外一个”类”的效果时：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;seven&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>)   <span class="comment">// seven</span></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>JavaScript中一切引用类型都是对象，对象就是属性的集合</li><li>Array类型、Function类型、Object类型、Date类型、RegExp类型都是引用类型</li><li>原型存在的意义就是组成原型链</li><li>原型链存在的意义就是继承</li><li>继承存在的意义就是属性共享</li><li>构造函数用来创建对象，同一构造函数创建的对象，其原型相同</li><li>对象有 <code>__proto__</code> 属性，函数有 <code>__proto__</code> 属性，数组也有 <code>__proto__</code> 属性，只要是引用类型，就有 <code>__proto__</code> 属性，指向其原型</li><li>只有函数有 <code>prototype</code> 属性，指向new操作符加调用该函数创建的对象实例的原型对象</li><li>instanceof运算符用于检查右边构造函数的 <code>prototype</code> 属性是否出现在左边对象的原型链中的任何位置，其他它则表示的是一种原型链的继承关系</li><li>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看本文之前需要有JavaScript的基础知识&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承，也没有在语言层面提供对抽象类和接口的支持&lt;/p&gt;
&lt;h3 id=&quot;一、动态类型语言和鸭子模型&quot;</summary>
      
    
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/categories/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="JavaScript的设计模式和开发实践" scheme="http://cychenhaibin.github.io/tags/JavaScript%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>算法:滑动窗口</title>
    <link href="http://cychenhaibin.github.io/2024/08/23/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://cychenhaibin.github.io/2024/08/23/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2024-08-23T14:22:47.000Z</published>
    <updated>2024-10-13T05:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、无重复字符的最长子集"><a href="#一、无重复字符的最长子集" class="headerlink" title="一、无重复字符的最长子集"></a>一、无重复字符的最长子集</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例1:</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 2:</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 3:</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> charIndexMap = &#123;&#125;; <span class="comment">// 存储字符及其索引的映射</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 初始化子串的起始索引</span></span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>; <span class="comment">// 初始化最长不重复子串的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++) &#123; <span class="comment">// end指针遍历整个字符串</span></span><br><span class="line">        <span class="keyword">const</span> currentChar = s[end]; <span class="comment">// 当前字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前字符已经在charIndexMap中，并且索引不小于start</span></span><br><span class="line">        <span class="keyword">if</span> (charIndexMap.<span class="title function_">hasOwnProperty</span>(currentChar) &amp;&amp; charIndexMap[currentChar] &gt;= start) &#123;</span><br><span class="line">            <span class="comment">// 移动start到重复字符索引的下一个位置</span></span><br><span class="line">            start = charIndexMap[currentChar] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新当前字符在charIndexMap中的索引</span></span><br><span class="line">        charIndexMap[currentChar] = end;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最长不重复子串的长度</span></span><br><span class="line">        maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLength; <span class="comment">// 返回最长不重复子串的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、无重复字符的最长子集&quot;&gt;&lt;a href=&quot;#一、无重复字符的最长子集&quot; class=&quot;headerlink&quot; title=&quot;一、无重复字符的最长子集&quot;&gt;&lt;/a&gt;一、无重复字符的最长子集&lt;/h3&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中</summary>
      
    
    
    
    <category term="算法" scheme="http://cychenhaibin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://cychenhaibin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序</title>
    <link href="http://cychenhaibin.github.io/2024/08/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://cychenhaibin.github.io/2024/08/23/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-08-23T04:47:47.000Z</published>
    <updated>2024-08-23T06:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文件已定稿，最后修改时间 20240823 12:47</p><hr><h3 id="一、wxml组件和wxss适配"><a href="#一、wxml组件和wxss适配" class="headerlink" title="一、wxml组件和wxss适配"></a>一、wxml组件和wxss适配</h3><ol><li><h4 id="wxml-—-div"><a href="#wxml-—-div" class="headerlink" title=".wxml —- div"></a>.wxml —- div</h4><ol><li>view — div</li><li>text文字：可以长按选中</li><li>image — img</li><li>button</li><li>form</li><li>input</li><li>label</li></ol></li><li><h4 id="wxss-—-css"><a href="#wxss-—-css" class="headerlink" title=".wxss —- .css"></a>.wxss —- .css</h4><p>单位：rpx</p><p>布局：弹性盒布局</p></li></ol><h3 id="二、JS数据-列表-条件渲染-事件"><a href="#二、JS数据-列表-条件渲染-事件" class="headerlink" title="二、JS数据-列表-条件渲染-事件"></a>二、JS数据-列表-条件渲染-事件</h3><ol><li><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">str</span>:<span class="string">&quot;这是小程序&quot;</span></span><br><span class="line">    <span class="attr">city</span>: [</span><br><span class="line">        <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">        <span class="string">&quot;上海&quot;</span>,</span><br><span class="line">        <span class="string">&quot;四川&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&#x27;&#123;&#123;city&#125;&#125;&#x27;</span> <span class="attr">wx:key</span>=<span class="string">&#x27;&#123;&#123;index&#125;&#125;&#x27;</span>&gt;</span></span><br><span class="line">&#123;&#123; item &#125;&#125;</span><br><span class="line">    &#123;&#123; index &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&#x27;&#123;city.length &gt; 0&#125;&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:for</span>=<span class="string">&#x27;&#123;&#123;city&#125;&#125;&#x27;</span>&gt;</span></span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">暂无数据...</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>bind：不会阻止冒泡</p><p>catch：会阻止冒泡</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">&#x27;btn&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="修改data中的数据"><a href="#修改data中的数据" class="headerlink" title="修改data中的数据"></a>修改data中的数据</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">btn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">str</span>:<span class="string">&#x27;我已经修改你了&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、请求接口和封装url"><a href="#三、请求接口和封装url" class="headerlink" title="三、请求接口和封装url"></a>三、请求接口和封装url</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 闭包要改变this指向</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">That</span> = <span class="variable language_">this</span>;</span><br><span class="line">    wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;https://ehcto.com/data.json&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">            <span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">            <span class="attr">userName</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="title class_">That</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">cityName</span>: res.<span class="property">data</span>.<span class="property">city</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、页面跳转-路径传值"><a href="#四、页面跳转-路径传值" class="headerlink" title="四、页面跳转-路径传值"></a>四、页面跳转-路径传值</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- list.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">这是list页面</span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:for</span>=<span class="string">&#x27;&#123;&#123;cityList&#125;&#125;&#x27;</span>&gt;</span></span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- list.<span class="property">js</span> --&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">cityList</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params">option</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = option.<span class="property">cityList</span>.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">cityList</span>: arr</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">bindtap</span>=<span class="string">&#x27;toLogs&#x27;</span>&gt;</span> &#123;&#123;cityName&#125;&#125; <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- index.<span class="property">js</span> --&gt;</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">cityName</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">toLogs</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">That</span> = <span class="variable language_">this</span>;</span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;../list/list?cityList=&quot;</span>+<span class="title class_">That</span>.<span class="property">data</span>.<span class="property">cityList</span>+<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">    onLoad: function()&#123;</span></span><br><span class="line"><span class="string">    // 闭包要改变this指向</span></span><br><span class="line"><span class="string">    let That = this;</span></span><br><span class="line"><span class="string">    wx.request(&#123;</span></span><br><span class="line"><span class="string">        url: &#x27;https://ehcto.com/data.json&#x27;,</span></span><br><span class="line"><span class="string">        data:&#123;</span></span><br><span class="line"><span class="string">            key:&#x27;123&#x27;,</span></span><br><span class="line"><span class="string">            userName:&quot;</span>张三<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        success(res)&#123;</span></span><br><span class="line"><span class="string">            That.setData(&#123;</span></span><br><span class="line"><span class="string">                cityName: res.data.city,</span></span><br><span class="line"><span class="string">                    cityList: res.data.hotList</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="五、template的使用"><a href="#五、template的使用" class="headerlink" title="五、template的使用"></a>五、template的使用</h3><ol><li><h4 id="template目录结构"><a href="#template目录结构" class="headerlink" title="template目录结构"></a>template目录结构</h4><ul><li>pages<ul><li>templates<ul><li>swiper-template<ul><li>swiper-template.wxml</li><li>swiper-template.wxss</li><li>swiper-template.js</li></ul></li><li>tabs-template</li></ul></li></ul></li></ul></li><li><h4 id="template的使用"><a href="#template的使用" class="headerlink" title="template的使用"></a>template的使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&#x27;swiper&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="页面引入"><a href="#页面引入" class="headerlink" title="页面引入"></a>页面引入</h4><p>wxml：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">&#x27;swiper&#x27;</span> <span class="attr">data</span>=<span class="string">&#x27;&#123;&#123;数据1, 数据2...&#125;&#125;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>wxss:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;/pages/templates/swiper-template/swiper-tempalte.wxss&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文件已定稿，最后修改时间 20240823 12:47&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、wxml组件和wxss适配&quot;&gt;&lt;a href=&quot;#一、wxml组件和wxss适配&quot; class=&quot;headerlink&quot; title=&quot;一、wxml组件和wxss适配&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Front-end" scheme="http://cychenhaibin.github.io/categories/Front-end/"/>
    
    
    <category term="Front-end" scheme="http://cychenhaibin.github.io/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://cychenhaibin.github.io/2024/08/22/Vue/"/>
    <id>http://cychenhaibin.github.io/2024/08/22/Vue/</id>
    <published>2024-08-22T08:27:47.000Z</published>
    <updated>2024-08-22T08:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文件已定稿，最后修改时间 20240822 16:27</p><hr><h2 id="一、Vue脚手架"><a href="#一、Vue脚手架" class="headerlink" title="一、Vue脚手架"></a>一、Vue脚手架</h2><p>vue-cli：框架  —-&gt; 脚手架</p><ol><li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><p><code>npm install -g @vue/cli</code></p></li><li><h4 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h4><p><code>vue -V </code></p></li><li><h4 id="安装老版本vue-cli"><a href="#安装老版本vue-cli" class="headerlink" title="安装老版本vue-cli"></a>安装老版本vue-cli</h4><p><code>npm install -g vue-cli</code></p></li><li><h4 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h4><p><code>npm install -g vue-cli@版本号</code></p></li><li><h4 id="查看全部版本"><a href="#查看全部版本" class="headerlink" title="查看全部版本"></a>查看全部版本</h4><p><code>npm view vue-cli versions --json</code></p></li><li><h4 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h4><p><code>vue init webpack 项目名称</code></p></li></ol></li><li><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><code>vue create 项目名称</code></p></li><li><h3 id="vue文件"><a href="#vue文件" class="headerlink" title=".vue文件"></a>.vue文件</h3><p>三大部分：</p><p>template：盒子布局的<br>script：js逻辑<br>style：css样式</p></li><li><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><p>只要运行vue项目，main.js就会执行</p><p>index.html —&gt; main.js —&gt; App.vue</p></li><li><h4 id="vue是”数据”驱动"><a href="#vue是”数据”驱动" class="headerlink" title="vue是”数据”驱动"></a>vue是”数据”驱动</h4><p>定义数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            str:&#x27;123&#x27;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; str &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="二、Vue指令"><a href="#二、Vue指令" class="headerlink" title="二、Vue指令"></a>二、Vue指令</h2><ol><li><h4 id="指令（v-xxx）"><a href="#指令（v-xxx）" class="headerlink" title="指令（v-xxx）"></a>指令（v-xxx）</h4><p><code>v-bind</code>：单向绑定</p><p><code>v-bind:属性名=&#39;数据&#39;</code></p><p>简写：</p><p><code>:属性名=&#39;数据&#39;</code></p><p><strong>指令不需要加入{{}}</strong></p></li><li><h4 id="列表渲染和条件渲染"><a href="#列表渲染和条件渲染" class="headerlink" title="列表渲染和条件渲染"></a>列表渲染和条件渲染</h4><ol><li><p>列表渲染（v-for）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in arr&#x27; :key=&#x27;index&#x27;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">                &#123;&#123; index &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>条件渲染（v-if）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-if=&#x27;types==&quot;张三&quot;&#x27;&gt;</span><br><span class="line">    11111</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else-if=&#x27;types==&quot;李四&quot;&#x27;&gt;</span><br><span class="line">    22222</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;</span><br><span class="line">    33333</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件添加</p><p><code>&lt;h1 v-on:click=&#39;方法&#39;&gt;&lt;/h1&gt;</code></p><p>简写：</p><p><code>&lt;h1 @click=&#39;方法&#39;&gt;&lt;/h1&gt;</code></p><p>注意：vue-cli中的方法要添加在methods</p></li></ol><p><strong>【面试题】v-if 和 v-for 的优先级</strong></p><ul><li><p>v-for比v-if高</p></li><li><p>正常的使用上来说</p><ul><li><p>v-if</p></li><li><p>​v-for</p></li></ul></li></ul></li><li><h4 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h4><ol><li><p><code>v-if</code></p><p>创建与删除的操作</p></li><li><p><code>v-show</code></p><p>显示和隐藏（<code>display:none;、display:block;</code>）</p></li></ol><p><strong>【面试题】两者区别</strong></p><ul><li><p>v-if 是创建和删除节点、v-show 是隐藏和显示节点</p></li><li><p>如果用户频繁切换的状态应该用v-show</p></li><li><p>如果一刷新进入页面的状态v-show的性能差一点</p></li></ul></li><li><h4 id="v-model的使用"><a href="#v-model的使用" class="headerlink" title="v-model的使用"></a>v-model的使用</h4><ul><li><p><code>v-bind</code>：单向绑定</p></li><li><p><code>v-model</code>：双向绑定</p></li></ul></li><li><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>模板语法内如果添加特别复杂的逻辑，就让模板表达式比较重而且难以维护，对于任何复杂逻辑，都应当使用计算属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str:&#x27;123&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">     changeStr()&#123;</span><br><span class="line">       return this.str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>计算属性（computed）是基于他们的响应式依赖进行缓存的</strong></p><ul><li><strong>【面试题】computed 和 methods 区别</strong><ul><li>computed是有缓存的（如果计算的属性没有发生变化，则执行缓存数据）</li><li>methods是没有缓存的（也就是template只要render了 [或者重复render] 就会执行methods内所有的方法）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;!-- &#123;&#123;  changeStr  &#125;&#125; --&gt;</span><br><span class="line">      单价：</span><br><span class="line">      &lt;input type=&quot;&quot; name=&quot;&quot; v-model=&#x27;price&#x27;&gt; </span><br><span class="line">      数量：</span><br><span class="line">      &lt;input type=&quot;&quot; name=&quot;&quot; v-model=&#x27;num&#x27;&gt; </span><br><span class="line">      总价：&#123;&#123;  total  &#125;&#125;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &#123;&#123; str &#125;&#125;</span><br><span class="line">      &lt;button @click=&#x27;btn&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      //str:&#x27;123&#x27;</span><br><span class="line">      price:&#x27;11&#x27;,</span><br><span class="line">      num:2,</span><br><span class="line">      str:&#x27;你好&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    total()&#123;</span><br><span class="line">      console.log(&#x27;computed&#x27;);</span><br><span class="line">      return this.price * this.num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    btn()&#123;</span><br><span class="line">      this.str = &#x27;不好&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    totalConut()&#123;</span><br><span class="line">      console.log( &#x27;methods&#x27; );</span><br><span class="line">      return this.price * this.num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // computed:&#123;</span><br><span class="line">  //   changeStr()&#123;</span><br><span class="line">  //     return this.str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><h4 id="class和style"><a href="#class和style" class="headerlink" title="class和style"></a>class和style</h4><ol><li><h5 id="class"><a href="#class" class="headerlink" title="class"></a>class</h5><ol><li><p>对象的写法</p><p><code>:class=&#39;&#123; class名称:true|false &#125;&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27; :class=&#x27;&#123;active:false&#125;&#x27;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        background:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>用于判断各种赋值的</p><p><code>:class=&#39; currentClass == index ? &quot;active&quot; : &quot;&quot; &#39;</code></p><p>点击某一个加上颜色</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27; </span><br><span class="line">            :class=&#x27; currentClass == index ? &quot;active&quot; : &quot;&quot; &#x27;</span><br><span class="line">            @click=&#x27;btn(index)&#x27;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">            currentClass:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btn(index)&#123;</span><br><span class="line">            this.currentClass = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        background:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>数组的写法</p><p><code>&lt;div :class=&#39;[activeClass]&#39;&gt;&lt;/div&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27; </span><br><span class="line">            :class=&#x27; currentClass == index ? &quot;active&quot; : &quot;&quot; &#x27;</span><br><span class="line">            @click=&#x27;btn(index)&#x27;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">        &lt;div :class=&#x27;[activeClass]&#x27;&gt;</span><br><span class="line">            aaa</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">            currentClass:0,</span><br><span class="line">            activeClass:&quot;active&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btn(index)&#123;</span><br><span class="line">            this.currentClass = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        background:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><h5 id="style"><a href="#style" class="headerlink" title="style"></a>style</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27; </span><br><span class="line">            :class=&#x27; currentClass == index ? &quot;active&quot; : &quot;&quot; &#x27;</span><br><span class="line">            @click=&#x27;btn(index)&#x27;&gt;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">        &lt;div :class=&#x27;[activeClass]&#x27;&gt;</span><br><span class="line">            aaa</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div :style=&#x27;styleClass&#x27;&gt;</span><br><span class="line">            这是style的写法</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],</span><br><span class="line">            currentClass:0,</span><br><span class="line">            activeClass:&quot;active&quot;,</span><br><span class="line">            styleClass:&#123;</span><br><span class="line">            background:&#x27;red&#x27;,</span><br><span class="line">            fontSize:&#x27;50px&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btn(index)&#123;</span><br><span class="line">            this.currentClass = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        background:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="img的src路径问题"><a href="#img的src路径问题" class="headerlink" title="img的src路径问题"></a>img的src路径问题</h4><p><code>img :src</code> 一旦是绑定的数据，那么他会类似于请求的数据了，需要从路径上查找</p><ul><li><p>没有绑定在src目录下找</p><p><code>&lt;img src=&quot;./assets/img/log0.png&quot;&gt;</code></p></li><li><p>绑定了在public目录下找</p><p><code>&lt;img :src=&quot;&quot;&gt;</code></p></li></ul></li><li><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><ol><li><h5 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h5><p><code>v-on:事件名称=&#39;&#39;</code></p><p>简写：</p><p><code>@事件名称=&#39;&#39;</code></p></li><li><h5 id="vue中的事件-—-和dom事件一致"><a href="#vue中的事件-—-和dom事件一致" class="headerlink" title="vue中的事件 —- 和dom事件一致"></a>vue中的事件 —- 和dom事件一致</h5><p>click、mouseover</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;div class=&#x27;main&#x27; @click=&#x27;btn($event,&quot;你好&quot;)&#x27; &gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&#x27;main&#x27; @mouseover=&#x27;overBtn&#x27; @mouseout=&#x27;outBtn&#x27;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input type=&quot;&quot; name=&quot;&quot; @keyup.enter=&#x27;upBtn&#x27;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    btn( e,val )&#123;</span><br><span class="line">      console.log(e,val);</span><br><span class="line">    &#125;,</span><br><span class="line">    overBtn()&#123;</span><br><span class="line">      alert(&#x27;移入&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    outBtn()&#123;</span><br><span class="line">      alert(&#x27;移出&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    upBtn()&#123;</span><br><span class="line">      alert(&#x27;111111&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 500px;</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><h5 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h5><p>.stop、.prevent、.capture、.self、.once、.passive</p><p><code>&lt;input type=&quot;&quot; name=&quot;&quot; @keyup.enter=&#39;upBtn&#39;&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;div class=&#x27;main&#x27; @click=&#x27;btn($event,&quot;你好&quot;)&#x27; &gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&#x27;main&#x27; @mouseover=&#x27;overBtn&#x27; @mouseout=&#x27;outBtn&#x27;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input type=&quot;&quot; name=&quot;&quot; @keyup.enter=&#x27;upBtn&#x27;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&#x27;container&#x27; @click=&#x27;parentNode&#x27;&gt;</span><br><span class="line">        &lt;div class=&#x27;main&#x27; @click.stop=&#x27;childNode&#x27;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    btn( e,val )&#123;</span><br><span class="line">      console.log(e,val);</span><br><span class="line">    &#125;,</span><br><span class="line">    overBtn()&#123;</span><br><span class="line">      alert(&#x27;移入&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    outBtn()&#123;</span><br><span class="line">      alert(&#x27;移出&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    upBtn()&#123;</span><br><span class="line">      alert(&#x27;111111&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    parentNode()&#123;</span><br><span class="line">      alert(&#x27;父&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    childNode()&#123;</span><br><span class="line">      alert(&#x27;子&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 500px;</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="Vue项目做自适应"><a href="#Vue项目做自适应" class="headerlink" title="Vue项目做自适应"></a>Vue项目做自适应</h4><ul><li><p>局部引入（单独某一页面生效）.vue文件中引入</p></li><li><p>在main.js中全局引入   <code>import &#39;./assets/js/flexible.js&#39;</code></p></li></ul></li></ol><h2 id="三、Vue组件"><a href="#三、Vue组件" class="headerlink" title="三、Vue组件"></a>三、Vue组件</h2><ol><li><h4 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h4><p>把较大的网页，进行功能模块的拆分</p><ol><li><h5 id="组件的操作"><a href="#组件的操作" class="headerlink" title="组件的操作"></a>组件的操作</h5><p>组件的首字母要大写</p><p>父组件引入子组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">        &lt;Swiper&gt;&lt;/Swiper&gt;</span><br><span class="line">        &lt;Icons&gt;&lt;/Icons&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &#x27;./components/Header&#x27;</span><br><span class="line">import Swiper from &#x27;./components/Swiper&#x27;</span><br><span class="line">import Icons from &#x27;./components/Icons&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Header,</span><br><span class="line">        Swiper,</span><br><span class="line">        Icons</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="父组件传值给子组件"><a href="#父组件传值给子组件" class="headerlink" title="父组件传值给子组件"></a>父组件传值给子组件</h4><ul><li><p>父组件</p><p><code>&lt;Swiper :xxx=&#39;parentStr&#39;&gt;&lt;/Swiper&gt;</code></p><p>xxx 是一个名称 &#x3D; ‘ 这里是属性值 ‘</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import Swiper from &#x27;./components/Swiper.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">parentStr:&#x27;这是父组件的数据&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">Swiper</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;&#123; xxx &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">props:[&#x27;xxx&#x27;],</span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">export default &#123;</span><br><span class="line">props:&#123;</span><br><span class="line">xxx:String,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="子组件传值给父组件"><a href="#子组件传值给父组件" class="headerlink" title="子组件传值给父组件"></a>子组件传值给父组件</h4><ul><li><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;Child @changeEvent=&#x27;fn&#x27;&gt;&lt;/Child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;./components/Child&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Child</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        fn(val)&#123;</span><br><span class="line">            alert(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        子组件:&#123;&#123; str &#125;&#125;</span><br><span class="line">        &lt;button @click=&#x27;btn&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            str:&#x27;这是子组件的数据&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btn()&#123;</span><br><span class="line">            // changeEvent自定义事件名称</span><br><span class="line">            this.$emit(&#x27;changeEvent&#x27;,this.str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="兄弟组件之间的传值（bus）"><a href="#兄弟组件之间的传值（bus）" class="headerlink" title="兄弟组件之间的传值（bus）"></a>兄弟组件之间的传值（bus）</h4><ul><li><p>bus.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>;</span><br></pre></td></tr></table></figure></li><li><p>A.vue</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        AAA</span><br><span class="line">        &lt;button @click=&#x27;btn&#x27;&gt;这是A的按钮&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &#x27;./bus&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            aStr:&#x27;这是A的数据&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        btn()&#123;</span><br><span class="line">            bus.$emit(&#x27;changeStr&#x27;,this.aStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>B.vue</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        BBB</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &#x27;./bus&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">    computed:&#123;</span><br><span class="line">        bStr()&#123;</span><br><span class="line">            bus.$on(&quot;changeStr&quot;,(res)=&gt;&#123;</span><br><span class="line">                alert(res);</span><br><span class="line">            &#125;)</span><br><span class="line">            return 111;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="scoped以及原理"><a href="#scoped以及原理" class="headerlink" title="scoped以及原理"></a>scoped以及原理</h4><ol><li><p>组件内样式局部化：</p><p><code>&lt;style scoped&gt;&lt;/style&gt;</code></p></li><li><p>原理</p><p>加入了scoped，就会在节点上添加自定义属性 <code>data-v-xxx</code></p><p>css选择器，根据属性选择最终添加样式</p></li></ol></li><li><h4 id="slot使用以及场景"><a href="#slot使用以及场景" class="headerlink" title="slot使用以及场景"></a>slot使用以及场景</h4><p>Header.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;&#123; title &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&#x27;分类&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用场景：</p><p><img src="/../image/Vue/image-20240725160914310.png" alt="image-20240725160914310"></p><p><img src="/../image/Vue/image-20240725160946389.png" alt="image-20240725160946389"></p></li><li><h4 id="Vue插件的使用（swiper插件为例）"><a href="#Vue插件的使用（swiper插件为例）" class="headerlink" title="Vue插件的使用（swiper插件为例）"></a>Vue插件的使用（swiper插件为例）</h4><ol><li><p>下载</p><p><code>npm install vue-awesome-swiper -S</code></p></li><li><p>引入</p><ul><li><p>全局引入在main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueAwesomeSwiper</span> <span class="keyword">from</span> <span class="string">&#x27;vue-awesome-swiper&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/dist/css/swiper.css&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueAwesomeSwiper</span>)</span><br></pre></td></tr></table></figure></li><li><p>局部按需引入：单组件引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/dist/css/swiper.css&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; swiper, swiperSlide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-awesome-swiper&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">swiper,</span><br><span class="line">swiperSlide</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置</p><p>相关文档</p></li></ol></li><li><h4 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h4><ol><li><p>通用（在选择器前面加入）：<code>::v-deep</code></p></li><li><p>stylus：<code>&gt;&gt;&gt;</code></p></li><li><p>sass和less：<code>/deep/</code></p></li></ol></li></ol><h2 id="四、生命周期和接口请求"><a href="#四、生命周期和接口请求" class="headerlink" title="四、生命周期和接口请求"></a>四、生命周期和接口请求</h2><ol><li><h4 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h4><ol><li><p>是什么？</p><p>vue中每一个组件都是独立的，每一个组件都有自己的生命周期，从一个组件创建、数据初始化、挂载、更新、销毁</p></li><li><p>有哪些？</p><p>beforeCreate、created</p><p>beforeMount、mounted</p><p>beforeUpdate、updated</p><p>beforeDestroy、destroyed</p></li><li><p>打开一个组件会执行哪些生命周期</p><p>beforeCreate、created</p><p>beforeMount、mounted</p><p><strong><code>this.$data</code>：组件的data数据 、created时有</strong></p><p><strong><code>this.$el</code>：组件的template节点、mounted时有</strong></p></li></ol></li><li><h4 id="axios和代理配置"><a href="#axios和代理配置" class="headerlink" title="axios和代理配置"></a>axios和代理配置</h4><p>vue项目中axios进行接口的请求</p><ol><li><p>下载</p><p><code>npm install axios -S</code></p></li><li><p>引入</p><p>在main.js中</p><p><code>import axios from &#39;axios&#39;</code></p><p><code>Vue.prototype.axios = axios;</code></p></li><li><p>使用</p><ul><li><p>GET</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27;&gt;</span><br><span class="line">    &#123;&#123; item.name &#125;&#125;</span><br><span class="line">                &lt;img :src=&quot;item.mgurl&quot;&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    components:&#123;</span><br><span class="line">        HelloWorld</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.axios(&#123;</span><br><span class="line">            url:&#x27;xxx&#x27;,</span><br><span class="line">            params:&#123;</span><br><span class="line">                page:1,</span><br><span class="line">                size:3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            this.list = res.data.data</span><br><span class="line">            // console.log(res.data.data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>POST</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27;&gt;</span><br><span class="line">    &#123;&#123; item.name &#125;&#125;</span><br><span class="line">                &lt;img :src=&quot;item.mgurl&quot;&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    components:&#123;</span><br><span class="line">        HelloWorld</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.axios(&#123;</span><br><span class="line">            url:&#x27;xxx&#x27;,</span><br><span class="line">            method:&quot;POST&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                page:1,</span><br><span class="line">                size:3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            this.list = res.data.data</span><br><span class="line">            // console.log(res.data.data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>vue项目在开发阶段设置代理</p><ol><li><p>项目根目录需要新建vue.config.js</p></li><li><p>配置代理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">        <span class="attr">proxy</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// target:&#x27;&lt;url&gt;&#x27;,</span></span><br><span class="line">                <span class="attr">target</span>:<span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">                <span class="attr">changeOrigin</span>:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// /api === http://localhost:3000</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;/api&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>后端</p><ol><li><p>全局安装</p><p><code>npm install express-generator -g</code></p></li><li><p>创建项目</p><p><code>express --view=ejs 项目名称</code></p></li><li><p>安装依赖</p><p><code>cd server</code></p><p><code>npm install</code></p><p><code>npm start</code></p></li><li><p>后端接口</p><p>server &#x2F; routes &#x2F; index.js</p></li></ol></li></ol></li></ol><h2 id="五、Vue路由"><a href="#五、Vue路由" class="headerlink" title="五、Vue路由"></a>五、Vue路由</h2><ol><li><h4 id="路由安装和介绍"><a href="#路由安装和介绍" class="headerlink" title="路由安装和介绍"></a>路由安装和介绍</h4><p>（router、单页面应用、SPA）</p><p>单页面应用：一个url（只有一个html）</p><ul><li><p>跳转不同组件</p></li><li><p>路径传值（url传值）</p></li><li><p>拦截</p><hr></li></ul><ol><li><p>使用</p><p><code>vue create 项目名称</code></p><p>选择自定义安装：安装Router</p><p>目录结构：</p><ul><li>router &#x2F; index.js：路由的配置</li><li>views：页面（组件）</li><li>components：页面模块（页面中的组件）</li></ul></li></ol></li><li><h4 id="router-link相关配置"><a href="#router-link相关配置" class="headerlink" title="router-link相关配置"></a>router-link相关配置</h4><ol><li><p>to：表示目标路由的链接</p><ul><li><p>跳转形式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/my&quot;</span> <span class="attr">tag</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&#x27;&#123;path:&quot;/my&quot;&#125;&#x27;</span>&gt;</span>我的<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&#x27;&#123;name:&quot;Cart&quot;&#125;&#x27;</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>路径传值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&#x27;&#123; name:&quot;Cart&quot;, query:&#123;a:1&#125; &#125;&#x27;</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>tag：默认生成a标签，如果希望修改 <code>tag=&#39;li&#39;</code></p></li><li><p>组件形式的跳转方式</p><p>replace</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&#x27;&#123; path:&quot;Cart&quot; replace &#125;&#x27;</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>append</p></li><li><p>exact：精准路由匹配模式</p></li><li><p>js的跳转方式</p><p><code>router.push</code>：打开新页面，并且可以返回上一页</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/list&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>router.replace</code>：打开新页面，不能返回上一页</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/list&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>router.go</code>：打开新页面，跳转几层</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>();</span><br></pre></td></tr></table></figure><p><code>router.back</code>：返回上一页</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>();</span><br></pre></td></tr></table></figure><p>传值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;selectList&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="router内文件配置"><a href="#router内文件配置" class="headerlink" title="router内文件配置"></a>router内文件配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">    <span class="comment">// 直接引入</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">    <span class="comment">// 二级路由</span></span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;city&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;city&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../views/About.vue&quot;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="comment">// 懒加载路由</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/about&quot;</span>,</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;About&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../views/About.vue&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 重定向</span></span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">&#x27;*&#x27;</span>,<span class="attr">redirect</span>:<span class="string">&#x27;/&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="路径传值"><a href="#路径传值" class="headerlink" title="路径传值"></a>路径传值</h4><ol><li><p>传值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">       <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>接收</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="导航守卫（拦截）"><a href="#导航守卫（拦截）" class="headerlink" title="导航守卫（拦截）"></a>导航守卫（拦截）</h4><ol><li><p>全局</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeRouteUpdate</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeRouteLeave</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>路由独享</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><code>to</code>：这是你跳转到哪个路由对象</p><p><code>from</code>：这是你要离开的路由对象</p><p><code>next</code>：是一个方法，可以接受参数，这个方法必须调用</p><ul><li><p><code>next()</code>：告诉保安要过去，去哪里就是to</p></li><li><p><code>next(false)</code>：可以不通过，中断跳转</p></li><li><p><code>next(&#39;/&#39;)</code>：保安不让过，你可以去另一个地方进行通过</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">name</span> == <span class="string">&#x27;About&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!userInfo)&#123;</span><br><span class="line">            router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><h4 id="watch：监听"><a href="#watch：监听" class="headerlink" title="watch：监听"></a>watch：监听</h4><ol><li><p>监听路由的变化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    $route(to,<span class="keyword">from</span>)&#123;</span><br><span class="line">        <span class="comment">// to:最新的路由</span></span><br><span class="line">        <span class="comment">// from:上一次的路由</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(to.<span class="property">path</span>, <span class="keyword">from</span>.<span class="property">path</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监听数据的变化</p><p>监听b但是是b的c改变了，所以要监听b内所有的属性变化，就要用到深度监听</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;h1&gt;A:&#123;&#123;  a &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;B:&#123;&#123;  b.c &#125;&#125;  &lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&#x27;btn&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"></span><br><span class="line">data () &#123;</span><br><span class="line">return &#123;</span><br><span class="line">a:1,</span><br><span class="line">b:&#123;</span><br><span class="line">c:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">btn()&#123;</span><br><span class="line">this.a = 2;</span><br><span class="line">this.b.c = 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line"></span><br><span class="line">a(to,from)&#123;</span><br><span class="line">//to   ==&gt; 最新的</span><br><span class="line">//from ==&gt; 上一次的</span><br><span class="line">console.log(to,from)</span><br><span class="line">&#125;,</span><br><span class="line">b:&#123;</span><br><span class="line">handler(to)&#123;</span><br><span class="line">console.log(&#x27;B:&#x27;,to.c)</span><br><span class="line">&#125;,</span><br><span class="line">//深度监听</span><br><span class="line">deep:true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="六、Vuex"><a href="#六、Vuex" class="headerlink" title="六、Vuex"></a>六、Vuex</h2><p>vuex：状态管理（集中式存储管理应用的所有组件的状态）</p><p>vuex的属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">state</span>: &#123;&#125;,       <span class="comment">// 放入数据[类似于组件中的data]</span></span><br><span class="line"><span class="attr">getters</span>: &#123;&#125;,     <span class="comment">// 就是一个计算属性[类似于组件中的computed]</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;&#125;,   <span class="comment">// 就是一个存放方法的[类似于组件中的methods]</span></span><br><span class="line"><span class="attr">actions</span>: &#123;&#125;,     <span class="comment">// Action 类似于 mutation [Action 提交的是 mutation，而不是直接变更状态。]</span></span><br><span class="line"><span class="attr">modules</span>: &#123;&#125;,     <span class="comment">// 分成多个模块，每个模块都有state、getters、mutations、actions</span></span><br></pre></td></tr></table></figure><ol><li><h4 id="Vuex中的state"><a href="#Vuex中的state" class="headerlink" title="Vuex中的state"></a>Vuex中的state</h4><p>state数据如何拿到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">&#123;&#123; $store.state.a &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方式二</span><br><span class="line">&#123;&#123; a &#125;&#125;</span><br><span class="line">&#123;&#123; b &#125;&#125;</span><br><span class="line">&#123;&#123; arr &#125;&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">computed:&#123;</span><br><span class="line">        ...mapState([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;arr&#x27;])</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><h4 id="Vuex中的getters"><a href="#Vuex中的getters" class="headerlink" title="Vuex中的getters"></a>Vuex中的getters</h4><p>&#x2F; store &#x2F; index.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">  <span class="attr">list</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attr">goods_id</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">goods_name</span>:<span class="string">&#x27;鞋&#x27;</span>,</span><br><span class="line">  <span class="attr">goods_num</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="attr">goods_price</span>:<span class="number">299</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attr">goods_id</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">goods_name</span>:<span class="string">&#x27;衣服&#x27;</span>,</span><br><span class="line">  <span class="attr">goods_num</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">goods_price</span>:<span class="number">49</span></span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">  <span class="title function_">total</span>(<span class="params"> state </span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">count</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">num</span>:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  state.<span class="property">list</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//总价</span></span><br><span class="line">  obj.<span class="property">count</span> += v.<span class="property">goods_num</span> * v.<span class="property">goods_price</span>;</span><br><span class="line">  <span class="comment">//总数量</span></span><br><span class="line">  obj.<span class="property">num</span> += v.<span class="property">goods_num</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共:&#123;&#123; total.num &#125;&#125;</span><br><span class="line">总计:&#123;&#123; total.count &#125;&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState, mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">computed:&#123;</span><br><span class="line">        ...mapState([&#x27;list&#x27;]),</span><br><span class="line">        ...mapGetters([&#x27;total&#x27;])</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><h4 id="Vuex中的mutations"><a href="#Vuex中的mutations" class="headerlink" title="Vuex中的mutations"></a>Vuex中的mutations</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">  &lt;h1&gt;这是首页Home&lt;/h1&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27;&gt;</span><br><span class="line">  &#123;&#123;item.appName&#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import &#123;mapMutations,mapState&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  created()&#123;</span><br><span class="line">  this.getData();</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">  ...mapState([&#x27;list&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">  ...mapMutations([&#x27;initData&#x27;]),</span><br><span class="line">  getData()&#123;</span><br><span class="line"></span><br><span class="line">  axios(&#123;</span><br><span class="line">  url:&#x27;http://39.101.217.150:8075/apps/list&#x27;,</span><br><span class="line">  params:&#123;</span><br><span class="line">  page:1,</span><br><span class="line">  size:3</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;).then(res=&gt;&#123;</span><br><span class="line">  this.initData(res.data.data.records);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">list</span>:[]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="title function_">initData</span>(<span class="params"> state , data </span>)&#123;</span><br><span class="line">  state.<span class="property">list</span> = data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">changeBtn</span>(<span class="params"> state </span>)&#123;</span><br><span class="line">  state.<span class="property">a</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><h4 id="Vuex中的actions"><a href="#Vuex中的actions" class="headerlink" title="Vuex中的actions"></a>Vuex中的actions</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&#x27;(item,index) in list&#x27; :key=&#x27;index&#x27;&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; :checked=&#x27;item.checked&#x27;&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;label @click=&#x27;checkedFn&#x27;&gt;</span><br><span class="line">  &lt;input type=&quot;radio&quot; :checked=&#x27;checkAll&#x27;/&gt;全选</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">import &#123;mapState,mapGetters,mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">computed:&#123;</span><br><span class="line">...mapState([&#x27;list&#x27;]),</span><br><span class="line">...mapGetters([&#x27;checkAll&#x27;])</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">...mapActions([&#x27;checkedFn&#x27;])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">  <span class="attr">list</span>:[  <span class="comment">//===&gt; length 6</span></span><br><span class="line">  &#123;<span class="attr">checked</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">checked</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">checked</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">checked</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">checked</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">checked</span>:<span class="literal">false</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">selectedList</span>:[]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="title function_">checkAll</span>(<span class="params"> state </span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> state.<span class="property">list</span>.<span class="property">length</span> == state.<span class="property">selectedList</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  <span class="comment">//全选</span></span><br><span class="line">  <span class="title function_">checkAll</span>(<span class="params"> state </span>)&#123;</span><br><span class="line">  state.<span class="property">selectedList</span> = state.<span class="property">list</span>.<span class="title function_">map</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">  v.<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//全不选</span></span><br><span class="line">  <span class="title function_">unCheckAll</span>(<span class="params"> state </span>)&#123;</span><br><span class="line">  state.<span class="property">list</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">  v.<span class="property">checked</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  state.<span class="property">selectedList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">checkedFn</span>(<span class="params">&#123;commit,getters&#125;</span>)&#123;</span><br><span class="line"></span><br><span class="line">  getters.<span class="property">checkAll</span> ? <span class="title function_">commit</span>(<span class="string">&#x27;unCheckAll&#x27;</span>) : <span class="title function_">commit</span>(<span class="string">&#x27;checkAll&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>mapState</code>、<code>mapGetters</code>放在组件中的computed中</strong></p></li><li><p><strong><code>mapMutations</code>、<code>mapActions</code>放在组件中的methods中</strong></p></li></ul></li><li><h4 id="actions和mutations的区别【面试题】"><a href="#actions和mutations的区别【面试题】" class="headerlink" title="actions和mutations的区别【面试题】"></a>actions和mutations的区别【面试题】</h4><ul><li><p>action 提交的是 mutation，而不是直接变更状态</p></li><li><p>mutations 是同步的、action 可以包含任意异步操作</p></li><li><p>action 更加容易调试</p></li></ul></li><li><h4 id="Vuex中的modules"><a href="#Vuex中的modules" class="headerlink" title="Vuex中的modules"></a>Vuex中的modules</h4><p>目录结构：</p><p><img src="/../image/Vue/image-20240726231609152.png" alt="image-20240726231609152"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;./modules/path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> order <span class="keyword">from</span> <span class="string">&#x27;./modules/order&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  path,</span><br><span class="line">  order</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// part.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line"><span class="attr">state</span>:&#123;</span><br><span class="line"><span class="attr">list</span>:[<span class="string">&#x27;地址1&#x27;</span>,<span class="string">&#x27;地址2&#x27;</span>]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">getters</span>:&#123;&#125;,</span><br><span class="line"><span class="attr">mutations</span>:&#123;</span><br><span class="line"><span class="title function_">btn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">actions</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&#x27;btn&#x27;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    地址：&#123;&#123;pathList&#125;&#125;</span><br><span class="line">    订单：&#123;&#123;orderList&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState,mapMutations&#125; from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">  pathList:state=&gt;state.path.list,</span><br><span class="line">  orderList:state=&gt;state.order.list</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">  ...mapMutations([&#x27;btn&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="七、Vue面试题"><a href="#七、Vue面试题" class="headerlink" title="七、Vue面试题"></a>七、Vue面试题</h2><ol><li><h4 id="双向绑定的原理"><a href="#双向绑定的原理" class="headerlink" title="双向绑定的原理"></a>双向绑定的原理</h4><p>通过数据劫持结合发布者订阅者模式，使用Object.defineProperty方法对每个属性的get和set进行拦截，当数据发现变化时，发布消息给订阅者，触发相应的监听回调，实现视图和数据的双向同步更新</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(对象,<span class="string">&#x27;属性&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">// 设置劫持</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取劫持</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;btnInput&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&#x27;h1&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&#x27;h2&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> btnInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnInput&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> h1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> h2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> obj = &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//只要赋值，给我console.log( &#x27;赋值了&#x27; )</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//obj.xx = &#x27;123&#x27;;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;names&#x27;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//设置劫持</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">set</span>(<span class="params"> val </span>)&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">h1.<span class="property">innerHTML</span> = val;</span></span><br><span class="line"><span class="language-javascript">h2.<span class="property">innerHTML</span> = val;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;设置&#x27;</span> );</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">names=val;</span></span><br><span class="line"><span class="language-javascript">&#125;,</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//获取劫持</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> names;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">btnInput.<span class="property">oninput</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">obj.<span class="property">names</span> = <span class="variable language_">this</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="Object-freeze性能优化"><a href="#Object-freeze性能优化" class="headerlink" title="Object.freeze性能优化"></a>Object.freeze性能优化</h4><p>用于冻结对象，禁止对于该对象的属性进行修改（由于数组本身也是对象，因此该方法可以对数组使用）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;xxx&#x27;</span>，</span><br><span class="line">        <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">page</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">size</span>:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Vue生命周期-1"><a href="#Vue生命周期-1" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h4><ol><li><p>vue的生命周期有哪些</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">beforeUpdate</span><br><span class="line">updated</span><br><span class="line">beforeDestroy</span><br><span class="line">destroyed</span><br></pre></td></tr></table></figure></li><li><p>一旦进入组件或者页面，会执行哪些生命周期</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br></pre></td></tr></table></figure></li><li><p>如果使用了keep-alive会多出来俩个生命周期</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">activated</span><br><span class="line">deactivated</span><br></pre></td></tr></table></figure></li><li><p>如果使用了keep-alive第一次进入组件会执行5个生命周期</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate</span><br><span class="line">created</span><br><span class="line">beforeMount</span><br><span class="line">mounted</span><br><span class="line">activated</span><br></pre></td></tr></table></figure></li><li><p>如果使用了keep-alive第二次或者第N次，每次都会执行一个生命周期</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">activated</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h4><ul><li>v-show：显示和隐藏 : <code>display:none</code>进行隐藏 、<code>display:block</code>进行显示</li><li>v-if：创建和删除：remove、append</li><li>区别：<ul><li>显示和隐藏用：v-show<br>创建和删除用：v-if</li><li>频繁切换用：v-show<br>不频繁切换用：v-if</li><li>首次加载：用v-if，不用v-show<ul><li>如果用v-if可以没有这个盒子，然后再通过v-if进行创建（但是第一次进入页面是没有这个盒子，是不加载的）。</li><li>如果用v-show这个盒子不管是显示还是隐藏，该盒子都是在的（节点都是存在）</li></ul></li></ul></li><li>使用场景：<ul><li>v-show ： 加入购物车、分享、蒙层这种都基本上用v-show<br>v-if : 首页栏目切换的时候v-if</li></ul></li></ul></li><li><h4 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h4><p><strong>v-for的优先级要比v-if的优先级高</strong></p><p>证明这个事情，是在vue.js源码中10997行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">genStatic</span>(el, state)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">once</span> &amp;&amp; !el.<span class="property">onceProcessed</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">genOnce</span>(el, state)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">genFor</span>(el, state)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">genIf</span>(el, state)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;template&#x27;</span> &amp;&amp; !el.<span class="property">slotTarget</span> &amp;&amp; !state.<span class="property">pre</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">genChildren</span>(el, state) || <span class="string">&#x27;void 0&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">genSlot</span>(el, state)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p><strong>注：v-if和v-for不要写在同一个节点上，这个性能很差。（v-if要写在父节点上）</strong></p></li><li><h4 id="ref、keep-alive、nextTick"><a href="#ref、keep-alive、nextTick" class="headerlink" title="ref、keep-alive、nextTick"></a>ref、keep-alive、nextTick</h4><ol><li><p><code>ref</code>：获取dom</p><p>场景：如果项目中使用插件，并且插件是要获取dom的，那么就可以使用ref了。</p></li><li><p><code>keep-alive</code>：缓存组件</p><p>一旦使用keep-alive会多两个生命周期，activated、deactivated</p><p>功能：提升性能的</p></li><li><p><code>nextTick</code>：当dom更新完毕执行内部代码</p><p>场景：使用插件的时候会用到。例如new Swiper这个插件可能会获取当前元素的宽度或者高度，等dom都加载完毕再去获取宽度和高度就不会有任何问题了。</p></li></ol></li><li><h4 id="computed、methods、watch区别"><a href="#computed、methods、watch区别" class="headerlink" title="computed、methods、watch区别"></a>computed、methods、watch区别</h4><ol><li><p><strong>computed：计算属性</strong></p><p>可以监听某些数据的变化，并且有缓存。</p><p>如果一进入页面调用，就会触发</p></li><li><p><strong>methods  ： 可以放入函数</strong></p><p>没有缓存</p><p>如果一进入页面调用，就会触发</p></li><li><p><strong>watch ：监听（路由和数据）</strong></p><p>当数据发生改变时，才会触发</p><p>可以得到现在的值和过去的值</p></li></ol></li><li><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><ol><li><p><strong>父传子</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父：</span><br><span class="line">&lt;<span class="title class_">HelloWorld</span> :msg=<span class="string">&quot;str&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">:msg</span>=<span class="string">&quot;str&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">子：</span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;msg&#x27;</span>]</span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line"><span class="attr">msg</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>子传父</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">子：</span><br><span class="line">&lt;button @click=<span class="string">&quot;changeParentName&quot;</span>&gt;改变父组件的name&lt;/button&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">//子组件的事件</span></span><br><span class="line">        <span class="attr">changeParentName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&#x27;handleChange&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// 触发父组件中handleChange事件并传参Jack</span></span><br><span class="line">            <span class="comment">// 注：此处事件名称与父组件中绑定的事件名称要一致</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">父：</span><br><span class="line">&lt;child @handleChange=<span class="string">&quot;changeName&quot;</span>&gt;&lt;/child&gt;</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">changeName</span>(<span class="params">name</span>) &#123;  <span class="comment">// name形参是子组件中传入的值Jack</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>兄弟组件传值</strong></p><p>创建bus作为中转</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A组件：</span><br><span class="line">&lt;button @click=<span class="string">&#x27;btn&#x27;</span>&gt;<span class="title class_">HelloWorld</span>按钮&lt;/button&gt;</span><br><span class="line"><span class="title function_">data</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">hlStr</span>:<span class="string">&quot;这是helloWorld组件的数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">btn</span>(<span class="params"></span>)&#123;</span><br><span class="line">      bus.$emit(<span class="string">&#x27;selectItem&#x27;</span>,<span class="variable language_">this</span>.<span class="property">hlStr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B组件：</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">bus.$on(<span class="string">&#x27;selectItem&#x27;</span>,<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( val , <span class="number">1111</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><h4 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h4><p>使用场景：组件中有些地方的布局可能大多一致，但是细微有些小小变化</p></li><li><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ol><li><p><strong>SPA单页面应用和传统页面跳转有什么区别？</strong></p><p>SPA跳转是一个页面进行切换</p><p>传统页面跳转就是跳转不同的html了</p><p>SPA对于seo部分不是特别好，只能收录一个</p><p>传统的页面对于seo比较好，多个html文件收录</p></li><li><p><strong>路径传值</strong></p><p>显示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">传：</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:<span class="string">&#x27;你好&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">接：</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span></span><br></pre></td></tr></table></figure><p>隐示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">传：</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">        <span class="attr">params</span>:&#123;</span><br><span class="line">          <span class="attr">key</span>:<span class="string">&#x27;你好&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">接：</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span></span><br></pre></td></tr></table></figure></li><li><p><strong>路由的模式</strong></p><p>mode: “history”   <a href="http://localhost:8080/about">http://localhost:8080/about</a></p><p>mode:”hash”       <a href="http://localhost:8080/#/about">http://localhost:8080/#/about</a></p></li><li><p><strong>路由导航守卫（拦截、路由钩子函数）</strong></p><p>全局</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeEach</span><br><span class="line">beforeResolve</span><br><span class="line">afterEach</span><br></pre></td></tr></table></figure><p>路由独享</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeEnter</span><br></pre></td></tr></table></figure><p>组件内</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter</span><br><span class="line">beforeRouteUpdate (2.2 新增)</span><br><span class="line">beforeRouteLeave</span><br></pre></td></tr></table></figure><p><strong>场景：要去拦截，判断用户是否是登录状态。功能：进入地址管理，用户如果没有登录是进入不了地址管理（在进入之前判断拦截），需要先登录。</strong></p></li><li><p><strong>子路由、动态路由</strong></p><p>子路由：<code>children</code><br>动态路由：<code>path: &#39;/user/:id&#39;</code></p></li></ol></li><li><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><ol><li><p><strong>Vuex有哪些部分构成</strong></p><p>state、getters、mutations、actions、modules</p></li><li><p><strong>什么场景用Vuex</strong></p><p>共享、方便管理、方便维护、组件传值……</p><p>项目：购物车数据，订单数据，用户的登录信息….</p></li><li><p><strong>mutations和actions的区别</strong></p><p>本质区别：<br>mutations必须是同步函数<br>actions“可以包含”任意异步操作</p><p>使用区别：mutations中可以放入函数，actions也可以放入函数，但是一般我们在mutations中放入函数而actions是提交mutations</p></li></ol></li><li><h4 id="v-model双向绑定原理"><a href="#v-model双向绑定原理" class="headerlink" title="v-model双向绑定原理"></a>v-model双向绑定原理</h4><p>通过Object.defineProperty劫持数据发生的改变，如果数据发生改变了（在set中进行赋值的），触发update方法进行更新节点内容（），从而实现了数据双向绑定的原理。</p></li><li><h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><p>功能：提升性能</p><p>虚拟dom —-&gt; 其实就是数据（ 把dom数据化 ）</p><p><strong>主流：snabbdom、virtual-dom</strong></p><p>snabbdom：<a href="https://www.npmjs.com/package/snabbdom">https://www.npmjs.com/package/snabbdom</a></p><ol><li><p><strong>搭建环境</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">cnpm install webpack@5 webpack-cli@3 webpack-dev-server@3 -S</span><br><span class="line"></span><br><span class="line">cnpm install snabbdom -S</span><br><span class="line"></span><br><span class="line">新建webpack.config.js</span><br><span class="line"></span><br><span class="line">配置webpack.config.js</span><br></pre></td></tr></table></figure></li><li><p><strong>虚拟节点 和  真实节点</strong></p><p>虚拟节点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="literal">undefined</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">  <span class="attr">elm</span>: h1</span><br><span class="line">  <span class="attr">key</span>: <span class="literal">undefined</span></span><br><span class="line">  <span class="attr">sel</span>: <span class="string">&quot;h1&quot;</span></span><br><span class="line">  <span class="attr">text</span>: <span class="string">&quot;你好h1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实节点：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>新老节点替换的规则</strong></p><ol><li><p>如果新老节点不是同一个节点名称，那么就暴力删除旧的节点，创建插入新的节点。</p></li><li><p>只能同级比较，不能跨层比较。如果跨层那么就暴力删除旧的节点，创建插入新的节点。</p></li><li><p>如果是相同节点，又分为很多情况</p><ol><li><p>新节点有没有children</p><p>如果新的节点没有children，那就证明新节点是文本，那直接把旧的替换成新的文本</p></li><li><p>新节点有children</p><p>新的有children，旧的也有children —-&gt; 就是diff算法的核心了【3】<br>新的有children，旧的没有 —-&gt; 创建元素添加（把旧的内容删除清空掉，增加新的）</p></li><li><p><strong>diff算法的核心（最复杂的情况）</strong></p><ol><li><p><strong>旧前 和 新前</strong></p><p>匹配：旧前的指针++ 、 新前的指针++</p></li><li><p><strong>旧后 和 新后</strong></p><p>匹配：旧后的指针– 、 新后的指针–</p></li><li><p><strong>旧前 和 新后</strong></p><p>匹配：旧前的指针++ 、 新后的指针–</p></li><li><p><strong>旧后 和 新前</strong></p><p>匹配：旧后的指针– 、 新前的指针++</p></li><li><p><strong>以上都不满足条件 —-&gt; 查找</strong></p><p>新的指针++，新的添加到页面上并且新在旧的种有，要给旧的复制成undefined</p></li><li><p><strong>创建或者删除</strong></p></li></ol></li></ol><p><strong>注意：如果要提升性能，一定要加入key，key是唯一标示，在更改前后，确认是不是同一个节点。</strong></p></li></ol></li></ol></li><li><h4 id="snabbdom"><a href="#snabbdom" class="headerlink" title="snabbdom"></a>snabbdom</h4></li><li><h4 id="手写diff算法-—-生成虚拟dom"><a href="#手写diff算法-—-生成虚拟dom" class="headerlink" title="手写diff算法 — 生成虚拟dom"></a>手写diff算法 — 生成虚拟dom</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h.js</span></span><br><span class="line"><span class="keyword">import</span> vnode <span class="keyword">from</span> <span class="string">&#x27;./vnode&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"> sel, data, params</span>)&#123;</span><br><span class="line">    <span class="comment">// h函数的 第三个参数是字符串类型，意味着没有子元素</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> params == <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">vnode</span>(sel, data, underfined, params, underfined)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(params))&#123;</span><br><span class="line">        <span class="keyword">let</span> children = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> params)&#123;</span><br><span class="line">            children.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">vnode</span>(sel, data, children, underfined, underfined)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> h <span class="keyword">from</span> <span class="string">&#x27;./h&#x27;</span></span><br><span class="line"><span class="keyword">let</span> vnode1 = <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vnode2 = <span class="title function_">h</span>(<span class="string">&#x27;ui&#x27;</span>, &#123;&#125;, [</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;&#125;, <span class="string">&#x27;你好&#x27;</span>),</span><br><span class="line">])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vnode2)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vode.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">sel, data, children, text, elm</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sel,</span><br><span class="line">        data,</span><br><span class="line">        children,</span><br><span class="line">        text,</span><br><span class="line">        elm</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="手写diff算法-—-patch不是同一个节点-—-相同节点有没有chrildren"><a href="#手写diff算法-—-patch不是同一个节点-—-相同节点有没有chrildren" class="headerlink" title="手写diff算法 — patch不是同一个节点 — 相同节点有没有chrildren"></a>手写diff算法 — patch不是同一个节点 — 相同节点有没有chrildren</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vode.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">sel, data, children, text, elm</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = data.<span class="property">key</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sel,</span><br><span class="line">        data,</span><br><span class="line">        children,</span><br><span class="line">        text,</span><br><span class="line">        elm,</span><br><span class="line">        key</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        这是container</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> h <span class="keyword">from</span> <span class="string">&#x27;./h&#x27;</span></span><br><span class="line"><span class="keyword">import</span> patch <span class="keyword">from</span> <span class="string">&#x27;./patch&#x27;</span></span><br><span class="line"><span class="comment">// 获取真实dom节点</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="comment">// 虚拟节点</span></span><br><span class="line"><span class="keyword">let</span> vnode1 = <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="string">&#x27;你好&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> vnode2 = <span class="title function_">h</span>(<span class="string">&#x27;ui&#x27;</span>, &#123;&#125;, [</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">key</span>:<span class="string">&#x27;a&#x27;</span>&#125;, <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">key</span>:<span class="string">&#x27;b&#x27;</span>&#125;, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span>&#125;, <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">key</span>:<span class="string">&#x27;d&#x27;</span>&#125;, <span class="string">&#x27;d&#x27;</span>),</span><br><span class="line">])</span><br><span class="line"><span class="title function_">patch</span>(container, vnode1);</span><br><span class="line"><span class="title function_">patch</span>(container, vnode2);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patch.js</span></span><br><span class="line"><span class="keyword">import</span> vnode <span class="keyword">from</span> <span class="string">&#x27;./vnode&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createElement <span class="keyword">from</span> <span class="string">&#x27;./createElement&#x27;</span></span><br><span class="line"><span class="keyword">import</span> newVnode <span class="keyword">from</span> <span class="string">&#x27;./patchVnode&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">oldVnode, newVnode</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode没有sel，就证明是虚拟节点（让他变成虚拟节点）</span></span><br><span class="line">    <span class="keyword">if</span>(oldVnode.<span class="property">sel</span> == underfined)&#123;</span><br><span class="line">        oldVnode = <span class="title function_">vnode</span>(</span><br><span class="line">        oldVnode.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>(), <span class="comment">// sel</span></span><br><span class="line">            &#123;&#125;, <span class="comment">// data</span></span><br><span class="line">            [],</span><br><span class="line">            underfined,</span><br><span class="line">            oldVnode</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断两个节点是否是同一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(oldVnode.<span class="property">sel</span> === newVnode.<span class="property">sel</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断条件复杂</span></span><br><span class="line">        <span class="title function_">patchVnode</span>(oldVnode, newVnode);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不是同一个节点，那么就暴力删除旧的节点，创建插入新的节点</span></span><br><span class="line">        <span class="comment">// 把新的虚拟节点创建为dom节点</span></span><br><span class="line">        <span class="keyword">let</span> newVnodeElm = <span class="title function_">createElement</span>(newVnode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取旧的虚拟节点，elm就是真正的节点</span></span><br><span class="line">        <span class="keyword">let</span> oldVnodeElm = oldVnode.<span class="property">elm</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新的节点</span></span><br><span class="line">        <span class="keyword">if</span>(newVnodeElm)&#123;</span><br><span class="line">            oldVnodeElm.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(newVnodeElm, oldVnodeElm)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除旧的节点</span></span><br><span class="line">        oldVnodeElm.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(oldVnodeElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createElement.js</span></span><br><span class="line"><span class="comment">// vnode为新节点，就是要创建的节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">vnode</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> domNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">sel</span>);</span><br><span class="line">    <span class="comment">// 判断有没有子节点 children 是不是为underfined</span></span><br><span class="line">    <span class="keyword">if</span>(vnode.<span class="property">children</span> == underfined)&#123;</span><br><span class="line">        domNode.<span class="property">innerText</span> = vnode.<span class="property">text</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode.<span class="property">children</span>))&#123;</span><br><span class="line">        <span class="comment">// 新的节点有children（子节点）,需要递归创建节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> vnode.<span class="property">children</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> childDom = <span class="title function_">createElement</span>(child);</span><br><span class="line">            domNode.<span class="title function_">appendChild</span>(childDom);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 补充elm属性</span></span><br><span class="line">    vnode.<span class="property">elm</span> = domNode;</span><br><span class="line">    <span class="keyword">return</span> domNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patchVnode.js</span></span><br><span class="line"><span class="keyword">import</span> createElement <span class="keyword">from</span> <span class="string">&#x27;./createElement&#x27;</span></span><br><span class="line"><span class="keyword">import</span> updateChildren <span class="keyword">from</span> <span class="string">&#x27;./updateChildren&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">patchVnode</span>(<span class="params">oldVnode, newVnode</span>)&#123;</span><br><span class="line">    <span class="comment">// 判断新节点有没有children</span></span><br><span class="line">    <span class="keyword">if</span>(newVnode.<span class="property">children</span> === underfined)&#123;</span><br><span class="line">        <span class="comment">// 没有子节点</span></span><br><span class="line">        <span class="comment">// 新节点的文本合旧节点的文本内容是不是一样的</span></span><br><span class="line">        <span class="keyword">if</span>(newVnode.<span class="property">text</span> !== oldVnode.<span class="property">text</span>)&#123;</span><br><span class="line">            oldVnode.<span class="property">elm</span>.<span class="property">innerText</span> = newVnode.<span class="property">text</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有子节点</span></span><br><span class="line">        <span class="comment">// 新节点虚拟节点有，旧的虚拟节点有</span></span><br><span class="line">        <span class="keyword">if</span>(oldVnode.<span class="property">children</span> !== underfined &amp;&amp; oldVnode.<span class="property">children</span>.<span class="property">legth</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 最复杂，diff核心</span></span><br><span class="line">            <span class="title function_">updateChildren</span>(oldVnode.<span class="property">elm</span>, oldVnode.<span class="property">children</span>, newVnode.<span class="property">children</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 新节点虚拟节点有，旧的虚拟节点没有</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把旧节点内容清空</span></span><br><span class="line">            oldVnode.<span class="property">elm</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="comment">// 遍历新的子节点，创建dom元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> newVnode.<span class="property">children</span>)&#123;</span><br><span class="line">                <span class="keyword">let</span> childDom = <span class="title function_">createElement</span>(child);</span><br><span class="line">                oldVnode.<span class="property">elm</span>.<span class="title function_">appendChild</span>(childDom);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// updateChildren.js</span></span><br><span class="line"><span class="keyword">import</span> patchVnode <span class="keyword">from</span> <span class="string">&#x27;./patchVnode&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createElement <span class="keyword">from</span> <span class="string">&#x27;./createElement&#x27;</span></span><br><span class="line"><span class="comment">// 判断两个虚拟节点是否为同一个节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">vNode1, vNode2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> vNode1.<span class="property">key</span> == vNode2.<span class="property">key</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数1：真实dom节点</span></span><br><span class="line"><span class="comment">// 参数2：旧的虚拟节点</span></span><br><span class="line"><span class="comment">// 参数3：新的虚拟节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="title function_">default</span> (parentElm, oldCh, newCh) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;                  <span class="comment">// 旧前指针</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.<span class="property">length</span> - <span class="number">1</span>;     <span class="comment">// 旧后指针</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;                  <span class="comment">// 新前指针</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.<span class="property">length</span> - <span class="number">1</span>;     <span class="comment">// 新后指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];         <span class="comment">// 旧前虚拟节点</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];   <span class="comment">// 旧后虚拟节点</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];         <span class="comment">// 新前虚拟节点</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];   <span class="comment">// 新后虚拟节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx)&#123;</span><br><span class="line">        <span class="keyword">if</span>(oldStartVnode == underfined)&#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(oldEndVnode == underfined)&#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">sameVnode</span>(oldStartVnode, newStartVnode))&#123;</span><br><span class="line">            <span class="comment">// 旧前 和 新前</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldStartVnode, newStartVnode);</span><br><span class="line">            <span class="keyword">if</span>(newStartVnode)&#123;</span><br><span class="line">                newStartVnode.<span class="property">elm</span> = oldStartVnode?.<span class="property">elm</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            oldStartVnode = oldCh[++oldStsrtIdx];</span><br><span class="line">            newStartVnode = newCh[++newStsrtIdx];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">sameVnode</span>(oldEndVnode, newEndVnode))&#123;</span><br><span class="line">            <span class="comment">// 旧后 和 新后</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldEndVnode, newEndVnode);</span><br><span class="line">            <span class="keyword">if</span>(newEndVnode)&#123;</span><br><span class="line">                newEndVnode.<span class="property">elm</span> = oldEndVnode?.<span class="property">elm</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndVnode];</span><br><span class="line">            newEndVnode = newCh[--newEndVnode];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">sameVnode</span>(oldStartVnode, newEndVnode))&#123;</span><br><span class="line">            <span class="comment">// 旧前 和 新后</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldStartVnode, newEndVnode);</span><br><span class="line">            <span class="keyword">if</span>(newEndVnode)&#123;</span><br><span class="line">                newEndVnode.<span class="property">elm</span> = oldStartVnode?.<span class="property">elm</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把旧前指定的节点移动到旧后指向的节点的后面</span></span><br><span class="line">            parentElm.<span class="title function_">insertBefore</span>(oldEndVnode.<span class="property">elm</span>, oldEndVnode.<span class="property">elm</span>.<span class="property">nextSibling</span>)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartVnode];</span><br><span class="line">            newEndVnode = newCh[--newEndVnode];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">sameVnode</span>(oldEndVnode, newStartVnode))&#123;</span><br><span class="line">            <span class="comment">// 旧后 和 新前</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldEndVnode, newStartVnode);</span><br><span class="line">            <span class="keyword">if</span>(newStartVnode)&#123;</span><br><span class="line">                newStartVnode.<span class="property">elm</span> = oldEndVnode?.<span class="property">elm</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把旧后指定的节点移动到旧前指向的节点的前面</span></span><br><span class="line">            parentElm.<span class="title function_">insertBefore</span>(oldStartVnode.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndVnode];</span><br><span class="line">            newStartVnode = newCh[++newStartVnode];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 以上都不满足查找</span></span><br><span class="line">            <span class="comment">// 创建一个对象，存虚拟节点（判断新旧有没有相节点）</span></span><br><span class="line">            <span class="keyword">const</span> keyMap = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++)&#123;</span><br><span class="line">                <span class="keyword">const</span> key = oldCh[i]?.<span class="property">key</span>;</span><br><span class="line">                <span class="keyword">if</span>(key)&#123;</span><br><span class="line">                    keyMap[key] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在旧节点中查找新前指向节点</span></span><br><span class="line">            <span class="keyword">let</span> idxInOld = keyMap[newStartVnode.<span class="property">key</span>];</span><br><span class="line">            <span class="comment">// 如果有，说明数据在新旧虚拟节点中都存在</span></span><br><span class="line">            <span class="keyword">if</span>(idxInOld)&#123;</span><br><span class="line">                <span class="keyword">const</span> elmMove = oldCh[idxInOld];</span><br><span class="line">                <span class="title function_">patchVnode</span>(elmMove, newStartVnode);</span><br><span class="line">                <span class="comment">// 处理过的节点，在旧虚拟系欸但的数组中，设置为underfined</span></span><br><span class="line">                oldCh[idxInOld] = underfined;</span><br><span class="line">                parentElm.<span class="title function_">insertBefore</span>(elmMove.<span class="property">elm</span>, oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果没有找到，说明是一个新的节点（创建）</span></span><br><span class="line">                parentElm.<span class="title function_">insertBefore</span>(<span class="title function_">createElement</span>(newStartVnode), oldStartVnode.<span class="property">elm</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束循环只有两种情况，新增和删除</span></span><br><span class="line">    <span class="comment">// 1、oldStartIdx &gt; oldEndIdx</span></span><br><span class="line">    <span class="comment">// 2、newStartIdx &gt; newEndIdx</span></span><br><span class="line">    <span class="keyword">if</span>(oldStartIdx &gt; oldEndIdx)&#123;</span><br><span class="line">        <span class="keyword">const</span> before = newCh[newEndIdx+<span class="number">1</span>] ? newCh[newEndIdx+<span class="number">1</span>].<span class="property">elm</span> : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++)&#123;</span><br><span class="line">            parentElm.<span class="title function_">insertBefore</span>(<span class="title function_">createElement</span>(newCh[i]), before);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 进入删除操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++)&#123;</span><br><span class="line">            parentElm.<span class="title function_">removeChild</span>(oldCh[i].<span class="property">elm</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="谈一下MVVM框架"><a href="#谈一下MVVM框架" class="headerlink" title="谈一下MVVM框架"></a>谈一下MVVM框架</h4><h5 id="web1-0时代："><a href="#web1-0时代：" class="headerlink" title="web1.0时代："></a>web1.0时代：</h5><p>文件全在一起，就是前端和后端的代码全在一起</p><p>问题：</p><ul><li>前端和后端都是一个人开发，技术没有侧重点或者责任不够细分</li><li>项目不好维护</li><li>html、css、js页面的静态内容没有，后端是没办法工作的（没办法套数据）</li></ul><p>mvc…都是后端先出的</p><h5 id="web2-0时代："><a href="#web2-0时代：" class="headerlink" title="web2.0时代："></a>web2.0时代：</h5><p>ajax出现了，前端和后端数据分离了。</p><p>解决问题：后端不用等前端页面弄完没，后端做后端的事情（写接口），前端布局、特效、发送请求</p><p>问题：</p><ul><li>html、css、js都在一个页面中，单个页面可能内容也是比较多的（也会出现不好维护的情况）</li></ul><p><strong>出现前端的框架MVC、MVVM</strong></p><p>解决问题：可以把一个特别大的页面进行拆分（组件化），单个组件进行维护</p><h5 id="什么是MVVM："><a href="#什么是MVVM：" class="headerlink" title="什么是MVVM："></a>什么是MVVM：</h5><p>Model-View-ViewModel 的简写</p><p><img src="/../image/Vue/bg2015020110.png" alt="img"></p><p>view：视图【dom在页面中展示的内容】</p><p>model：模型【数据层：vue中的data数据】</p><p>ViewModel：视图模型层【就是vue源码】</p><p><img src="/../image/Vue/6e5b407e2c6e248dd6cb67d136986a8c.png" alt="img"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文件已定稿，最后修改时间 20240822 16:27&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、Vue脚手架&quot;&gt;&lt;a href=&quot;#一、Vue脚手架&quot; class=&quot;headerlink&quot; title=&quot;一、Vue脚手架&quot;&gt;&lt;/a&gt;一、Vue脚手架&lt;/h2&gt;&lt;p&gt;vue-c</summary>
      
    
    
    
    <category term="Front-end" scheme="http://cychenhaibin.github.io/categories/Front-end/"/>
    
    
    <category term="Front-end" scheme="http://cychenhaibin.github.io/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>算法:双指针</title>
    <link href="http://cychenhaibin.github.io/2024/08/20/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://cychenhaibin.github.io/2024/08/20/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2024-08-19T18:28:47.000Z</published>
    <updated>2024-10-13T05:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、移动零"><a href="#一、移动零" class="headerlink" title="一、移动零"></a>一、移动零</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例1：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 2:</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><ol><li>定义两个指针， left  和  right 。 left  从索引 0 开始， right  也从索引 0 开始。</li><li>遍历数组，使用  right  指针。</li><li>当  right  指针指向的元素不是零时：<ul><li>将  left  指针指向的元素（如果它是一个零）替换为  right  指针指向的元素。</li><li>将  left  指针向前移动一位。</li></ul></li><li>当  right  指针指向的元素是零时，继续向右移动  right  指针，直到找到一个非零元素或到达数组末尾。</li><li>重复步骤 3 和 4，直到  right  指针到达数组末尾。</li><li>当  right  指针遍历完成后， left  指针之前的所有元素都是非零的，并且保持了原始顺序。此时，将  left  指针之后的所有位置填充为零。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>; <span class="comment">// 初始化左指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; nums.<span class="property">length</span>; right++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 交换 left 指针和 right 指针指向的元素</span></span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="comment">// 只有当交换了元素后，left 指针才向前移动</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用零填充 left 指针之后的所有位置</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        nums[left] = <span class="number">0</span>;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="二、盛最多水的容器"><a href="#二、盛最多水的容器" class="headerlink" title="二、盛最多水的容器"></a>二、盛最多水的容器</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> </p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例1：</strong></p><p><img src="/../image/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/question_11.jpg" alt="img"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例2：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><ol><li>初始化两个指针  l  和  r ，分别指向数组  height  的起始和结束位置，即  l &#x3D; 0  和  r &#x3D; n - 1 。</li><li>定义一个变量  <code>maxWater</code>  来存储最大水量，初始值为 0。</li><li>当  l &lt; r  时，执行以下操作：<ul><li>计算当前左右指针高度的较小值，记为  <code>minHeight</code> 。</li><li>计算当前容器的容量，即  <code>minHeight</code>  和指针之间的距离（ r - l ）的乘积，记为  <code>currentWater</code> 。</li><li>如果  <code>currentWater</code>  大于  <code>maxWater</code> ，则更新  <code>maxWater</code> 。</li><li>如果左边的高度小于右边的高度，移动左指针  l  向右一位（ l++ ），否则移动右指针  r  向左一位（ r– ）。</li></ul></li><li>当  l  和  r  相遇或交叉时，结束循环。</li><li>返回  <code>maxWater</code> 。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxWater = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> minHeight = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[l], height[r]);</span><br><span class="line">        <span class="keyword">let</span> currentWater = minHeight * (r - l);</span><br><span class="line">        maxWater = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxWater, currentWater);</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWater;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="三、三数之和"><a href="#三、三数之和" class="headerlink" title="三、三数之和"></a>三、三数之和</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例1：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例2：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例3：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><ol><li><strong>排序</strong>：首先对数组  nums  进行排序。</li><li><strong>初始化</strong>：设置三个指针  i 、 left  和  right 。 i  从索引 0 开始遍历数组， left  和  right  分别指向  i  之后的两个端点。</li><li><strong>遍历</strong>：对于每个  i ：<ul><li>设置  left  为  i + 1 ， right  为数组的最后一个索引。</li><li>执行循环，当  left &lt; right  时：</li><li>计算当前三元组的和： sum &#x3D; nums[i] + nums[left] + nums[right] 。</li><li>如果  sum  等于 0，找到了一个满足条件的三元组，将其添加到结果列表中，然后将  left  和  right  向中间移动，同时跳过重复的元素。</li><li>如果  sum  小于 0，说明需要增大和，因此将  left  向右移动（寻找更大的数）。</li><li>如果  sum  大于 0，说明需要减小和，因此将  right  向左移动（寻找更小的数）。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 对数组进行排序</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复的元素</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([nums[i], nums[left], nums[right]]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="comment">// 跳过重复的元素</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                left++; <span class="comment">// 需要增大和</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--; <span class="comment">// 需要减小和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="四、接雨水"><a href="#四、接雨水" class="headerlink" title="四、接雨水"></a>四、接雨水</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例1：</strong></p><p><img src="/../image/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/rainwatertrap.png" alt="img"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure></blockquote><p><strong>示例2：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><ol><li><strong>初始化</strong>：创建两个数组  <code>leftMax</code>  和  <code>rightMax</code> ，它们的长度与输入数组  <code>height</code>  相同。 <code>leftMax[i]</code>  表示索引  i  左侧最高的柱子高度， <code>rightMax[i]</code>  表示索引  i  右侧最高的柱子高度。</li><li><strong>填充左侧最大高度数组</strong>：从左到右遍历  <code>height</code>  数组，对于每个索引  i ， <code>leftMax[i]</code>  初始化为  <code>height[i]</code> ，然后与  <code>leftMax[i-1]</code>  比较，取较大值。</li><li><strong>填充右侧最大高度数组</strong>：从右到左遍历  <code>height</code>  数组，对于每个索引  i ， <code>rightMax[i]</code>  初始化为  <code>height[i]</code> ，然后与  rightMax[i+1]  比较，取较大值。</li><li><strong>计算雨水量</strong>：遍历  <code>height</code>  数组，对于每个索引  i ，计算当前柱子能接的雨水量，即  <code>min(leftMax[i], rightMax[i]) - height[i]</code> 。如果这个值大于 0，累加到总雨水量  <code>total</code> 。</li><li><strong>返回总雨水量</strong>。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = height.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> leftMax = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">    <span class="keyword">let</span> rightMax = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化左侧最大高度数组</span></span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        leftMax[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(height[i], leftMax[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化右侧最大高度数组</span></span><br><span class="line">    rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rightMax[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(height[i], rightMax[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雨水量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        total += <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(leftMax[i], rightMax[i]) - height[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、移动零&quot;&gt;&lt;a href=&quot;#一、移动零&quot; class=&quot;headerlink&quot; title=&quot;一、移动零&quot;&gt;&lt;/a&gt;一、移动零&lt;/h3&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾</summary>
      
    
    
    
    <category term="算法" scheme="http://cychenhaibin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://cychenhaibin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:哈希</title>
    <link href="http://cychenhaibin.github.io/2024/08/19/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/"/>
    <id>http://cychenhaibin.github.io/2024/08/19/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/</id>
    <published>2024-08-19T12:14:47.000Z</published>
    <updated>2024-10-13T05:20:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、两数之和"><a href="#一、两数之和" class="headerlink" title="一、两数之和"></a>一、两数之和</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例1：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure></blockquote><p><strong>示例2：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例3：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><p>给定一个数组，首先想到的是两次for循环，第一次for循环时拿到第一个元素，第二次for循环时拿到后面的元素，进行判断第一个元素和后面的元素加起来是否是目标值，是则添加到新数组中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">               num.<span class="title function_">push</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="二、字母异位词分组"><a href="#二、字母异位词分组" class="headerlink" title="二、字母异位词分组"></a>二、字母异位词分组</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例1：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 2:</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 3:</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><p>计数方法</p><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        <span class="comment">// 创建了一个长度为26的新数组 count ，并将每个元素初始化为0。</span></span><br><span class="line">        <span class="comment">// 用于存储每个字符出现的次数，其中索引0对应字符&#x27;a&#x27;，索引1对应字符&#x27;b&#x27;，依此类推，直到索引25对应字符&#x27;z&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> count = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="comment">// 计算字符 c 的ASCII码值与字符&#x27;a&#x27;的ASCII码值之间的差</span></span><br><span class="line">            count[c.<span class="title function_">charCodeAt</span>() - <span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>()]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 map 对象中是否已经有一个以当前字符串的字符计数数组为键的数组</span></span><br><span class="line">        <span class="comment">// 如果有，就将当前字符串添加到这个数组中；</span></span><br><span class="line">        <span class="comment">// 如果没有，就创建一个新的数组，并将这个数组与当前字符串关联起来作为 map 对象的一个新键值对。</span></span><br><span class="line">        map[count] ? map[count].<span class="title function_">push</span>(s) : map[count] = [s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(map);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="三、最长连续序列"><a href="#三、最长连续序列" class="headerlink" title="三、最长连续序列"></a>三、最长连续序列</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例1：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例2：</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure></blockquote><p><strong>题解：</strong></p><p>将数组元素存入 set 中<br>遍历<code>nums</code>，如果 当前项 - 1 存在于 set ，说明当前项不是连续序列的起点，忽略，继续遍历<br>如果当前项没有“左邻居”，它就是连续序列的起点，循环查看当前项连续的右邻居有多少个<br>返回最长的连续次数</p><p>此方法的时间复杂度为O(n)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// 把题目中数组的数字全部放入set中，一来去重，二来方便快速查找</span></span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(nums);</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key,a] <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="comment">// 没有左邻居，是序列的起点</span></span><br><span class="line">    <span class="keyword">if</span> (!set.<span class="title function_">has</span>(a - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">let</span> cur = a;</span><br><span class="line">      <span class="comment">// 有右邻居，看连续的右邻居有多少个</span></span><br><span class="line">      <span class="keyword">while</span> (set.<span class="title function_">has</span>(cur + <span class="number">1</span>)) &#123;</span><br><span class="line">        cur++;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 存放最大的连续邻居的值</span></span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先将数组排序，设置计数器等于1，最长连续计数器等于1，如果数组的长度为0，则返回0，遍历数组，如果数组的第一个和他后面的一个值相同，就继续比较，类似 <code>Set</code> 方法，如果数组前一个值加一等于下一个的值，count就加一，否则重置计数器为1，每当遍历完一次回合都要更新一次 <code>maxCount</code> 计数器，将最长序列存储，遍历完成后，返回最长序列的长度</p><p>时间复杂度为O(nlogn)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果数组为空，返回0</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 对数组进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>; <span class="comment">// 初始化连续序列的计数器</span></span><br><span class="line">    <span class="keyword">let</span> maxCount = <span class="number">1</span>; <span class="comment">// 初始化最长连续序列的计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123; <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素与前一个元素相同，则跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素是连续的，增加计数器</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素不是连续的，重置计数器</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCount = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxCount, count); <span class="comment">// 更新最长连续序列的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxCount; <span class="comment">// 返回最长连续序列的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、两数之和&quot;&gt;&lt;a href=&quot;#一、两数之和&quot; class=&quot;headerlink&quot; title=&quot;一、两数之和&quot;&gt;&lt;/a&gt;一、两数之和&lt;/h3&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code</summary>
      
    
    
    
    <category term="算法" scheme="http://cychenhaibin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://cychenhaibin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
